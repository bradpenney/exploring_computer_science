{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#exploring-computer-science","title":"Exploring Computer Science","text":"<p>Decoding the machines that run our world.</p> <p>A subsection of BradPenney.io, this site documents my journey through the Computer Science curriculum. It transforms raw lecture notes into structured, teaching-focused articles designed to explain why things work, not just how.</p>"},{"location":"#curriculum-areas","title":"Curriculum Areas","text":"<ul> <li> <p> Building Blocks</p> <p>Theory \u2014 What is CS?, Computational Thinking, FSMs</p> <p>Languages \u2014 Regex, BNF, RTNs</p> <p>Implementation \u2014 Parsers, Trees, Scheme</p> </li> <li> <p> Programming &amp; Languages</p> <p>Languages \u2014 Scheme Primer</p> <p>Paradigms \u2014 Procedures &amp; Higher-Order Functions</p> <p>Coming Soon \u2014 OOP, Programming Paradigms, Interpreters vs. Compilers</p> </li> <li> <p> Data Structures (Coming Soon)</p> <p>Abstract Data Types \u2014 Stacks, Queues, Deques, &amp; Linked Lists</p> <p>Advanced Structures \u2014 Binary Search Trees, Heaps, and Graphs</p> </li> <li> <p> Algorithms</p> <p>Logic \u2014 Recursion</p> <p>Coming Soon \u2014 Big-O Notation, Turing Machines, Searching, Sorting, and Graph Traversal</p> </li> <li> <p> Systems (Coming Soon)</p> <p>Architecture \u2014 Operating Systems, Virtual Machines, and Networking</p> <p>Infrastructure \u2014 Processes, Threads, Cloud &amp; Edge Computing</p> </li> <li> <p> Modern Topics (Coming Soon)</p> <p>Intelligence \u2014 AI Concepts, Generative Models, &amp; Computer Graphics</p> <p>Impact \u2014 Information Security, Cryptography, and Ethics</p> </li> </ul>"},{"location":"#connect","title":"Connect","text":"<ul> <li>Main site: bradpenney.io</li> <li>Source code: GitHub</li> </ul>"},{"location":"algorithms_complexity/big_o_space_complexity/","title":"Big O: Space Complexity","text":"<p>If Time Complexity is about the clock, Space Complexity is about the workbench.</p> <p>You might have a program that is incredibly fast (low Time Complexity), but if it requires 100GB of RAM to process a 1GB file, it\u2019s going to crash on most computers. As engineers, we must balance how fast we run with how much \"room\" we take up in memory.</p> <p>Space Complexity measures how the total memory usage of an algorithm scales as the input size (\\(N\\)) increases.</p>"},{"location":"algorithms_complexity/big_o_space_complexity/#auxiliary-vs-total-space","title":"Auxiliary vs. Total Space","text":"<p>When we talk about Space Complexity, we usually focus on Auxiliary Space.</p> <ul> <li>Input Space: The memory taken up by the data you were given (the list, the string, the file). You can't control this.</li> <li>Auxiliary Space: The extra or temporary space your algorithm creates to solve the problem.</li> </ul> <p>In most interviews and academic contexts, \"Space Complexity\" refers to Auxiliary Space.</p>"},{"location":"algorithms_complexity/big_o_space_complexity/#common-space-complexities","title":"Common Space Complexities","text":""},{"location":"algorithms_complexity/big_o_space_complexity/#1-o1-constant-space","title":"1. \\(O(1)\\) - Constant Space","text":"<p>The algorithm uses the same amount of memory regardless of the input size. -   Example: A loop that uses a single <code>i</code> variable to iterate. -   Mechanism: You aren't creating new lists or data structures that grow with \\(N\\). -   Vibe: Efficient and \"In-place.\"</p>"},{"location":"algorithms_complexity/big_o_space_complexity/#2-on-linear-space","title":"2. \\(O(N)\\) - Linear Space","text":"<p>The memory usage grows in direct proportion to the input size. -   Example: Creating a copy of a list, or building a new list of the same size. -   Mechanism: If you have 1,000 items and you create a new array to store a modified version of each, you've used \\(O(N)\\) space. -   Vibe: Common, but can be a bottleneck for massive datasets.</p>"},{"location":"algorithms_complexity/big_o_space_complexity/#3-on2-quadratic-space","title":"3. \\(O(N^2)\\) - Quadratic Space","text":"<p>The memory usage grows by the square of the input. -   Example: Creating a 2D grid (matrix) where both the rows and columns are the size of the input. -   Mechanism: Often seen in graph algorithms that use an Adjacency Matrix. -   Vibe: Very expensive. Avoid for large \\(N\\).</p>"},{"location":"algorithms_complexity/big_o_space_complexity/#the-hidden-cost-the-call-stack","title":"The Hidden Cost: The Call Stack","text":"<p>One of the most common ways to accidentally use \\(O(N)\\) space is through Recursion.</p> <p>Every time a function calls itself, the computer has to remember where it was. It \"pushes\" the current function's state onto the Call Stack (remember our article on Stacks?).</p> <pre><code>def sum_list(n):\n    if n &lt;= 0:\n        return 0\n    return n + sum_list(n - 1)\n</code></pre> <p>If you call <code>sum_list(1000)</code>, the computer creates 1,000 \"frames\" in memory, one for each call. This takes \\(O(N)\\) Space, even though you didn't explicitly create a list. If \\(N\\) is too large, you'll get a Stack Overflow error.</p>"},{"location":"algorithms_complexity/big_o_space_complexity/#the-space-time-trade-off","title":"The Space-Time Trade-off","text":"<p>In computer science, we often play a game of \"Trading.\"</p> <ul> <li>Trading Space for Time: You can make an algorithm faster by \"caching\" or \"memoizing\" previous results in a table (using more memory to avoid recalculating).</li> <li>Trading Time for Space: You can save memory by calculating values on-the-fly every time you need them (using more CPU cycles to keep the memory footprint small).</li> </ul> <p>There is rarely a \"perfect\" answer; the best choice depends on your environment. An embedded sensor has very little RAM (prioritize Space), while a cloud server might have terabytes of RAM but needs to serve millions of users per second (prioritize Time).</p>"},{"location":"algorithms_complexity/big_o_space_complexity/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Variable Counting <p>What is the Auxiliary Space Complexity of this function?</p> <pre><code>def find_max(numbers):\n    max_val = numbers[0]\n    for num in numbers:\n        if num &gt; max_val:\n            max_val = num\n    return max_val\n</code></pre> Solution <p>This is \\(O(1)\\).</p> <p>Regardless of whether the <code>numbers</code> list has 10 or 10,000,000 items, we only create one variable (<code>max_val</code>). We are looking at the data, but we aren't storing anything new that scales with the size of the data.</p> Practice Problem 2: List Mapping <p>What is the Space Complexity of this function?</p> <pre><code>def double_list(numbers):\n    new_list = []\n    for num in numbers:\n        new_list.append(num * 2)\n    return new_list\n</code></pre> Solution <p>This is \\(O(N)\\).</p> <p>We are creating a <code>new_list</code>. The size of this list is exactly the same as the input <code>numbers</code>. If <code>numbers</code> grows, <code>new_list</code> grows identically.</p> Practice Problem 3: Grid Creation <p>If you write an algorithm that takes a string of length \\(N\\) and creates a 2D table to compare every character in the string against every other character (like in some DNA sequencing algorithms), what is the space complexity?</p> Solution <p>This is \\(O(N^2)\\).</p> <p>A table that is \\(N\\) wide and \\(N\\) high contains \\(N \\times N\\) cells.</p>"},{"location":"algorithms_complexity/big_o_space_complexity/#key-takeaways","title":"Key Takeaways","text":"Notation Space Usage Example \\(O(1)\\) Fixed Simple variables, in-place swaps. \\(O(N)\\) Linear Arrays, Lists, Recursion stacks. \\(O(N^2)\\) Quadratic Matrices, 2D arrays. <p>Space Complexity reminds us that code doesn't run in a vacuum. Every variable we declare and every function we call takes a bite out of our physical resources. Mastering space complexity is the difference between a program that runs on any machine and a program that only runs on yours.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/","title":"Big O: Time Complexity","text":"<p>If you have two different programs that solve the same problem, how do you know which one is better?</p> <p>You might reach for a stopwatch. You run Program A, it takes 2 seconds. You run Program B, it takes 5 seconds. Case closed? Not quite. What if Program A was running on a $5,000 gaming rig and Program B was running on an old laptop? What if you give them 10 times more data\u2014will they both stay at the same speed ratio?</p> <p>In computer science, we don't measure performance in seconds. We measure it in growth. We ask: \"As the input size (\\(N\\)) increases, how does the number of operations grow?\"</p> <p>This measurement is called Big O Notation.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#the-core-concept-growth","title":"The Core Concept: Growth","text":"<p>Imagine you are looking for a specific name in a phone book of \\(N\\) pages.</p> <ul> <li>Algorithm A (Linear Scan): You check page 1, then page 2, then page 3...</li> <li>Algorithm B (Binary Search): You open to the middle, see the name is in the first half, open to the middle of that half, and so on.</li> </ul> <p>If the phone book has 10 pages, both are fast. But if the phone book has 1,000,000 pages: -   Algorithm A might take 1,000,000 steps. -   Algorithm B will take about 20 steps.</p> <p>Big O doesn't care that the steps take 0.001 milliseconds. It cares about the shape of the curve as \\(N\\) gets huge.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#common-time-complexities","title":"Common Time Complexities","text":"<p>Here are the \"Speeds\" of algorithms, ranked from fastest to slowest:</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#1-o1-constant-time","title":"1. \\(O(1)\\) - Constant Time","text":"<p>The execution time stays the same regardless of how much data you have. -   Example: Accessing an element in an array by its index (<code>arr[5]</code>). -   Vibe: Instant.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#2-olog-n-logarithmic-time","title":"2. \\(O(\\log N)\\) - Logarithmic Time","text":"<p>The number of steps increases slowly as the data grows. Every time you double the data, you only add one more step. -   Example: Binary Search. -   Vibe: Extremely fast, even for billions of items.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#3-on-linear-time","title":"3. \\(O(N)\\) - Linear Time","text":"<p>The number of steps grows exactly in proportion to the data. If you have 10x more data, it takes 10x more time. -   Example: A simple <code>for</code> loop scanning a list. -   Vibe: Fair. Good for small to medium data.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#4-on-log-n-linearithmic-time","title":"4. \\(O(N \\log N)\\) - Linearithmic Time","text":"<p>A bit slower than linear, but still efficient. This is the gold standard for sorting large datasets. -   Example: Merge Sort or Quick Sort. -   Vibe: The best we can usually do for complex tasks like sorting.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#5-on2-quadratic-time","title":"5. \\(O(N^2)\\) - Quadratic Time","text":"<p>The steps grow by the square of the input. If you have 10x more data, it takes 100x more time. -   Example: Nested loops (a loop inside a loop). -   Vibe: Dangerous. Fine for small lists, but will freeze your computer on large ones.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#6-o2n-exponential-time","title":"6. \\(O(2^N)\\) - Exponential Time","text":"<p>The steps double with every single new item of data. -   Example: Recursive solutions for the Traveling Salesperson Problem or the \"naive\" Fibonacci sequence. -   Vibe: Terrifying. Even a small increase in \\(N\\) can make the program take longer than the age of the universe.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#the-two-rules-of-big-o","title":"The Two Rules of Big O","text":"<p>When calculating Big O, we simplify the math using two rules:</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#rule-1-drop-the-constants","title":"Rule 1: Drop the Constants","text":"<p>We don't care if an algorithm takes \\(2N\\) steps or \\(5N\\) steps. In the grand scheme of infinity, they are both just \\(O(N)\\). We look for the \"Class\" of the algorithm, not the exact count.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#rule-2-keep-the-highest-order-term","title":"Rule 2: Keep the Highest Order Term","text":"<p>If an algorithm takes \\(N^2 + N\\) steps, we just call it \\(O(N^2)\\). As \\(N\\) gets large (like a billion), the \\(N\\) becomes so insignificant compared to \\(N^2\\) that it's essentially rounding error.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#why-we-focus-on-the-worst-case","title":"Why We Focus on the \"Worst Case\"","text":"<p>Usually, Big O refers to the Worst Case Scenario (\\(\\Omega\\) and \\(\\Theta\\) are used for best and average, but Big O is the industry standard).</p> <p>Why? Because as engineers, we care about guarantees. If you are building an airplane's flight control system, you don't care how fast it works on a \"lucky\" day; you need to know it will finish its calculations even in the worst-case scenario before the plane hits the ground.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Identify the Big O <p>What is the Big O of the following Python snippet?</p> <pre><code>def print_items(n):\n    for i in range(n):\n        print(i)\n\n    for j in range(n):\n        print(j)\n</code></pre> Solution <p>This is \\(O(N)\\).</p> <p>The code does \\(N\\) operations, then another \\(N\\) operations. That is \\(2N\\). According to Rule 1, we drop the constant. It remains \\(O(N)\\).</p> Practice Problem 2: Nested Loops <p>What is the Big O of this snippet?</p> <pre><code>def print_pairs(items):\n    for i in items:\n        for j in items:\n            print(f\"{i}, {j}\")\n</code></pre> Solution <p>This is \\(O(N^2)\\).</p> <p>For every 1 item in the outer loop, we run the inner loop \\(N\\) times. Since the outer loop also runs \\(N\\) times, we have \\(N \\times N = N^2\\).</p> Practice Problem 3: The Constant Trap <p>What is the Big O of a function that prints the first 1,000 items of a list, regardless of whether the list has 1,000 or 1,000,000 items?</p> Solution <p>This is \\(O(1)\\).</p> <p>Even though 1,000 is a large number, it is a constant. It does not grow as the input size (\\(N\\)) grows. Whether the list has a million or a billion items, the function always does exactly 1,000 steps.</p>"},{"location":"algorithms_complexity/big_o_time_complexity/#key-takeaways","title":"Key Takeaways","text":"Notation Name Growth \\(O(1)\\) Constant Flat \\(O(\\log N)\\) Logarithmic Very Slow \\(O(N)\\) Linear Steady \\(O(N^2)\\) Quadratic Fast \\(O(2^N)\\) Exponential Explosive <p>Big O is the language of efficiency. It allows us to talk about how a program will behave in the future, on hardware we haven't seen yet, with data volumes we haven't reached yet. It is the ultimate tool for scalable engineering.</p>"},{"location":"algorithms_complexity/graph_traversal/","title":"Graph Traversal: BFS vs. DFS","text":"<p>Imagine you are in a large, dark maze. You want to find the exit. You have two choices for how to explore:</p> <ol> <li>Choice A: You walk down every path as far as it goes. If you hit a dead end, you backtrack to the last intersection and try a different turn.</li> <li>Choice B: You explore everything within 5 feet of you. Then everything within 10 feet. Then 15 feet. You gradually expand your search area in circles.</li> </ol> <p>In computer science, these are the two fundamental ways to explore a Graph (a web of connected nodes). They are called Depth-First Search (DFS) and Breadth-First Search (BFS).</p>"},{"location":"algorithms_complexity/graph_traversal/#1-depth-first-search-dfs","title":"1. Depth-First Search (DFS)","text":"<p>DFS is the \"Deep Dive\" approach. It explores one branch as deeply as possible before backtracking.</p>"},{"location":"algorithms_complexity/graph_traversal/#how-it-works","title":"How it works:","text":"<ol> <li>Visit a node.</li> <li>Go to one of its unvisited neighbors.</li> <li>Repeat until you hit a dead end (a node with no unvisited neighbors).</li> <li>Backtrack to the previous node and try another neighbor.</li> </ol>"},{"location":"algorithms_complexity/graph_traversal/#data-structure-the-stack","title":"Data Structure: The Stack","text":"<p>DFS naturally uses a Stack to keep track of where it's been. This is why DFS is almost always implemented using Recursion.</p>"},{"location":"algorithms_complexity/graph_traversal/#best-used-for","title":"Best Used For:","text":"<ul> <li>Solving Puzzles/Mazes: Finding a path from start to finish.</li> <li>Topological Sorting: Scheduling tasks with dependencies.</li> <li>Detecting Cycles: Checking if a graph has a loop.</li> </ul>"},{"location":"algorithms_complexity/graph_traversal/#2-breadth-first-search-bfs","title":"2. Breadth-First Search (BFS)","text":"<p>BFS is the \"Layer-by-Layer\" approach. It visits all the immediate neighbors of a node before moving on to the neighbors' neighbors.</p>"},{"location":"algorithms_complexity/graph_traversal/#how-it-works_1","title":"How it works:","text":"<ol> <li>Visit a node.</li> <li>Add all of its unvisited neighbors to a \"to-do\" list.</li> <li>Visit the first item on that list and add its neighbors to the end of the list.</li> <li>Repeat.</li> </ol>"},{"location":"algorithms_complexity/graph_traversal/#data-structure-the-queue","title":"Data Structure: The Queue","text":"<p>BFS uses a Queue (First-In, First-Out). The first neighbors you see are the first ones you visit.</p>"},{"location":"algorithms_complexity/graph_traversal/#best-used-for_1","title":"Best Used For:","text":"<ul> <li>Shortest Path: In an unweighted graph (like a subway map), BFS is guaranteed to find the path with the fewest steps.</li> <li>Social Networks: Finding \"Friends of Friends\" or \"Degrees of Separation.\"</li> <li>GPS Navigation: Finding the nearest gas station.</li> </ul>"},{"location":"algorithms_complexity/graph_traversal/#visual-comparison","title":"Visual Comparison","text":"Feature DFS (Depth-First) BFS (Breadth-First) Analogy A snake diving deep. A ripple in a pond. Structure Stack (Recursion). Queue. Shortest Path Not guaranteed. Guaranteed (in unweighted graphs). Memory Low (depends on depth). High (must store all neighbors at a level)."},{"location":"algorithms_complexity/graph_traversal/#which-one-should-you-use","title":"Which One Should You Use?","text":"<ul> <li>Use BFS if you need the shortest path, or if you know the target is likely close to your starting point.</li> <li>Use DFS if you need to visit every node in the graph, if the graph is very deep and memory is an issue, or if you are looking for solutions that are far away from the start.</li> </ul>"},{"location":"algorithms_complexity/graph_traversal/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Social Networks <p>LinkedIn shows you \"2nd-degree connections.\" Which algorithm would LinkedIn use to find these people?</p> Solution <p>BFS. </p> <p>LinkedIn looks at your neighbors (1st degree) and then their neighbors (2nd degree). This layer-by-layer exploration is exactly what BFS does.</p> Practice Problem 2: The Maze <p>You are writing a program to solve a maze. You want to explore every possible path to see if any of them lead to a hidden treasure. Which algorithm is more natural to write using recursion?</p> Solution <p>DFS.</p> <p>Recursion uses the \"Call Stack\" automatically. DFS's logic of \"Go deep, then backtrack\" maps perfectly to how recursive functions work.</p>"},{"location":"algorithms_complexity/graph_traversal/#key-takeaways","title":"Key Takeaways","text":"Algorithm Order of Exploration Tool DFS Deepest first. Stack / Recursion. BFS Widest first. Queue. <p>Whether you are crawling the web, routing internet packets, or analyzing DNA, BFS and DFS are your primary tools for navigating the complex web of information that makes up our world.</p>"},{"location":"algorithms_complexity/recursion/","title":"Recursion","text":""},{"location":"algorithms_complexity/recursion/#description-master-the-art-of-self-reference-understanding-base-cases-recursive-steps-and-how-the-call-stack-works","title":"description: Master the art of self-reference: Understanding base cases, recursive steps, and how the call stack works.","text":""},{"location":"algorithms_complexity/recursion/#recursion-the-art-of-self-reference","title":"Recursion: The Art of Self-Reference","text":"<p>To understand recursion, you must first understand recursion.</p> <p>This old programmer's joke actually contains the core definition: Recursion is a technique where a function calls itself to solve a smaller version of the same problem. It is a fundamental concept that allows us to solve complex, nested problems with elegant, simple code.</p>"},{"location":"algorithms_complexity/recursion/#the-two-golden-rules","title":"The Two Golden Rules","text":"<p>A recursive function without rules is a recipe for a computer crash. Every recursive function must have two parts:</p> <ol> <li>The Base Case (The Stop): This is the condition that tells the function when to stop calling itself. Without a base case, the function will run forever (until the computer runs out of memory).</li> <li>The Recursive Case (The Step): This is where the function calls itself, but with a smaller or simpler input. This ensures that we are always moving toward the base case.</li> </ol>"},{"location":"algorithms_complexity/recursion/#example-the-countdown","title":"Example: The Countdown","text":"<p>Imagine a function that counts down from \\(N\\) to 1.</p> <p>Iterative (Loop) Approach: <pre><code>def countdown(n):\n    while n &gt; 0:\n        print(n)\n        n = n - 1\n</code></pre></p> <p>Recursive Approach: <pre><code>def countdown_recursive(n):\n    # 1. Base Case\n    if n &lt;= 0:\n        return\n\n    # 2. Action\n    print(n)\n\n    # 3. Recursive Case (Smaller input)\n    countdown_recursive(n - 1)\n</code></pre></p>"},{"location":"algorithms_complexity/recursion/#how-the-computer-remembers-the-call-stack","title":"How the Computer Remembers: The Call Stack","text":"<p>When a function calls itself, the computer doesn't just \"jump.\" It has to remember where it was so it can come back and finish. It does this using the Call Stack.</p> <p>Every time a recursive call is made, a new \"frame\" is pushed onto the stack. When the base case is hit, the computer starts \"popping\" those frames off one by one, finishing each function in reverse order.</p> <p>The Danger: Stack Overflow Because the stack takes up memory (\\(O(N)\\) Space Complexity), you can't recurse forever. If you try to calculate <code>countdown(100000000)</code>, you will likely get a <code>RecursionError</code> or a Stack Overflow, because the computer ran out of room on the stack.</p>"},{"location":"algorithms_complexity/recursion/#real-world-use-cases","title":"Real-World Use Cases","text":"<p>Recursion isn't just for math; it\u2019s for nested structures.</p>"},{"location":"algorithms_complexity/recursion/#1-file-systems","title":"1. File Systems","text":"<p>A folder contains files... and other folders. To calculate the total size of a folder, you look at every item: if it\u2019s a file, add its size; if it\u2019s a folder, call the size function again on that folder.</p>"},{"location":"algorithms_complexity/recursion/#2-searching-and-sorting","title":"2. Searching and Sorting","text":"<p>As we saw in Merge Sort and Quick Sort, recursion is the primary way we implement \"Divide and Conquer\" strategies.</p>"},{"location":"algorithms_complexity/recursion/#3-tree-traversal","title":"3. Tree Traversal","text":"<p>In Binary Trees, every node has a left and right child, which are themselves small binary trees. Recursion is the natural way to walk through these structures.</p>"},{"location":"algorithms_complexity/recursion/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: The Factorial <p>The factorial of \\(N\\) (\\(N!\\)) is \\(N   imes (N-1)  imes (N-2) \u2026    imes 1\\). Example: \\(3! = 3    imes 2  imes 1 = 6\\).</p> <p>Write the rules for a recursive <code>factorial(n)</code> function.</p> Solution <ol> <li>Base Case: If \\(n = 1\\), return 1.</li> <li>Recursive Case: Return \\(n \\times factorial(n - 1)\\).</li> </ol> <p>Tracing factorial(3): - <code>factorial(3)</code> calls <code>3 * factorial(2)</code> - <code>factorial(2)</code> calls <code>2 * factorial(1)</code> - <code>factorial(1)</code> returns <code>1</code> - Result: <code>3 * 2 * 1 = 6</code>.</p> Practice Problem 2: The Infinite Loop <p>What happens if you forget the Base Case?</p> Solution <p>The function will continue to call itself with smaller and smaller (or larger and larger) numbers forever. Eventually, the computer will run out of memory dedicated to the Call Stack, and the program will crash with a Stack Overflow.</p>"},{"location":"algorithms_complexity/recursion/#key-takeaways","title":"Key Takeaways","text":"Rule Purpose Base Case Prevents infinite loops; the exit strategy. Recursive Case Breaks the problem into a smaller version of itself. Call Stack The memory where the computer tracks recursive calls (\\(O(N)\\) space)."},{"location":"algorithms_complexity/recursion/#further-reading","title":"Further Reading","text":"<ul> <li>Scheme Primer \u2014 A guide to a language that uses recursion for everything (no loops allowed!)</li> </ul> <p>Recursion is a mindset shift. Instead of thinking about \"Doing this 10 times,\" you think about \"Doing this once, then doing it again for the rest.\" Mastering recursion is the key to unlocking the most powerful and elegant algorithms in computer science.</p>"},{"location":"algorithms_complexity/searching_linear_vs_binary/","title":"Searching: Linear vs. Binary","text":"<p>Whether you are looking for a specific email in your inbox, a name in a contact list, or a value in a database, you are performing a search. </p> <p>In computer science, searching is one of the most common tasks a computer performs. However, the way you organize your data determines whether that search takes a fraction of a second or several minutes.</p>"},{"location":"algorithms_complexity/searching_linear_vs_binary/#1-linear-search-the-simple-scan","title":"1. Linear Search: The Simple Scan","text":"<p>Linear Search is the most basic search algorithm. It starts at the beginning of a collection and checks every single item, one by one, until it finds what it\u2019s looking for or reaches the end.</p>"},{"location":"algorithms_complexity/searching_linear_vs_binary/#how-it-works","title":"How it works:","text":"<ol> <li>Start at the first item.</li> <li>Is this the item? <ul> <li>If yes, stop.</li> <li>If no, move to the next item.</li> </ul> </li> <li>Repeat until found or list ends.</li> </ol>"},{"location":"algorithms_complexity/searching_linear_vs_binary/#the-complexity-on","title":"The Complexity: \\(O(N)\\)","text":"<p>In the worst-case scenario (the item is at the very end or not there at all), you have to look at all \\(N\\) items. If the list doubles in size, the search takes twice as long.</p>"},{"location":"algorithms_complexity/searching_linear_vs_binary/#when-to-use-it","title":"When to use it:","text":"<ul> <li>When the data is unsorted.</li> <li>When the list is very small.</li> <li>When you don't care about performance.</li> </ul>"},{"location":"algorithms_complexity/searching_linear_vs_binary/#2-binary-search-divide-and-conquer","title":"2. Binary Search: Divide and Conquer","text":"<p>Binary Search is a much faster algorithm, but it comes with a strict requirement: The data must be sorted.</p> <p>If you are looking for a name in a phone book, you don't start at page 1. You open to the middle. If the name you want comes \"after\" the middle page alphabetically, you know for a fact that the name is not in the first half. You just eliminated 500,000 pages in a single step.</p>"},{"location":"algorithms_complexity/searching_linear_vs_binary/#how-it-works_1","title":"How it works:","text":"<ol> <li>Find the middle element of the sorted list.</li> <li>Is this the item? If yes, stop.</li> <li>Is the item smaller than the middle?<ul> <li>If yes, throw away the right half and repeat the process on the left half.</li> </ul> </li> <li>Is the item larger than the middle?<ul> <li>If yes, throw away the left half and repeat the process on the right half.</li> </ul> </li> </ol>"},{"location":"algorithms_complexity/searching_linear_vs_binary/#the-complexity-olog-n","title":"The Complexity: \\(O(\\log N)\\)","text":"<p>Every step cuts the remaining work in half. This is \"Logarithmic\" growth. </p>"},{"location":"algorithms_complexity/searching_linear_vs_binary/#why-log-n-is-a-superpower","title":"Why \\(\\log N\\) is a Superpower:","text":"<p>Look at how many steps it takes to find an item in a list of size \\(N\\):</p> \\(N\\) (Items) Linear Search (Max Steps) Binary Search (Max Steps) 10 10 ~4 1,000 1,000 ~10 1,000,000 1,000,000 ~20 4,000,000,000 4,000,000,000 ~32 <p>Binary Search can find one specific person in the entire population of Earth in about 33 steps. Linear search would take years.</p>"},{"location":"algorithms_complexity/searching_linear_vs_binary/#the-trade-off-to-sort-or-not-to-sort","title":"The Trade-off: To Sort or Not to Sort?","text":"<p>If Binary Search is so much faster, why do we ever use Linear Search?</p> <p>The answer is the Cost of Sorting. Sorting a list takes time (usually \\(O(N \\log N)\\)). </p> <ul> <li>If you are only going to search a list once, it is faster to just do a Linear Search \\(O(N)\\) than it is to Sort it \\(O(N \\log N)\\) and then Search it \\(O(\\log N)\\).</li> <li>If you are going to search a list many times, it is much better to Sort it once and then perform lightning-fast Binary Searches forever.</li> </ul>"},{"location":"algorithms_complexity/searching_linear_vs_binary/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: The Sorted Requirement <p>You have a list of unsorted IDs: <code>[45, 12, 89, 33, 27]</code>. You want to find <code>33</code>. Can you use Binary Search?</p> Solution <p>No. Binary Search relies on the data being ordered. In this unsorted list, the \"middle\" element is 89. Since 33 is smaller than 89, Binary Search would throw away everything to the right of 89. But in an unsorted list, 33 could be anywhere! You would miss it.</p> Practice Problem 2: Steps in Binary Search <p>If you have a sorted list of 128 items, what is the maximum number of steps Binary Search will take to find an item?</p> Solution <p>7 steps. </p> <p>Binary search halves the list each time: 128 -&gt; 64 -&gt; 32 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1. (Mathematically, \\(2^7 = 128\\), so \\(\\log_2(128) = 7\\)).</p> Practice Problem 3: Practical Choice <p>You are building a feature for a music app that lets a user search through their 50 favorite songs. The list is updated frequently. Which algorithm would you use?</p> Solution <p>Linear Search.</p> <p>With only 50 items, the difference between \\(O(N)\\) and \\(O(\\log N)\\) is measured in microseconds\u2014humans won't notice. Since the list is updated frequently, sorting it every time it changes would likely be more \"expensive\" than just doing a quick linear scan when the user types.</p>"},{"location":"algorithms_complexity/searching_linear_vs_binary/#key-takeaways","title":"Key Takeaways","text":"Algorithm Complexity Requirement Strategy Linear Search \\(O(N)\\) None Check every item. Binary Search \\(O(\\log N)\\) Must be Sorted Divide and Conquer. <p>Searching is the first place where we see how Data Structures (how we organize data) directly impact Algorithms (how we process data). By simply keeping a list sorted, we transform a task from \"Impossible for large data\" to \"Instant.\"</p>"},{"location":"algorithms_complexity/sorting_elementary/","title":"Sorting: Elementary Sorts","text":"<p>Sorting is one of the oldest and most fundamental problems in computer science. How do you take a chaotic list of numbers and arrange them perfectly from smallest to largest?</p> <p>Before we get to the lightning-fast algorithms that power modern databases, we must look at the Elementary Sorts. These algorithms are intuitive and easy to write, but they are also slow (\\(O(N^2)\\)). They are the \"learning wheels\" of algorithm design.</p>"},{"location":"algorithms_complexity/sorting_elementary/#1-bubble-sort","title":"1. Bubble Sort","text":"<p>Bubble Sort gets its name because larger elements \"bubble\" to the top (end) of the list with each pass.</p>"},{"location":"algorithms_complexity/sorting_elementary/#the-algorithm","title":"The Algorithm","text":"<ol> <li>Compare the first item with the second item.</li> <li>If the first is greater than the second, swap them.</li> <li>Move to the next pair (2nd and 3rd) and repeat until the end of the list.</li> <li>At this point, the largest item is guaranteed to be at the very end.</li> <li>Repeat the process for the remaining unsorted items (ignoring the end).</li> </ol>"},{"location":"algorithms_complexity/sorting_elementary/#visual-example-5-1-4-2","title":"Visual Example: <code>[5, 1, 4, 2]</code>","text":"<p>Pass 1: -   <code>[5, 1]</code>: Swap -&gt; <code>[1, 5, 4, 2]</code> -   <code>[5, 4]</code>: Swap -&gt; <code>[1, 4, 5, 2]</code> -   <code>[5, 2]</code>: Swap -&gt; <code>[1, 4, 2, 5]</code> (Notice 5 has bubbled to the end)</p> <p>Pass 2: -   <code>[1, 4]</code>: Correct -&gt; <code>[1, 4, 2, 5]</code> -   <code>[4, 2]</code>: Swap -&gt; <code>[1, 2, 4, 5]</code> (Notice 4 is now in place)</p> <p>Pass 3: -   <code>[1, 2]</code>: Correct -&gt; <code>[1, 2, 4, 5]</code> (List is sorted)</p>"},{"location":"algorithms_complexity/sorting_elementary/#the-complexity-on2","title":"The Complexity: \\(O(N^2)\\)","text":"<p>In the worst case (a reverse-ordered list), we have to make roughly \\(N^2\\) comparisons. It's fine for 10 items, but terrible for 10,000.</p>"},{"location":"algorithms_complexity/sorting_elementary/#2-selection-sort","title":"2. Selection Sort","text":"<p>Selection Sort works by dividing the list into two parts: the sorted part at the beginning and the unsorted part at the end. It repeatedly selects the smallest remaining item and moves it to the sorted part.</p>"},{"location":"algorithms_complexity/sorting_elementary/#the-algorithm_1","title":"The Algorithm","text":"<ol> <li>Scan the entire unsorted list to find the minimum value.</li> <li>Swap that minimum value with the first unsorted item.</li> <li>Advance the \"sorted\" boundary by one.</li> <li>Repeat.</li> </ol>"},{"location":"algorithms_complexity/sorting_elementary/#visual-example-5-1-4-2_1","title":"Visual Example: <code>[5, 1, 4, 2]</code>","text":"<p>Pass 1: -   Sorted: <code>[]</code>, Unsorted: <code>[5, 1, 4, 2]</code> -   Find Min in unsorted: <code>1</code> -   Swap <code>1</code> with first item (<code>5</code>): <code>[1, 5, 4, 2]</code></p> <p>Pass 2: -   Sorted: <code>[1]</code>, Unsorted: <code>[5, 4, 2]</code> -   Find Min in unsorted: <code>2</code> -   Swap <code>2</code> with first unsorted (<code>5</code>): <code>[1, 2, 4, 5]</code></p> <p>Pass 3: -   Sorted: <code>[1, 2]</code>, Unsorted: <code>[4, 5]</code> -   Find Min in unsorted: <code>4</code> -   Swap <code>4</code> with itself (it's already first): <code>[1, 2, 4, 5]</code></p>"},{"location":"algorithms_complexity/sorting_elementary/#the-complexity-on2_1","title":"The Complexity: \\(O(N^2)\\)","text":"<p>Even though Selection Sort usually performs fewer swaps than Bubble Sort, it still requires scanning the remaining list over and over again, resulting in \\(N^2\\) comparisons.</p>"},{"location":"algorithms_complexity/sorting_elementary/#why-learn-these","title":"Why Learn These?","text":"<p>If these are slow, why bother?</p> <ol> <li>Simplicity: They are very easy to implement (3-5 lines of code).</li> <li>Memory: They are In-Place algorithms, meaning they require \\(O(1)\\) Auxiliary Space. You don't need to create a second list.</li> <li>Specific Cases:<ul> <li>Bubble Sort is actually very fast (\\(O(N)\\)) if the list is already almost sorted (it can detect this and stop early).</li> <li>Selection Sort minimizes the number of writes/swaps, which can be useful if writing to memory is expensive (like writing to Flash storage).</li> </ul> </li> </ol>"},{"location":"algorithms_complexity/sorting_elementary/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Bubble Sort Steps <p>Perform the first full pass of Bubble Sort on this list: <code>[3, 2, 5, 1]</code>.</p> Solution <ol> <li>Compare <code>3, 2</code>: Swap -&gt; <code>[2, 3, 5, 1]</code></li> <li>Compare <code>3, 5</code>: Keep -&gt; <code>[2, 3, 5, 1]</code></li> <li>Compare <code>5, 1</code>: Swap -&gt; <code>[2, 3, 1, 5]</code></li> </ol> <p>Result: <code>[2, 3, 1, 5]</code> (5 has bubbled to the end).</p> Practice Problem 2: Selection Sort Choice <p>You have a list of numbers where swapping items is extremely costly (takes a long time), but comparing them is fast. Would you prefer Bubble Sort or Selection Sort?</p> Solution <p>Selection Sort.</p> <p>Selection Sort only swaps once per pass (after finding the minimum). Bubble Sort might swap many, many times per pass as items bubble up. Selection Sort minimizes the number of writes.</p>"},{"location":"algorithms_complexity/sorting_elementary/#key-takeaways","title":"Key Takeaways","text":"Algorithm Best Case Worst Case Main Feature Bubble Sort \\(O(N)\\) (Already sorted) \\(O(N^2)\\) Bubbles largest to end. Simple. Selection Sort \\(O(N^2)\\) \\(O(N^2)\\) Selects smallest to start. Minimizes swaps. <p>These elementary sorts teach us the basics of iteration and swapping. But for real-world data, we need something smarter\u2014something that doesn't just scan, but divides. That leads us to Efficient Sorts.</p>"},{"location":"algorithms_complexity/sorting_insertion/","title":"Sorting: Insertion Sort","text":"<p>If you\u2019ve ever been dealt a hand of playing cards and arranged them from lowest to highest, you\u2019ve likely used Insertion Sort without knowing it.</p> <p>You pick up one card at a time. You look at the cards already in your hand, find the correct spot for the new card, and slide it in. Everything to the right of that spot shifts over to make room. This simple, intuitive process is exactly how the algorithm works.</p>"},{"location":"algorithms_complexity/sorting_insertion/#the-mechanism","title":"The Mechanism","text":"<p>Insertion Sort divides the list into a sorted part (on the left) and an unsorted part (on the right). </p> <ol> <li>Start with the second item in the list (the first item is \"sorted\" by itself).</li> <li>Compare this \"current\" item with the items to its left.</li> <li>Shift the sorted items to the right until you find the correct position for the current item.</li> <li>Insert the item.</li> <li>Repeat for the next unsorted item.</li> </ol>"},{"location":"algorithms_complexity/sorting_insertion/#visual-example-5-2-4-1","title":"Visual Example: <code>[5, 2, 4, 1]</code>","text":"<p>Step 1: <code>[5 | 2, 4, 1]</code> (5 is the sorted part) -   Current item is <code>2</code>. -   Is 2 &lt; 5? Yes. Shift 5 to the right. -   Insert 2: <code>[2, 5 | 4, 1]</code></p> <p>Step 2: <code>[2, 5 | 4, 1]</code> -   Current item is <code>4</code>. -   Is 4 &lt; 5? Yes. Shift 5 to the right. -   Is 4 &lt; 2? No.  -   Insert 4: <code>[2, 4, 5 | 1]</code></p> <p>Step 3: <code>[2, 4, 5 | 1]</code> -   Current item is <code>1</code>. -   Compare with 5, 4, and 2. Shift them all to the right. -   Insert 1: <code>[1, 2, 4, 5]</code> (List is sorted)</p>"},{"location":"algorithms_complexity/sorting_insertion/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"algorithms_complexity/sorting_insertion/#time-complexity","title":"Time Complexity","text":"<ul> <li>Worst Case: \\(O(N^2)\\)      If the list is in reverse order, every item has to be compared and shifted across the entire sorted part.</li> <li>Best Case: \\(O(N)\\)     If the list is already sorted, the algorithm only makes one comparison per item and never shifts anything. This makes it incredibly efficient for \"nearly sorted\" data.</li> </ul>"},{"location":"algorithms_complexity/sorting_insertion/#space-complexity","title":"Space Complexity","text":"<ul> <li>Auxiliary Space: \\(O(1)\\)     Like Bubble and Selection sort, it is an In-Place algorithm. It only needs one extra variable to hold the \"current\" item being moved.</li> </ul>"},{"location":"algorithms_complexity/sorting_insertion/#insertion-sort-vs-the-others","title":"Insertion Sort vs. The Others","text":"<p>Why use Insertion Sort when we have Bubble or Selection sort?</p> <ol> <li>Stability: It is a Stable sort. If you have two items with the same value (e.g., two \"7\" cards), their relative order won't change. This is important when sorting complex objects (like sorting a list of students by grade, then by name).</li> <li>Online Processing: It can sort a list as it receives it. You can keep adding new items to a sorted list and Insertion Sort will efficiently place them.</li> <li>Performance on Small Data: For very small lists (typically 10-20 items), Insertion Sort is often faster than even the high-speed algorithms like Merge Sort because it has very low overhead.</li> </ol>"},{"location":"algorithms_complexity/sorting_insertion/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Insertion Sort Pass <p>Given the list <code>[8, 10, 3, 5]</code>, show the state of the list after the item <code>3</code> has been inserted into its correct position.</p> Solution <ol> <li>Start: <code>[8, 10, 3, 5]</code></li> <li>Sorted part is <code>[8, 10]</code>. Next item is <code>3</code>.</li> <li>3 &lt; 10 (Shift), 3 &lt; 8 (Shift).</li> <li>Result: <code>[3, 8, 10, 5]</code></li> </ol> Practice Problem 2: When to Choose Insertion Sort <p>You are receiving a stream of sensor data, one number every 5 seconds. You want to keep a running \"Top 10\" list of the highest values seen so far. Which sort is best for inserting the new value into the existing list?</p> Solution <p>Insertion Sort.</p> <p>Since you are adding one item at a time to an already sorted list, Insertion Sort only takes a few comparisons to find the spot and shift the others. This is its \"Best Case\" (\\(O(N)\\)) scenario.</p>"},{"location":"algorithms_complexity/sorting_insertion/#key-takeaways","title":"Key Takeaways","text":"Feature Details Logic Insert the next item into its correct spot in the sorted sub-list. Best Case \\(O(N)\\) (Already sorted). Worst Case \\(O(N^2)\\) (Reverse sorted). Space \\(O(1)\\) (In-place). Use Case Small datasets or nearly sorted data. <p>Insertion Sort is the bridge between human intuition and algorithmic efficiency. It\u2019s the \"practical\" elementary sort\u2014the one you'll actually see used in production inside more complex \"Hybrid\" sorting algorithms (like Timsort, which is used in Python and Java).</p>"},{"location":"algorithms_complexity/sorting_merge/","title":"Sorting: Merge Sort","text":"<p>Elementary sorts like Bubble Sort work by comparing every item against every other item, leading to slow \\(O(N^2)\\) performance. To sort millions of items, we need a smarter approach. We need to stop comparing and start dividing.</p> <p>Merge Sort is a classic \"Divide and Conquer\" algorithm. It follows a simple philosophy: It is easier to combine two small, sorted lists than it is to sort one giant, messy list.</p>"},{"location":"algorithms_complexity/sorting_merge/#the-concept","title":"The Concept","text":"<p>Merge Sort works in two phases: 1.  Divide (Split): Recursively cut the list in half until you have \\(N\\) lists, each containing just one item. (A list of one item is, by definition, sorted!) 2.  Conquer (Merge): Take pairs of these small sorted lists and merge them together into larger sorted lists. Repeat until you have one giant sorted list.</p>"},{"location":"algorithms_complexity/sorting_merge/#the-algorithm","title":"The Algorithm","text":""},{"location":"algorithms_complexity/sorting_merge/#phase-1-the-recursive-split","title":"Phase 1: The Recursive Split","text":"<p>Imagine trying to sort <code>[38, 27, 43, 3]</code>.</p> <ol> <li>Split into <code>[38, 27]</code> and <code>[43, 3]</code>.</li> <li>Split again into <code>[38]</code>, <code>[27]</code>, <code>[43]</code>, <code>[3]</code>.<ul> <li>Now we have 4 lists. Each has 1 item. Each is sorted.</li> </ul> </li> </ol>"},{"location":"algorithms_complexity/sorting_merge/#phase-2-the-merge","title":"Phase 2: The Merge","text":"<p>Now we \"zip\" them back together.</p> <ol> <li>Merge <code>[38]</code> and <code>[27]</code>.<ul> <li>Compare 38 vs 27. Take 27. Then take 38.</li> <li>Result: <code>[27, 38]</code></li> </ul> </li> <li>Merge <code>[43]</code> and <code>[3]</code>.<ul> <li>Compare 43 vs 3. Take 3. Then take 43.</li> <li>Result: <code>[3, 43]</code></li> </ul> </li> <li>Final Merge: Merge <code>[27, 38]</code> and <code>[3, 43]</code>.<ul> <li>Compare 27 vs 3. Take 3.</li> <li>Compare 27 vs 43. Take 27.</li> <li>Compare 38 vs 43. Take 38.</li> <li>Take 43.</li> <li>Final Result: <code>[3, 27, 38, 43]</code></li> </ul> </li> </ol>"},{"location":"algorithms_complexity/sorting_merge/#why-is-it-faster-on-log-n","title":"Why Is It Faster? (\\(O(N \\\\\\log N)\\))","text":"<p>The speed comes from the structure of the recursion tree.</p> <ul> <li>Height of the Tree (\\(\\\\\\log N\\)): Because we divide the list in half every time, the number of \"levels\" is \\(\\\\\\log_2 N\\). (For 8 items, 3 levels. For 1,000,000 items, only 20 levels).</li> <li>Work per Level (\\(N\\)): At each level, we iterate through all \\(N\\) items to merge them.</li> </ul> <p>So, the total work is: Height (\\(\\\\\\log N\\)) \u00d7 Width (\\(N\\)) = \\(O(N \\\\\\log N)\\).</p> <p>This is massively faster than \\(O(N^2)\\). For 1 million items: -   Bubble Sort: \\(1,000,000^2 = 1,000,000,000,000\\) operations. -   Merge Sort: \\(1,000,000 \\\\times 20 = 20,000,000\\) operations. Merge Sort is 50,000 times faster.</p>"},{"location":"algorithms_complexity/sorting_merge/#the-trade-off-space-complexity","title":"The Trade-off: Space Complexity","text":"<p>There is no free lunch. Merge Sort is fast, but it is not In-Place.</p> <p>To merge two lists, you typically need to create a temporary array to hold the sorted result before copying it back. If you are sorting 1GB of data, Merge Sort needs another 1GB of RAM to hold these temporary arrays.</p> <ul> <li>Time Complexity: \\(O(N \\\\\\log N)\\) (Always - Best, Average, and Worst).</li> <li>Space Complexity: \\(O(N)\\) (Auxiliary).</li> </ul>"},{"location":"algorithms_complexity/sorting_merge/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: The Split Depth <p>If you run Merge Sort on a list of 16 items, how many times will you split the list before you start merging?</p> Solution <p>4 times.</p> <p>\\(16 \\\\rightarrow 8 \\\\rightarrow 4 \\\\rightarrow 2 \\\\rightarrow 1\\). This corresponds to \\(\\\\\\log_2(16) = 4\\).</p> Practice Problem 2: Stability <p>Merge Sort is a Stable sort (it preserves the original order of equal elements). Why is this true during the merge step?</p> Solution <p>When merging two sub-lists (Left and Right), if we encounter equal values (e.g., <code>5</code> in Left and <code>5</code> in Right), the algorithm is designed to pick the value from the Left list first. This ensures that the item that appeared earlier in the original list stays earlier in the sorted list.</p>"},{"location":"algorithms_complexity/sorting_merge/#key-takeaways","title":"Key Takeaways","text":"Feature Details Strategy Divide and Conquer. Speed \\(O(N \\\\\\log N)\\) (Very Fast). Consistency Performs reliably on all data (Worst Case is same as Best Case). Downside Requires \\(O(N)\\) extra memory (Space). <p>Merge Sort teaches us that structure matters. By organizing our data flow into a tree structure, we bypass the limitations of brute-force comparison. It is the workhorse algorithm for sorting Linked Lists and large external datasets that don't fit in RAM.</p>"},{"location":"algorithms_complexity/sorting_quick/","title":"Sorting: Quick Sort","text":"<p>Merge Sort is excellent, but it requires a lot of extra memory (\\(O(N)\\)) to stitch lists back together. Can we achieve the same \\(O(N \\log N)\\) speed without the memory cost?</p> <p>Enter Quick Sort.</p> <p>Quick Sort is another \"Divide and Conquer\" algorithm, but it flips the logic of Merge Sort. Instead of doing the hard work (merging) after the recursive calls, Quick Sort does the hard work (partitioning) before the recursive calls.</p>"},{"location":"algorithms_complexity/sorting_quick/#the-strategy-partitioning","title":"The Strategy: Partitioning","text":"<p>The heart of Quick Sort is the Partition operation.</p> <ol> <li>Pick a Pivot: Choose one element from the list (e.g., the last item). This value becomes our reference point.</li> <li>Reorder: Shuffle the array so that:<ul> <li>All numbers smaller than the Pivot move to its Left.</li> <li>All numbers larger than the Pivot move to its Right.</li> </ul> </li> <li>Place Pivot: Put the Pivot in its final, correct position between the two groups.</li> </ol> <p>At this point, the Pivot is \"sorted.\" It will never move again.</p>"},{"location":"algorithms_complexity/sorting_quick/#visual-example-5-2-9-1-3","title":"Visual Example: <code>[5, 2, 9, 1, 3]</code>","text":"<p>Let's pick the last element, <code>3</code>, as the Pivot.</p> <ol> <li>Compare <code>5</code> vs <code>3</code>: Bigger. Stay.</li> <li>Compare <code>2</code> vs <code>3</code>: Smaller. Swap to front. <code>[2, 5, 9, 1, 3]</code></li> <li>Compare <code>9</code> vs <code>3</code>: Bigger. Stay.</li> <li>Compare <code>1</code> vs <code>3</code>: Smaller. Swap to front. <code>[2, 1, 9, 5, 3]</code></li> <li>Place Pivot: Swap <code>3</code> into the middle (between small and big). <code>[2, 1, 3, 5, 9]</code></li> </ol> <p>Now <code>3</code> is in its final home. We recursively apply the same logic to the left sub-list <code>[2, 1]</code> and the right sub-list <code>[5, 9]</code>.</p>"},{"location":"algorithms_complexity/sorting_quick/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"algorithms_complexity/sorting_quick/#time-complexity","title":"Time Complexity","text":"<ul> <li>Average Case: \\(O(N \\log N)\\)     If the Pivot divides the list roughly in half every time, we get the same efficient tree structure as Merge Sort.</li> <li>Worst Case: \\(O(N^2)\\)     If you get unlucky and pick the smallest or largest item as the Pivot every single time (e.g., trying to sort a list that is already sorted), the \"Divide\" step doesn't divide anything. You just peel off one item at a time. This degrades to Bubble Sort performance.</li> </ul>"},{"location":"algorithms_complexity/sorting_quick/#space-complexity","title":"Space Complexity","text":"<ul> <li>Space: \\(O(\\log N)\\)     Quick Sort sorts In-Place. It doesn't need to create new arrays. However, it does use stack space for the recursion (about \\(\\log N\\) stack frames). This is significantly better than Merge Sort's \\(O(N)\\) memory requirement.</li> </ul>"},{"location":"algorithms_complexity/sorting_quick/#the-pivot-problem","title":"The Pivot Problem","text":"<p>Since the speed depends heavily on picking a \"good\" pivot (one that is near the median value), optimizations often focus on pivot selection: -   Random Pivot: Pick a random index. -   Median-of-Three: Look at the first, middle, and last item, and pick the median of those three.</p>"},{"location":"algorithms_complexity/sorting_quick/#quick-sort-vs-merge-sort","title":"Quick Sort vs. Merge Sort","text":"Feature Quick Sort Merge Sort Speed Usually faster (better cache locality). Consistent \\(O(N \\log N)\\). Memory Low (\\(O(\\log N)\\) stack). High (\\(O(N)\\) array). Worst Case \\(O(N^2)\\) (Can be mitigated). \\(O(N \\log N)\\) (Guaranteed). Stability Unstable (Swaps scramble order). Stable (Preserves order)."},{"location":"algorithms_complexity/sorting_quick/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: The Partition <p>Given the list <code>[10, 80, 30, 90, 40, 50, 70]</code>, and choosing the last element (<code>70</code>) as the Pivot, which numbers will end up to the LEFT of 70 after the partition step?</p> Solution <p>Any number less than 70.</p> <p>Left Side: <code>10, 30, 40, 50</code> Pivot: <code>70</code> Right Side: <code>80, 90</code></p> Practice Problem 2: Worst Case Scenario <p>You implement a basic Quick Sort that always picks the first element as the pivot. You run it on the list <code>[1, 2, 3, 4, 5]</code>. What is the Time Complexity?</p> Solution <p>\\(O(N^2)\\).</p> <p>Because the list is already sorted, picking the first element (<code>1</code>) means everything else is \"greater\". You partition into an empty left side and a massive right side. Then you pick <code>2</code>, and do the same. You never divide the problem in half; you just reduce it by 1 each time.</p>"},{"location":"algorithms_complexity/sorting_quick/#key-takeaways","title":"Key Takeaways","text":"Feature Details Strategy Partition around a Pivot. Speed \\(O(N \\log N)\\) (Average). Memory Efficient (In-Place). Weakness Bad Pivots lead to \\(O(N^2)\\) slowness. <p>Quick Sort is the gambler of sorting algorithms. It takes a risk (picking a pivot) that usually pays off with incredible speed, but occasionally busts. Despite the risk, its low memory footprint and high performance on real hardware make it the industry standard for general-purpose sorting.</p>"},{"location":"algorithms_complexity/the_halting_problem/","title":"The Halting Problem","text":"<p>You've likely encountered the \"Infinite Loop\" bug. You write a <code>while</code> loop, mess up the exit condition, and your program freezes. You have to force-quit it.</p> <p>Wouldn't it be amazing if your code editor could warn you? Imagine a red squiggly line that pops up and says: \"Error: This loop will never finish.\"</p> <p>It seems like a reasonable feature request. We have spell-checkers, syntax-checkers, and type-checkers. Why not an Infinite-Loop-Checker?</p> <p>In 1936, Alan Turing proved that this specific feature is impossible to build. Not just \"hard\" or \"requires a supercomputer,\" but mathematically impossible. This discovery is known as The Halting Problem.</p>"},{"location":"algorithms_complexity/the_halting_problem/#the-setup","title":"The Setup","text":"<p>Let's imagine such a program exists. We'll call it <code>HaltChecker</code>.</p> <p><code>HaltChecker</code> is a perfect machine. It takes two inputs: 1.  A Program (source code). 2.  An Input for that program.</p> <p>It returns a simple Yes/No answer: -   YES: The program will eventually finish (halt) on that input. -   NO: The program will run forever (loop) on that input.</p> <p>It looks like this function:</p> <pre><code>def halt_checker(program, input_data):\n    if program_will_stop(program, input_data):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"algorithms_complexity/the_halting_problem/#the-paradox","title":"The Paradox","text":"<p>To prove this machine cannot exist, Turing used a \"Proof by Contradiction.\" He assumed it did exist, and then built a scenario that broke logic itself.</p> <p>Let's build a new program called <code>Paradox</code>. This program uses our imaginary <code>HaltChecker</code> as a subroutine.</p> <p><code>Paradox</code> takes only one input: a Program.</p> <p>Here is what <code>Paradox</code> does: 1.  It asks <code>HaltChecker</code>: \"If I feed this Program to itself as input, will it halt?\" 2.  If <code>HaltChecker</code> says YES (It halts): <code>Paradox</code> deliberately enters an infinite loop. 3.  If <code>HaltChecker</code> says NO (It loops): <code>Paradox</code> immediately stops (halts).</p> <p>In Python-ish pseudocode:</p> <pre><code>def paradox(program):\n    # Ask the Oracle\n    will_it_halt = halt_checker(program, program)\n\n    if will_it_halt:\n        # Do the opposite: Loop forever\n        while True:\n            pass\n    else:\n        # Do the opposite: Stop immediately\n        return\n</code></pre>"},{"location":"algorithms_complexity/the_halting_problem/#the-logical-explosion","title":"The Logical Explosion","text":"<p>Now for the final trick. We take our <code>Paradox</code> program and feed it to itself.</p> <p>We run: <code>paradox(paradox)</code></p> <p>What happens?</p> <p>Scenario A: <code>paradox(paradox)</code> halts. 1.  <code>HaltChecker</code> analyzes it and returns <code>True</code> (because we assumed it halts). 2.  Inside the code, <code>if will_it_halt:</code> becomes true. 3.  The code enters <code>while True: pass</code>. 4.  Result: <code>paradox(paradox)</code> LOOPS. 5.  Contradiction: We started by assuming it halts, but it looped.</p> <p>Scenario B: <code>paradox(paradox)</code> loops forever. 1.  <code>HaltChecker</code> analyzes it and returns <code>False</code> (because we assumed it loops). 2.  Inside the code, the <code>else:</code> block triggers. 3.  The code returns immediately. 4.  Result: <code>paradox(paradox)</code> HALTS. 5.  Contradiction: We started by assuming it loops, but it halted.</p> <p>Conclusion: In both cases, <code>HaltChecker</code> is wrong. It is impossible to write a program that can correctly predict the behavior of every other program. Therefore, <code>HaltChecker</code> cannot exist.</p>"},{"location":"algorithms_complexity/the_halting_problem/#why-this-matters","title":"Why This Matters","text":"<p>The Halting Problem was a devastating blow to the idea that mathematics and logic were all-powerful. It proved that Undecidable Problems exist.</p> <p>There are questions that computers cannot answer.</p>"},{"location":"algorithms_complexity/the_halting_problem/#1-compiler-limits","title":"1. Compiler Limits","text":"<p>This is why your compiler can't tell you if your code is \"correct\" or if it will finish. It can check syntax (grammar), but it can't check semantic termination (logic) for all cases.</p>"},{"location":"algorithms_complexity/the_halting_problem/#2-security-analysis","title":"2. Security Analysis","text":"<p>We cannot write a perfect antivirus that scans a file and says 100% definitively, \"This code does nothing malicious.\" Malicious behavior is just another form of program execution. We can check for known patterns (signatures), but we can't mathematically prove safety for all code.</p>"},{"location":"algorithms_complexity/the_halting_problem/#3-the-limits-of-knowledge","title":"3. The Limits of Knowledge","text":"<p>It draws a hard line in the sand. Computing is powerful, but it is not infinite. We are bounded by the laws of logic just as we are bounded by the laws of physics.</p>"},{"location":"algorithms_complexity/the_halting_problem/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning Decidable Problem A problem that can be solved by an algorithm in a finite amount of time (e.g., \"Is this number even?\"). Undecidable Problem A problem for which no algorithm can ever be constructed that always leads to a correct Yes/No answer. The Halting Problem The proof that determining whether any arbitrary program will stop is an undecidable problem. <p>The Halting Problem teaches us humility. We can build machines that simulate galaxies and defeat grandmasters at chess, but we cannot build a machine that simply knows if any loop will ever end.</p>"},{"location":"algorithms_complexity/turing_machines/","title":"Turing Machines","text":"<p>Imagine you have a roll of paper tape that stretches infinitely in both directions. You also have a simple mechanical box that sits on this tape. This box can do only three things: read the symbol written on the paper, write a new symbol, and move one step to the left or right.</p> <p>It sounds primitive, like a toy. Yet, this simple theoretical device\u2014the Turing Machine\u2014is powerful enough to simulate every computer that has ever existed or will ever exist. From the supercomputer running climate models to the smartphone in your pocket, they are all just optimized Turing Machines.</p>"},{"location":"algorithms_complexity/turing_machines/#the-model","title":"The Model","text":"<p>Alan Turing proposed this model in 1936, before electronic computers were even built. He wanted to define exactly what it means to \"compute\" something.</p> <p>A Turing Machine consists of four essential parts:</p> <ol> <li>The Tape: An infinite strip of paper divided into cells. Each cell contains a symbol (like <code>0</code>, <code>1</code>, or <code>A</code>) or is blank. This is the machine's memory.</li> <li>The Head: A device that can read the symbol at the current cell, write a new symbol, and move the tape Left (<code>L</code>) or Right (<code>R</code>).</li> <li>The State Register: A variable that holds the current \"state\" of the machine (e.g., <code>START</code>, <code>FIND_ZERO</code>, <code>HALT</code>).</li> <li>The Finite Table of Action (The Program): A set of rules that tells the machine what to do.</li> </ol>"},{"location":"algorithms_complexity/turing_machines/#the-rules-of-the-game","title":"The Rules of the Game","text":"<p>Every operation follows a strict pattern based on two inputs: 1.  The Current State of the machine. 2.  The Symbol currently being read by the head.</p> <p>Based on these two inputs, the machine produces three outputs: 1.  Write a symbol to the current cell. 2.  Move the head (Left or Right). 3.  Switch to a new state.</p> <p>It looks like a function: <code>(Current State, Current Symbol) \u2192 (Write Symbol, Move Direction, New State)</code></p>"},{"location":"algorithms_complexity/turing_machines/#visualizing-with-state-graphs","title":"Visualizing with State Graphs","text":"<p>While you can write out rules in a table, computer scientists often use State Graphs (or State Transition Diagrams) to visualize them.</p> <ul> <li>Nodes (Circles) represent States.</li> <li>Arrows represent Transitions.</li> <li>Labels on Arrows show the rule: <code>Read / Write, Move</code></li> </ul> <p>For example, a label <code>0 / 1, R</code> on an arrow from State A to State B means: \"If you are in State A and read a '0', write a '1', move Right, and go to State B.\"</p>"},{"location":"algorithms_complexity/turing_machines/#example-the-bit-flipper","title":"Example: The \"Bit Flipper\"","text":"<p>Let's design a simple Turing Machine that reads a string of binary digits (e.g., <code>1101</code>) and flips them (to <code>0010</code>).</p> <p>Setup: -   Tape: <code>... # 1 1 0 1 # ...</code> (where <code>#</code> is a blank space) -   Head: Starts at the first <code>1</code>. -   States: <code>FLIP</code> (working), <code>DONE</code> (finished).</p> <p>The Rules:</p> Current State Read Write Move New State Description FLIP <code>1</code> <code>0</code> Right FLIP See a 1? Make it 0, keep going. FLIP <code>0</code> <code>1</code> Right FLIP See a 0? Make it 1, keep going. FLIP <code>#</code> <code>#</code> Left DONE Hit a blank? We're finished. Back up one step. <p>The Execution:</p> <ol> <li>Start (State: FLIP): Head reads <code>1</code>. Rule says: Write <code>0</code>, Move <code>R</code>, Stay in <code>FLIP</code>.     Tape is now <code>0 1 0 1</code>.</li> <li>Step 2 (State: FLIP): Head reads <code>1</code>. Rule says: Write <code>0</code>, Move <code>R</code>, Stay in <code>FLIP</code>.     Tape is now <code>0 0 0 1</code>.</li> <li>Step 3 (State: FLIP): Head reads <code>0</code>. Rule says: Write <code>1</code>, Move <code>R</code>, Stay in <code>FLIP</code>.     Tape is now <code>0 0 1 1</code>.</li> <li>Step 4 (State: FLIP): Head reads <code>1</code>. Rule says: Write <code>0</code>, Move <code>R</code>, Stay in <code>FLIP</code>.     Tape is now <code>0 0 1 0</code>.</li> <li>Step 5 (State: FLIP): Head reads <code>#</code> (Blank). Rule says: Write <code>#</code>, Move <code>L</code>, Go to <code>DONE</code>.     Machine halts.</li> </ol>"},{"location":"algorithms_complexity/turing_machines/#why-this-matters-universality","title":"Why This Matters: Universality","text":"<p>The specific machine above is a \"special-purpose\" Turing Machine\u2014it only flips bits. But Turing discovered something profound: you can build a Universal Turing Machine (UTM).</p> <p>A UTM is a Turing Machine that can read the description of another Turing Machine (written on its tape) and simulate it.</p> <p>This is the separation of Hardware and Software. -   The UTM is the Hardware (the CPU). -   The description on the tape is the Software (the App).</p> <p>Before this, computing machines were built for single tasks (calculating tides, cracking codes). To change the task, you had to rebuild the machine. Turing proved that you only need one machine design; to change the task, you just change the tape.</p>"},{"location":"algorithms_complexity/turing_machines/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Parity Checker <p>Design a Turing Machine (in descriptions) that reads a binary string and determines if it has an odd number of 1s.</p> <ul> <li>Start at the beginning of the string.</li> <li>If the number of 1s is odd, write <code>1</code> at the end.</li> <li>If even, write <code>0</code>.</li> </ul> <p>Hint: You need two states to track the parity as you scan.</p> Solution <p>States: 1.  <code>EVEN</code> (Start state, assumes we've seen 0 or even 1s so far) 2.  <code>ODD</code> (We've seen an odd number of 1s so far) 3.  <code>HALT</code></p> <p>Rules: -   State EVEN:     -   Read <code>0</code>: Stay <code>EVEN</code>, Move R (0 doesn't change parity).     -   Read <code>1</code>: Switch to <code>ODD</code>, Move R.     -   Read <code>#</code>: Write <code>0</code> (count was even), Move L, -&gt; <code>HALT</code>. -   State ODD:     -   Read <code>0</code>: Stay <code>ODD</code>, Move R.     -   Read <code>1</code>: Switch to <code>EVEN</code>, Move R.     -   Read <code>#</code>: Write <code>1</code> (count was odd), Move L, -&gt; <code>HALT</code>.</p> Practice Problem 2: The Infinite Loop <p>Can you design a rule that causes a Turing Machine to run forever?</p> Solution <p>Yes, it's very simple. Just create a state that moves without changing anything fundamental or reaching a halt state.</p> <p>Rule: -   State <code>RUN</code>: Read <code>Any</code>, Write <code>Same</code>, Move <code>Right</code>, Next State <code>RUN</code>.</p> <p>The head will just travel to the right forever (assuming an infinite tape). This concept is crucial for the Halting Problem.</p>"},{"location":"algorithms_complexity/turing_machines/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning Tape Infinite memory storage. Head The mechanism that reads and modifies memory. State The current \"context\" or memory of what the machine is doing. Transition The rule: <code>(State, Symbol) -&gt; (Action, New State)</code>. Universal Turing Machine A machine that can simulate any other machine (Software). <p>The Turing Machine is the atom of computer science. It strips away all the complexity of RAM, caches, and transistors to reveal the pure mathematical heart of computation: Reading, Writing, and Changing State.</p>"},{"location":"building_blocks/backus_naur_form/","title":"Backus-Naur Form (BNF)","text":""},{"location":"building_blocks/backus_naur_form/#description-backus-naur-form-bnf-explained-the-standard-notation-for-defining-programming-language-syntax","title":"description: Backus-Naur Form (BNF) explained: The standard notation for defining programming language syntax.","text":""},{"location":"building_blocks/backus_naur_form/#backus-naur-form-bnf","title":"Backus-Naur Form (BNF)","text":"<p>If Recursive Transition Networks are the visual way to describe a grammar, then Backus-Naur Form (BNF) is the textual equivalent. Same idea, different notation\u2014and one that's far easier to type into a computer.</p> <p>BNF has been the go-to notation for defining programming language syntax since the late 1950s. When you see a language specification or parser documentation, chances are you're looking at some flavor of BNF.</p>"},{"location":"building_blocks/backus_naur_form/#a-brief-history","title":"A Brief History","text":"<p>BNF was developed by John Backus and Peter Naur while working on the ALGOL 60 programming language. Backus created the initial notation; Naur refined and popularized it. The name is sometimes expanded as \"Backus Normal Form,\" but \"Backus-Naur Form\" is more historically accurate (and gives Naur his due credit).</p> <p>Fun fact: This was one of the first times anyone had formally specified a programming language's syntax. Before BNF, language definitions were often ambiguous prose that left implementers guessing. \ud83e\udd14 Good times.</p>"},{"location":"building_blocks/backus_naur_form/#the-bigger-picture-formal-languages","title":"The Bigger Picture: Formal Languages","text":"<p>BNF is more than just a convenient notation; it's a gateway to the field of formal language theory. Specifically, BNF is used to define context-free grammars (CFGs).</p> <p>In the 1950s, linguist Noam Chomsky created a hierarchy to classify the complexity of formal languages. BNF-style grammars sit at Type 2 of the Chomsky hierarchy:</p> Type Grammar Recognizable By Example Type-0 Unrestricted Turing Machine Any computable language Type-1 Context-Sensitive Linear-bounded Automaton <code>a^n b^n c^n</code> Type-2 Context-Free Pushdown Automaton Most programming languages Type-3 Regular Finite State Automaton Regular Expressions <p>What does \"context-free\" mean? It means the rules are simple. A non-terminal like <code>&lt;expression&gt;</code> can be replaced by its definition regardless of what surrounds it. There's no rule that says, \"you can only expand <code>&lt;expression&gt;</code> this way if it's inside a <code>for</code> loop.\" This simplicity is what makes them powerful and relatively easy to parse.</p> <p>Most programming language syntax is designed to be context-free, which is why BNF and its variants are the perfect tools for the job.</p>"},{"location":"building_blocks/backus_naur_form/#the-basic-syntax","title":"The Basic Syntax","text":"<p>BNF uses a simple set of symbols:</p> Symbol Meaning <code>::=</code> \"is defined as\" <code>&lt;name&gt;</code> A non-terminal (a rule that needs further expansion) <code>|</code> \"or\" (alternative options) Plain text Terminals (literal characters or tokens) <p>Let's see it in action.</p>"},{"location":"building_blocks/backus_naur_form/#example-1-greetings-rtn-vs-bnf","title":"Example 1: Greetings (RTN vs BNF)","text":"<p>Remember our greeting RTN? Here's the same grammar in BNF:</p> Greeting Grammar in BNF<pre><code>&lt;greeting&gt; ::= &lt;salutation&gt; | &lt;salutation&gt; &lt;modifier&gt;\n&lt;salutation&gt; ::= Hello | Hi\n&lt;modifier&gt; ::= there | friend | there friend\n</code></pre> <p>Reading this:</p> <ul> <li>A <code>&lt;greeting&gt;</code> is either just a <code>&lt;salutation&gt;</code>, OR a <code>&lt;salutation&gt;</code> followed by a <code>&lt;modifier&gt;</code></li> <li>A <code>&lt;salutation&gt;</code> is either \"Hello\" or \"Hi\"</li> <li>A <code>&lt;modifier&gt;</code> is \"there\", \"friend\", or \"there friend\"</li> </ul> <p>This generates all the same strings as our RTN: \"Hello\", \"Hi\", \"Hello there\", \"Hi friend\", \"Hello there friend\", etc.</p> Comparing Notations RTN BNF Nodes and edges Rules and alternatives Visual, good for understanding Textual, good for implementation Can be unwieldy for complex grammars Scales well, easy to edit Traces paths through a graph Expands rules recursively"},{"location":"building_blocks/backus_naur_form/#example-2-unsigned-integers","title":"Example 2: Unsigned Integers","text":"<p>An unsigned integer is one or more digits (see the RTN version). In BNF:</p> Unsigned Integer Grammar in BNF<pre><code>&lt;unsigned-integer&gt; ::= &lt;digit&gt; | &lt;digit&gt; &lt;unsigned-integer&gt;\n&lt;digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n</code></pre> <p>What's happening here:</p> <ul> <li>An <code>&lt;unsigned-integer&gt;</code> is either a single <code>&lt;digit&gt;</code>, OR a <code>&lt;digit&gt;</code> followed by another <code>&lt;unsigned-integer&gt;</code></li> <li>That self-reference is the recursion\u2014it lets us match \"7\", \"42\", \"1337\", or any sequence of digits</li> </ul> <p>This is the textual equivalent of the loop we drew in the RTN diagram.</p>"},{"location":"building_blocks/backus_naur_form/#example-3-arithmetic-expressions","title":"Example 3: Arithmetic Expressions","text":"<p>Here's where BNF really shines. Remember those three interconnected RTNs for arithmetic? Three separate diagrams, jumping between them to understand the relationships. In BNF, the entire grammar fits on your screen at once:</p> Arithmetic Expression Grammar in BNF<pre><code>&lt;expression&gt; ::= &lt;term&gt; | &lt;expression&gt; + &lt;term&gt; | &lt;expression&gt; - &lt;term&gt;\n&lt;term&gt; ::= &lt;factor&gt; | &lt;term&gt; * &lt;factor&gt; | &lt;term&gt; / &lt;factor&gt;\n&lt;factor&gt; ::= &lt;number&gt; | ( &lt;expression&gt; )\n&lt;number&gt; ::= &lt;digit&gt; | &lt;digit&gt; &lt;number&gt;\n&lt;digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n</code></pre> <p>Five lines of text. Everything visible simultaneously. The recursive relationships are explicit: <code>&lt;expression&gt;</code> calls <code>&lt;term&gt;</code>, <code>&lt;term&gt;</code> calls <code>&lt;factor&gt;</code>, and <code>&lt;factor&gt;</code> can call back to <code>&lt;expression&gt;</code>. This is the inflection point\u2014for simple grammars, RTNs offer intuitive visual clarity; for complex grammars, BNF becomes far more practical and readable.</p> <p>Let's trace how a parser using this grammar would evaluate <code>3 + 4 * 2</code>. This is a \"bottom-up\" view of the parse tree being built.</p> <ol> <li>Start with <code>&lt;expression&gt;</code>: The parser wants to find an expression.</li> <li>Call <code>parse_expression()</code>:<ul> <li>It must first find a <code>&lt;term&gt;</code>. It calls <code>parse_term()</code>.</li> <li><code>parse_term()</code> must find a <code>&lt;factor&gt;</code>. It calls <code>parse_factor()</code>.</li> <li><code>parse_factor()</code> finds the <code>&lt;number&gt;</code> <code>3</code>. This is our first result.</li> <li><code>parse_term()</code> gets <code>3</code> back. It looks ahead and sees a <code>+</code>. Since <code>+</code> is not <code>*</code> or <code>/</code>, the <code>parse_term()</code> function returns <code>3</code>.</li> <li><code>parse_expression()</code> gets <code>3</code> back. It sees the <code>+</code> token, consumes it, and now needs to parse another <code>&lt;term&gt;</code>. It calls <code>parse_term()</code> again.</li> </ul> </li> <li>Second Call to <code>parse_term()</code>:<ul> <li>It must find a <code>&lt;factor&gt;</code>. It calls <code>parse_factor()</code>.</li> <li><code>parse_factor()</code> finds the <code>&lt;number&gt;</code> <code>4</code>.</li> <li><code>parse_term()</code> gets <code>4</code> back. It looks ahead and sees a <code>*</code>.</li> <li>Aha! The <code>*</code> is part of the <code>&lt;term&gt;</code> rule. The parser consumes the <code>*</code> and calls <code>parse_factor()</code> again to get the operand on the right.</li> <li><code>parse_factor()</code> finds the <code>&lt;number&gt;</code> <code>2</code>.</li> <li>The <code>parse_term()</code> function now has everything it needs to compute <code>4 * 2</code>, resulting in <code>8</code>.</li> <li><code>parse_term()</code> returns <code>8</code>.</li> </ul> </li> <li>Back in <code>parse_expression()</code>:<ul> <li>It previously had the left-hand side (<code>3</code>) and the operator (<code>+</code>). It now receives the right-hand side (<code>8</code>).</li> <li>It can now compute <code>3 + 8</code>, resulting in <code>11</code>.</li> </ul> </li> </ol> <p>The parse is complete. Notice how the grammar forced the parser to evaluate <code>4 * 2</code> before the addition. That's operator precedence in action.</p> Operator Precedence is Built In <p>Notice how <code>*</code> and <code>/</code> are in the <code>&lt;term&gt;</code> rule, while <code>+</code> and <code>-</code> are in <code>&lt;expression&gt;</code>? Since an <code>&lt;expression&gt;</code> must first call down to a <code>&lt;term&gt;</code>, the grammar forces the parser to go \"deeper\" to find multiplications and divisions. As the parser returns from these deeper recursive calls, it evaluates the higher-precedence operators first. The grammar's structure is the operator precedence.</p>"},{"location":"building_blocks/backus_naur_form/#extended-bnf-ebnf","title":"Extended BNF (EBNF)","text":"<p>Classic BNF can get verbose. Extended BNF adds some conveniences borrowed from regular expressions:</p> EBNF Syntax Meaning Example <code>{ x }</code> Zero or more of x <code>{ digit }</code> = any number of digits <code>[ x ]</code> Optional (zero or one) <code>[ - ]</code> = optional minus sign <code>( x | y )</code> Grouping <code>( + | - )</code> = plus or minus"},{"location":"building_blocks/backus_naur_form/#unsigned-integer-in-ebnf","title":"Unsigned Integer in EBNF","text":"Unsigned Integer in EBNF<pre><code>unsigned-integer = digit { digit }\ndigit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n</code></pre> <p>Much cleaner! The <code>digit { digit }</code> is a common and important idiom: it means \"one digit, followed by zero or more additional digits.\" This ensures an integer has at least one digit.</p>"},{"location":"building_blocks/backus_naur_form/#signed-integer-in-ebnf","title":"Signed Integer in EBNF","text":"Signed Integer in EBNF<pre><code>signed-integer = [ \"-\" ] digit { digit }\n</code></pre> <p>The <code>[ \"-\" ]</code> means the minus sign is optional. Simple.</p>"},{"location":"building_blocks/backus_naur_form/#arithmetic-expressions-in-ebnf","title":"Arithmetic Expressions in EBNF","text":"Arithmetic Expressions in EBNF<pre><code>expression = term { ( \"+\" | \"-\" ) term }\nterm = factor { ( \"*\" | \"/\" ) factor }\nfactor = number | \"(\" expression \")\"\nnumber = digit { digit }\ndigit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"\n</code></pre> <p>This is arguably more readable than the recursive BNF version\u2014the repetition is explicit rather than implied through self-reference.</p>"},{"location":"building_blocks/backus_naur_form/#real-world-bnf-a-taste-of-python","title":"Real-World BNF: A Taste of Python","text":"<p>Here's a simplified snippet from Python's actual grammar (which uses a variant of EBNF):</p> Python Control Flow Grammar (Simplified)<pre><code>if_stmt = \"if\" expression \":\" suite\n          { \"elif\" expression \":\" suite }\n          [ \"else\" \":\" suite ]\n\nwhile_stmt = \"while\" expression \":\" suite [ \"else\" \":\" suite ]\n\nfor_stmt = \"for\" target_list \"in\" expression_list \":\" suite\n           [ \"else\" \":\" suite ]\n</code></pre> <p>(Where <code>suite</code> is an indented block of code, <code>expression</code> is our familiar rule, and <code>target_list</code> and <code>expression_list</code> are comma-separated lists of variables and values, respectively.)</p> <p>You can read this almost like English:</p> <ul> <li>An <code>if_stmt</code> is the keyword \"if\", followed by an expression, a colon, a suite (block of code), optionally followed by any number of \"elif\" clauses, optionally followed by an \"else\" clause</li> <li>Python's <code>else</code> on loops? Right there in the grammar!</li> </ul> Finding Language Grammars <p>Most programming languages publish their formal grammar:</p> <ul> <li>Python Grammar</li> <li>JSON Grammar (beautifully simple \ud83d\udc96)</li> <li>SQL Grammar (terrifyingly complex \ud83d\ude31)</li> </ul> <p>Reading these is a great way to deeply understand a language's syntax.</p>"},{"location":"building_blocks/backus_naur_form/#from-bnf-to-code","title":"From BNF to Code","text":"<p>One of BNF's superpowers is that it translates almost directly into parser code. Each rule becomes a function:</p> Recursive Descent Parser from BNF<pre><code>def parse_expression():  # (1)!\n    \"\"\"&lt;expression&gt; ::= &lt;term&gt; { ('+' | '-') &lt;term&gt; }\"\"\"\n    result = parse_term()  # (2)!\n    while current_token() in ['+', '-']:  # (3)!\n        operator = consume_token()\n        right = parse_term()\n        result = BinaryOp(result, operator, right)  # (4)!\n    return result\n\ndef parse_term():  # (5)!\n    \"\"\"&lt;term&gt; ::= &lt;factor&gt; { ('*' | '/') &lt;factor&gt; }\"\"\"\n    result = parse_factor()\n    while current_token() in ['*', '/']:\n        operator = consume_token()\n        right = parse_factor()\n        result = BinaryOp(result, operator, right)\n    return result\n\ndef parse_factor():  # (6)!\n    \"\"\"&lt;factor&gt; ::= &lt;number&gt; | '(' &lt;expression&gt; ')'\"\"\"\n    if current_token() == '(':\n        consume_token()  # eat '('\n        result = parse_expression()  # (7)!\n        consume_token()  # eat ')'\n        return result\n    else:\n        return parse_number()\n</code></pre> <ol> <li>Each BNF rule becomes a function - this one handles expressions (lowest precedence)</li> <li>Start by parsing the higher-precedence term</li> <li>Handle zero or more addition/subtraction operations</li> <li>Build AST node combining left operand, operator, and right operand</li> <li>Handles medium precedence operations (multiplication and division)</li> <li>Handles highest precedence: numbers and parenthesized expressions</li> <li>Recursively parse expressions inside parentheses - shows how BNF recursion becomes function recursion</li> </ol> <p>This technique is called recursive descent parsing, and it's one of the most intuitive ways to build a parser. The grammar is the code structure. For a deeper dive into parsing strategies and implementation, see How Parsers Work.</p>"},{"location":"building_blocks/backus_naur_form/#bnf-variants-youll-encounter","title":"BNF Variants You'll Encounter","text":"<p>Different tools and specifications use slightly different BNF flavors:</p> Variant Used By Notable Differences BNF Academic papers, older specs <code>::=</code>, <code>&lt;angle brackets&gt;</code> EBNF ISO standards, formal specs Adds <code>{ }</code>, <code>[ ]</code>, <code>( )</code> ABNF Internet RFCs (HTTP, SMTP, etc.) Uses <code>=</code>, prose descriptions PEG Modern parser generators Ordered choice, no ambiguity ANTLR ANTLR parser generator Rich syntax, semantic actions <p>Don't worry too much about the differences\u2014once you understand one, the others are easy to pick up.</p>"},{"location":"building_blocks/backus_naur_form/#key-differences-rtn-vs-bnf","title":"Key Differences: RTN vs BNF","text":"Aspect RTN BNF Format Visual (graphs) Textual (rules) Best for Learning, understanding Implementation, documentation Recursion Call other networks Rules reference other rules Tooling Draw by hand or diagramming tools Text editors, parser generators Ambiguity Harder to spot Easier to analyze <p>Both describe the same thing\u2014valid strings in a language. Choose based on your audience and purpose.</p>"},{"location":"building_blocks/backus_naur_form/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Write BNF for Email Addresses <p>Define a grammar for simple email addresses like <code>user@domain.com</code>.</p> <p>Hint: You'll need rules for the local part (before @), domain, and top-level domain.</p> Practice Problem 2: Convert This RTN to BNF <p>Remember the natural language Sentence RTN? Convert the Noun Phrase portion to BNF:</p> <ul> <li>A noun phrase has an optional article, zero or more adjectives, and a noun</li> </ul> <pre><code>&lt;noun-phrase&gt; ::= ???\n</code></pre> Practice Problem 3: Add Exponentiation <p>Extend the arithmetic expression grammar to support <code>^</code> for exponentiation. Remember: exponentiation has higher precedence than multiplication and is right-associative (\\(2^{3^4} = 2^{(3^4)}\\), not \\((2^3)^4\\)).</p> <p>Where does the new rule go?</p>"},{"location":"building_blocks/backus_naur_form/#key-takeaways","title":"Key Takeaways","text":"Concept What It Means Terminal Literal text that appears in the language Non-terminal A rule name in angle brackets <code>&lt;like-this&gt;</code> Production A rule defining what a non-terminal expands to <code>::=</code> \"is defined as\" <code>|</code> \"or\" (alternatives) EBNF Extended BNF with <code>{ }</code>, <code>[ ]</code> for repetition and optionality Recursive descent Parsing technique where grammar rules become functions"},{"location":"building_blocks/backus_naur_form/#further-reading","title":"Further Reading","text":"<p>Related Articles:</p> <ul> <li>Recursive Transition Networks \u2014 The visual equivalent</li> <li>Scheme &amp; Parse Trees \u2014 A language with a trivial BNF grammar</li> </ul> <p>Books and Tutorials:</p> <ul> <li>David Evans, Introduction to Computing \u2014 Chapter 2 for more on language and grammars</li> <li>Crafting Interpreters by Bob Nystrom \u2014 Excellent free online book with hands-on parsing chapters</li> </ul> <p>Tools and Documentation:</p> <ul> <li>ANTLR \u2014 Powerful parser generator with excellent documentation</li> <li>Python Grammar \u2014 Python's complete formal grammar</li> <li>JSON Grammar \u2014 Beautifully simple example</li> </ul> <p>Historical and Reference:</p> <ul> <li>ALGOL 60 Report \u2014 The original 1960 report where BNF was formalized</li> </ul> <p>BNF takes the visual intuition of RTNs and packages it into a format that's easy to write, share, and\u2014most importantly\u2014turn into working parsers. It's been describing programming languages for over 60 years, and it's not going anywhere. Once you can read BNF, you can read the source code of language design itself. \ud83c\udfaf</p>"},{"location":"building_blocks/backus_naur_form/#video-summary","title":"Video Summary","text":""},{"location":"building_blocks/binary_trees_and_representation/","title":"Binary Trees & Representation","text":""},{"location":"building_blocks/binary_trees_and_representation/#description-binary-representation-and-trees-the-foundation-of-how-computers-store-and-organize-information","title":"description: Binary representation and trees: The foundation of how computers store and organize information.","text":""},{"location":"building_blocks/binary_trees_and_representation/#binary-trees-and-binary-representation","title":"Binary Trees and Binary Representation","text":"<p>When you fill out a form and select your country from a dropdown menu, how does the system find \"United States\" among 195 countries in milliseconds? When a compiler checks your code's syntax tree for errors, what structure lets it traverse thousands of nodes efficiently? When your computer represents the number 42, why does it use <code>101010</code> instead of <code>42</code>?</p> <p>The answer to all three lies in understanding binary\u2014both as a number system and as a tree structure. Binary representation is the foundation of how computers store everything, while binary trees are the foundation of how computers organize and search through that everything.</p>"},{"location":"building_blocks/binary_trees_and_representation/#the-binary-number-system","title":"The Binary Number System","text":""},{"location":"building_blocks/binary_trees_and_representation/#what-is-binary","title":"What is Binary?","text":"<p>Binary is a base-2 number system, using only two digits: <code>0</code> and <code>1</code>. Each digit is called a bit (binary digit).</p> <p>Decimal (base-10) vs. Binary (base-2):</p> Decimal Binary Calculation 0 0 0 1 1 1 2 10 \\(1 \\times 2^1 + 0 \\times 2^0\\) 3 11 \\(1 \\times 2^1 + 1 \\times 2^0\\) 4 100 \\(1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0\\) 5 101 \\(1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\\) 7 111 \\(1 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0\\) 42 101010 \\(1 \\times 2^5 + 0 \\times 2^4 + 1 \\times 2^3 + 0 \\times 2^2 + 1 \\times 2^1 + 0 \\times 2^0\\) <p>Each position represents a power of 2, just as decimal positions represent powers of 10.</p>"},{"location":"building_blocks/binary_trees_and_representation/#why-binary","title":"Why Binary?","text":"<p>Computers use binary because digital circuits have two stable states:</p> <ul> <li>Voltage high (typically ~5V or ~3.3V) \u2192 represents <code>1</code></li> <li>Voltage low (typically ~0V) \u2192 represents <code>0</code></li> </ul> <p>This physical constraint makes binary natural for electronic computers. A transistor is either conducting or not. A magnetic region on a hard drive is magnetized north or south. A laser reading a CD detects a pit or a land.</p> <p>Two states are reliable. Trying to distinguish between ten voltage levels (for decimal) would require extreme precision and be error-prone.</p> Historical Context: Binary's Journey from Ancient Mathematics to Modern Computing <p>Ancient Origins of Binary Arithmetic</p> <p>Binary arithmetic has deep roots. Indian mathematician Pingala described binary-like patterns in prosody around 300 BCE. Later, Gottfried Wilhelm Leibniz formalized binary arithmetic in 1679 and recognized its connection to Boolean logic\u2014a connection that would prove essential for computing centuries later.</p> <p>The Decimal Computer Experiments (1940s-1950s)</p> <p>Binary wasn't always the obvious choice for electronic computers. In the 1940s and early 1950s, several pioneering computers experimented with decimal (base-10) representation, since humans naturally think in decimal.</p> <p>Notable decimal computers:</p> <ul> <li>ENIAC (1945): Used decimal representation with 10-state vacuum tube rings to store each digit. Each decimal digit required 10 vacuum tubes in a ring counter configuration\u2014far more complex than binary's simple on/off states.</li> <li>IBM 650 (1953): A commercial decimal computer that stored data using bi-quinary code (a hybrid approach using 7 bits to represent each decimal digit).</li> <li>UNIVAC I (1951): Used excess-3 binary-coded decimal (BCD), where each decimal digit was encoded in 4 bits.</li> </ul> <p>Why binary won:</p> <ol> <li>Simplicity: Binary logic gates and circuits are far simpler to design and build.</li> <li>Reliability: Two voltage levels are easier to distinguish than ten, especially as components age or temperatures fluctuate.</li> <li>Efficiency: Binary arithmetic circuits (adders, multipliers) are more straightforward than decimal equivalents.</li> <li>Error correction: Binary systems made it easier to detect and correct errors using parity bits and other techniques.</li> </ol> <p>By the late 1950s, the industry had largely standardized on binary.</p> <p>Binary Trees in Computing (1960s-1970s)</p> <p>Binary trees became fundamental to computer science in the 1960s:</p> <ul> <li>1962: Donald Knuth's work on tree algorithms (later published in The Art of Computer Programming)</li> <li>1962: Adelson-Velsky and Landis invented AVL trees (self-balancing binary search trees)</li> <li>1972: Rudolf Bayer invented B-trees (generalization for databases)</li> </ul> <p>The lesson? Sometimes the system that's easiest for machines to process trumps the system that's easiest for humans to read\u2014and we build translation layers (like decimal I/O) to bridge the gap. Today, binary representation and binary trees underpin databases, compilers, file systems, and machine learning.</p>"},{"location":"building_blocks/binary_trees_and_representation/#the-power-of-binary","title":"The Power of Binary","text":"<p>Binary is remarkably expressive:</p> <ul> <li>8 bits (1 byte) can represent \\(2^8 = 256\\) different values (0-255)</li> <li>16 bits can represent \\(2^{16} = 65{,}536\\) values</li> <li>32 bits can represent \\(2^{32} = 4{,}294{,}967{,}296\\) values (4.3 billion)</li> <li>64 bits can represent \\(2^{64} = 18{,}446{,}744{,}073{,}709{,}551{,}616\\) values (18.4 quintillion)</li> </ul> <p>With binary, computers can represent:</p> <ul> <li>Integers: Positive and negative whole numbers</li> <li>Floating-point numbers: Decimals and scientific notation</li> <li>Text: ASCII, Unicode (each character is a number)</li> <li>Images: Pixel colors (RGB values)</li> <li>Audio: Sample amplitudes</li> <li>Video: Sequences of images</li> <li>Instructions: CPU opcodes</li> <li>Memory addresses: Locations in RAM</li> </ul> <p>Everything a computer processes\u2014from your email to a movie to the operating system itself\u2014is ultimately bits.</p>"},{"location":"building_blocks/binary_trees_and_representation/#why-abstraction-is-still-necessary","title":"Why Abstraction is Still Necessary","text":"<p>Given that binary can represent anything\u2014numbers, text, images, sound\u2014why do we need abstraction?</p>  Cognitive Overload Semantic Meaning Hardware Complexity Efficiency <p>Working directly with bits is impractical for humans.</p> <p>Representing the number 1,000,000:</p> <ul> <li>Binary: <code>11110100001001000000</code> (20 bits)</li> <li>Decimal: <code>1000000</code> (7 digits)</li> <li>Hexadecimal: <code>F4240</code> (5 characters)</li> </ul> <p>Hexadecimal is an abstraction over binary (each hex digit = 4 bits), making it easier to read and write.</p> <p>Bits have no inherent meaning\u2014context determines interpretation.</p> <p>The bit sequence <code>01000001</code> could mean:</p> <ul> <li>The number 65 (unsigned integer)</li> <li>The letter 'A' (ASCII encoding)</li> <li>The number \\(1.52 \\times 10^{-43}\\) (part of a floating-point number)</li> <li>An instruction opcode (CPU operation)</li> </ul> <p>Abstraction provides meaning: High-level languages let you write <code>'A'</code> instead of <code>01000001</code>, making intent clear.</p> <p>Modern CPUs have billions of transistors. Writing programs at the bit level would be:</p> <ul> <li>Extremely tedious (millions of lines for simple tasks)</li> <li>Error-prone (one wrong bit = program crash)</li> <li>Unportable (different CPUs use different instruction sets)</li> </ul> <p>Abstraction layers solve this:</p> Layer Example Abstracts Over Hardware Transistors, logic gates Physics (voltage, current) Machine Code <code>10110000 01100001</code> Gate-level operations Assembly <code>MOV AL, 97</code> Binary opcodes High-Level <code>char letter = 'A';</code> Assembly instructions Libraries <code>print(\"Hello\")</code> Low-level I/O details <p>Each layer hides complexity, letting programmers focus on solving problems rather than managing bits.</p> <p>Sometimes binary isn't the most efficient representation for specific tasks.</p> <p>Example: DNA Sequences</p> <p>DNA has four bases (A, C, G, T). You could encode each base in binary:</p> <ul> <li><code>A = 00</code>, <code>C = 01</code>, <code>G = 10</code>, <code>T = 11</code> (2 bits each)</li> </ul> <p>But specialized data structures (suffix trees, hash tables) provide faster search and comparison, even though they ultimately use binary underneath.</p> <p>Abstraction enables optimization: You can change the underlying representation without changing the program logic.</p> Abstraction in Data Structures <p>The concept of hiding implementation details behind clean interfaces is formalized in Abstract Data Types (ADTs).</p> <p>An ADT defines what a data structure does (its operations and behavior) without specifying how it's implemented. This separation allows you to swap implementations\u2014switching from an array-based stack to a linked-list-based stack\u2014without changing any code that uses it.</p> <p>Binary trees themselves can be implemented many ways (arrays, linked nodes, etc.), but users of the tree only care about operations like insert, search, and traverse.</p>"},{"location":"building_blocks/binary_trees_and_representation/#binary-trees","title":"Binary Trees","text":""},{"location":"building_blocks/binary_trees_and_representation/#what-is-a-binary-tree","title":"What is a Binary Tree?","text":"<p>A binary tree is a hierarchical data structure where each node has at most two children, conventionally called left and right.</p> <p>Structure:</p> <pre><code>graph TD\n    A[Root Node] --&gt; B[Left Child]\n    A --&gt; C[Right Child]\n    B --&gt; D[Left Grandchild]\n    B --&gt; E[Right Grandchild]\n    C --&gt; F[Left Grandchild]\n    C --&gt; G[Right Grandchild]\n\n    style A fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style B fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style C fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style D fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style E fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style F fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style G fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>Terminology:</p> Term Definition Root The topmost node (no parent) Leaf A node with no children Parent A node with children Child A node with a parent Sibling Nodes sharing the same parent Depth Number of edges from root to a node Height Maximum depth in the tree Level All nodes at the same depth"},{"location":"building_blocks/binary_trees_and_representation/#formal-definition","title":"Formal Definition","text":"<p>A binary tree is either:</p> <ol> <li>Empty (no nodes), or</li> <li>A root node with two subtrees (left and right), each of which is itself a binary tree</li> </ol> <p>This recursive definition mirrors how binary trees are used\u2014operations on trees often recursively operate on subtrees.</p>"},{"location":"building_blocks/binary_trees_and_representation/#the-exponential-power-of-depth","title":"The Exponential Power of Depth","text":"<p>Here's where binary trees become fascinating: depth determines capacity exponentially.</p>"},{"location":"building_blocks/binary_trees_and_representation/#levels-and-capacity","title":"Levels and Capacity","text":"<p>At each level of a binary tree, the maximum number of nodes doubles:</p> Level Max Nodes Calculation Total Nodes (cumulative) 0 (root) 1 \\(2^0\\) 1 1 2 \\(2^1\\) 3 2 4 \\(2^2\\) 7 3 8 \\(2^3\\) 15 4 16 \\(2^4\\) 31 5 32 \\(2^5\\) 63 \\(n\\) \\(2^n\\) \\(2^n\\) \\(2^{n+1} - 1\\) Key Insight: Exponential Growth <p>A binary tree of depth \\(n\\) has \\(2^n\\) nodes at the bottom level.</p> <p>This exponential relationship is why binary trees are so powerful for representing choices, decisions, and hierarchical data. Each additional level doubles the capacity\u2014making even shallow trees surprisingly expressive.</p>"},{"location":"building_blocks/binary_trees_and_representation/#example-depth-3-binary-tree","title":"Example: Depth 3 Binary Tree","text":"<pre><code>graph TD\n    A[\"Level 0: 1 node\"] --&gt; B[\"Level 1: 2 nodes\"]\n    A --&gt; C[\"Level 1: 2 nodes\"]\n    B --&gt; D[\"Level 2: 4 nodes\"]\n    B --&gt; E[\"Level 2: 4 nodes\"]\n    C --&gt; F[\"Level 2: 4 nodes\"]\n    C --&gt; G[\"Level 2: 4 nodes\"]\n    D --&gt; H[\"Level 3: 8 nodes\"]\n    D --&gt; I[\"Level 3: 8 nodes\"]\n    E --&gt; J[\"Level 3: 8 nodes\"]\n    E --&gt; K[\"Level 3: 8 nodes\"]\n    F --&gt; L[\"Level 3: 8 nodes\"]\n    F --&gt; M[\"Level 3: 8 nodes\"]\n    G --&gt; N[\"Level 3: 8 nodes\"]\n    G --&gt; O[\"Level 3: 8 nodes\"]\n\n    style A fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style B fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style C fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style D fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style E fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style F fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style G fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>Total capacity: \\(2^3 = 8\\) distinct values can be represented at the leaves.</p> <p>If each path from root to leaf represents a unique answer to yes/no questions:</p> <ul> <li>At depth 1: 2 possible outcomes</li> <li>At depth 2: 4 possible outcomes</li> <li>At depth 3: 8 possible outcomes</li> <li>At depth 10: 1,024 possible outcomes</li> <li>At depth 20: 1,048,576 possible outcomes (over a million!)</li> </ul> <p>This exponential growth makes binary trees extraordinarily efficient for representing choices, decisions, and searches.</p>"},{"location":"building_blocks/binary_trees_and_representation/#binary-trees-for-distinction","title":"Binary Trees for Distinction","text":"<p>A binary tree can distinguish among different values by assigning each leaf a unique path from the root.</p>"},{"location":"building_blocks/binary_trees_and_representation/#example-20-questions-game","title":"Example: 20 Questions Game","text":"<p>The classic \"20 Questions\" game leverages this principle. With 20 yes/no questions, you can distinguish among \\(2^{20} = 1{,}048{,}576\\) possible answers.</p> <p>Simplified Example (3 questions, 8 animals):</p> <pre><code>graph TD\n    Start[\"Is it a mammal?\"]\n    Start --&gt;|Yes| Mammal[\"Does it have 4 legs?\"]\n    Start --&gt;|No| NotMammal[\"Can it fly?\"]\n    Mammal --&gt;|Yes| FourLegs[\"Does it bark?\"]\n    Mammal --&gt;|No| NoFourLegs[\"Whale\"]\n    FourLegs --&gt;|Yes| Dog[\"Dog\"]\n    FourLegs --&gt;|No| Cat[\"Cat\"]\n    NotMammal --&gt;|Yes| Fly[\"Sparrow\"]\n    NotMammal --&gt;|No| NoFly[\"Does it live in water?\"]\n    NoFly --&gt;|Yes| Fish[\"Fish\"]\n    NoFly --&gt;|No| Snake[\"Snake\"]\n    NoFourLegs -.- X1[\" \"]\n    NoFourLegs -.- X2[\" \"]\n    style X1 fill:none,stroke:none\n    style X2 fill:none,stroke:none\n\n    style Start fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Mammal fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style NotMammal fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style FourLegs fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style NoFourLegs fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Fly fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style NoFly fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Dog fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Cat fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Whale fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Sparrow fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Fish fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Snake fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>Each path from root to leaf uniquely identifies one animal. With depth 3, we can distinguish up to 8 animals (though this example uses 6).</p>"},{"location":"building_blocks/binary_trees_and_representation/#binary-search-trees","title":"Binary Search Trees","text":"<p>A binary search tree (BST) is a binary tree where:</p> <ul> <li>Left subtree contains only values less than the node's value</li> <li>Right subtree contains only values greater than the node's value</li> </ul> <p>This structure enables logarithmic search time for balanced trees. Each comparison eliminates half of the remaining items, so the number of steps grows as \\(\\log_2 n\\) (we'll explore this \"Big O notation\" in our algorithms section). In practical terms: searching 1,000,000 items requires only about 20 comparisons, because \\(\\log_2 1{,}000{,}000 \\approx 20\\). Double the data to 2,000,000 items? You only need 21 comparisons\u2014one more.</p> <p>Example BST (numbers):</p> <pre><code>graph TD\n    A[50] --&gt; B[30]\n    A --&gt; C[70]\n    B --&gt; D[20]\n    B --&gt; E[40]\n    C --&gt; F[60]\n    C --&gt; G[80]\n\n    style A fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style B fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style C fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style D fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style E fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style F fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style G fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>To find 40:</p> <ol> <li>Start at 50 \u2192 40 &lt; 50, go left</li> <li>At 30 \u2192 40 &gt; 30, go right</li> <li>Found 40 \u2713</li> </ol> <p>Only 3 comparisons instead of scanning all 7 nodes sequentially.</p>"},{"location":"building_blocks/binary_trees_and_representation/#real-world-applications","title":"Real-World Applications","text":"Decision TreesExpression TreesFile SystemsCompression <p>Machine Learning</p> <p>Binary trees model decisions in AI systems:</p> <ul> <li>Each node represents a feature test</li> <li>Each leaf represents a classification</li> <li>Depth determines model complexity</li> </ul> <p>Compilers</p> <p>The expression <code>2 + 3 * 4</code> becomes a binary tree:</p> <pre><code>graph TD\n    Plus[\"+\"] --&gt; Two[\"2\"]\n    Plus --&gt; Times[\"*\"]\n    Times --&gt; Three[\"3\"]\n    Times --&gt; Four[\"4\"]\n\n    style Plus fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Times fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Two fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Three fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Four fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>Evaluating the tree (post-order traversal) correctly computes <code>2 + (3 * 4) = 14</code>.</p> <p>See Scheme &amp; Parse Trees for a perfect example of how code structure maps directly to these trees.</p> <p>See How Parsers Work for a deep dive into how these trees are built.</p> <p>Directory hierarchies are trees:</p> <pre><code>/\n\u251c\u2500\u2500 home/\n\u2502   \u251c\u2500\u2500 user/\n\u2502   \u2502   \u251c\u2500\u2500 documents/\n\u2502   \u2502   \u2514\u2500\u2500 pictures/\n\u2502   \u2514\u2500\u2500 shared/\n\u2514\u2500\u2500 var/\n    \u2514\u2500\u2500 log/\n</code></pre> <p>Though not strictly binary (nodes can have many children), the principle of hierarchical organization is the same.</p> <p>Huffman Encoding</p> <p>Huffman trees assign shorter binary codes to frequent characters:</p> <ul> <li>Frequent characters: shorter paths (fewer bits)</li> <li>Rare characters: longer paths (more bits)</li> </ul> <p>This is how ZIP files and JPEG images achieve compression.</p>"},{"location":"building_blocks/binary_trees_and_representation/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Binary Conversion <p>Convert the decimal number 100 to binary.</p> <p>Show your work using powers of 2.</p> Solution <p>Method 1: Repeated Division by 2</p> <pre><code>100 \u00f7 2 = 50 remainder 0  (rightmost bit)\n 50 \u00f7 2 = 25 remainder 0\n 25 \u00f7 2 = 12 remainder 1\n 12 \u00f7 2 =  6 remainder 0\n  6 \u00f7 2 =  3 remainder 0\n  3 \u00f7 2 =  1 remainder 1\n  1 \u00f7 2 =  0 remainder 1  (leftmost bit)\n</code></pre> <p>Reading remainders bottom-up: <code>1100100</code></p> <p>Method 2: Powers of 2</p> <p>100 = 64 + 32 + 4     = \\(2^6 + 2^5 + 2^2\\)     = <code>1100100</code> in binary</p> <p>Verification: \\(1 \\times 64 + 1 \\times 32 + 0 \\times 16 + 0 \\times 8 + 1 \\times 4 + 0 \\times 2 + 0 \\times 1 = 100\\) \u2713</p> Practice Problem 2: Tree Depth Calculation <p>How many distinct values can a binary tree of depth 7 distinguish?</p> <p>If you're building a decision tree for classifying animals and need to distinguish among 500 species, what minimum depth is required?</p> Solution <p>Part 1: Depth 7</p> <p>A binary tree of depth \\(n\\) can distinguish \\(2^n\\) values.</p> <p>Depth 7: \\(2^7 = 128\\) distinct values</p> <p>Part 2: 500 Species</p> <p>Need \\(2^n \\geq 500\\)</p> <ul> <li>\\(2^8 = 256\\) (too small)</li> <li>\\(2^9 = 512\\) \u2713 (sufficient)</li> </ul> <p>Minimum depth: 9</p> <p>Verification: With 9 yes/no questions, you can distinguish among 512 different animals, which covers all 500 species.</p> Practice Problem 3: Binary Search Tree Search <p>Given this binary search tree, trace the path to find the value 35:</p> <pre><code>       50\n      /  \\\n    30    70\n   /  \\   / \\\n  20  40 60 80\n     /\n    35\n</code></pre> <p>How many comparisons are needed? How does this compare to linear search?</p> Solution <p>Trace:</p> <ol> <li>Start at 50 \u2192 35 &lt; 50, go left</li> <li>At 30 \u2192 35 &gt; 30, go right</li> <li>At 40 \u2192 35 &lt; 40, go left</li> <li>Found 35 \u2713</li> </ol> <p>Comparisons needed: 4</p> <p>Linear search comparison: If the tree were stored as a flat list [50, 30, 70, 20, 40, 60, 80, 35], linear search would need to check each element until finding 35 \u2192 8 comparisons (worst case).</p> <p>BST is 2x faster in this example. For larger trees, the advantage grows exponentially\u2014searching 1 million items requires ~20 BST comparisons vs. up to 1 million linear comparisons.</p> Practice Problem 4: Abstraction Necessity <p>The 8-bit binary sequence <code>11000001</code> could represent:</p> <ul> <li>An unsigned integer</li> <li>A signed integer (two's complement)</li> <li>An ASCII character</li> <li>Part of a machine instruction</li> </ul> <p>What value does it represent in each case? Why does this demonstrate the need for abstraction?</p> Solution <p>Interpretations:</p> <ol> <li>Unsigned integer: 1\u00d7128 + 1\u00d764 + 1\u00d71 = 193</li> <li>Signed integer (two's complement): First bit is 1 (negative). Flip bits: <code>00111110</code>, add 1: <code>00111111</code> = 63, so the value is -63</li> <li>ASCII character: Decimal 193 = '\u00c1' (Latin capital A with acute accent in extended ASCII)</li> <li>Machine instruction: Could be an opcode like <code>RET</code> (return from function) in some CPU architectures</li> </ol> <p>Why abstraction is needed:</p> <p>The same bit pattern has four completely different meanings depending on context. Without type systems and high-level languages that label data (int, char, instruction, etc.), programmers would need to track every bit's intended meaning manually\u2014a recipe for catastrophic errors.</p> <p>Abstraction lets you write <code>int x = -63;</code> or <code>char c = '\u00c1';</code>, making the intent explicit and preventing misinterpretation.</p>"},{"location":"building_blocks/binary_trees_and_representation/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning Binary Number System Base-2 representation using only 0 and 1 Binary Tree Hierarchical structure where each node has \u2264 2 children Depth Number of edges from root to a node Exponential Growth Tree of depth \\(n\\) can distinguish \\(2^n\\) values Binary Search Tree Binary tree with left &lt; parent &lt; right ordering Abstraction Hiding bit-level details to provide semantic meaning and manage complexity Logarithmic Time Search efficiency \\(\\log_2 n\\) where doubling data adds only one more step"},{"location":"building_blocks/binary_trees_and_representation/#why-binary-trees-matter","title":"Why Binary Trees Matter","text":"<p>Understanding binary trees reveals:</p> <ul> <li>How computers organize information efficiently (databases, file systems)</li> <li>How compilers parse code (syntax trees, expression evaluation)</li> <li>How search algorithms work (binary search, decision trees)</li> <li>How exponential growth creates power (20 questions \u2192 1 million possibilities)</li> <li>Why logarithmic time is so valuable (\\(\\log_2(1{,}000{,}000) \\approx 20\\) comparisons)</li> </ul> <p>Binary representation is the foundation\u2014binary trees are the structure built on that foundation. Together, they explain how computers transform electrical signals into everything from spreadsheets to streaming video.</p>"},{"location":"building_blocks/binary_trees_and_representation/#further-reading","title":"Further Reading","text":"<ul> <li>David Evans, Introduction to Computing \u2014 Chapter 1 covers binary trees and representation</li> <li>Computational Thinking \u2014 Decomposition and abstraction in action</li> <li>How Parsers Work \u2014 Building syntax trees from code</li> <li>Recursive Transition Networks \u2014 Trees in parsing and grammars</li> <li>Donald Knuth, The Art of Computer Programming, Volume 1 \u2014 Definitive reference on tree algorithms</li> </ul> <p>Binary is the language of computers. Binary trees are the grammar. You can't truly understand computing without understanding both\u2014and how they work together to turn simple on/off signals into the complex systems we use every day.</p>"},{"location":"building_blocks/binary_trees_and_representation/#video-summary","title":"Video Summary","text":""},{"location":"building_blocks/computational_thinking/","title":"Computational Thinking","text":""},{"location":"building_blocks/computational_thinking/#description-master-the-mental-toolkit-of-computer-science-decomposition-pattern-recognition-abstraction-and-algorithm-design","title":"description: Master the mental toolkit of computer science: Decomposition, Pattern Recognition, Abstraction, and Algorithm Design.","text":""},{"location":"building_blocks/computational_thinking/#computational-thinking","title":"Computational Thinking","text":"<p>Before you can write code, you need to think in a way that computers can follow. That's not about memorizing syntax or learning keyboard shortcuts\u2014it's about developing a mental toolkit for breaking down problems, spotting patterns, and building solutions that scale.</p> <p>This toolkit is called computational thinking, and it's arguably more important than any programming language you'll ever learn. Languages come and go; the ability to think systematically about problems is forever.</p>"},{"location":"building_blocks/computational_thinking/#the-four-pillars","title":"The Four Pillars","text":"<p>Computational thinking rests on four core skills. They're not steps to follow in order\u2014they're lenses you apply, often simultaneously, when tackling any problem.</p>  Decomposition Pattern Recognition Abstraction Algorithm Design <p>Breaking a complex problem into smaller, manageable parts.</p> <p>When faced with something overwhelming, the natural instinct is to panic. Computational thinking says: don't solve the whole thing at once. Chop it up.</p> <p>Example: Building a Website</p> <p>\"Build a website\" is paralyzing. But decompose it:</p> <ul> <li>Design the layout</li> <li>Create the navigation</li> <li>Build the home page</li> <li>Build the about page</li> <li>Add a contact form</li> <li>Style everything with CSS</li> <li>Deploy to a server</li> </ul> <p>Suddenly, you have a todo list instead of an existential crisis. \ud83d\udcdd Much better.</p> <p>Example: Making Breakfast</p> <p>Even \"make breakfast\" decomposes:</p> <ol> <li>Decide what to eat</li> <li>Gather ingredients</li> <li>Prepare each item (eggs, toast, coffee)</li> <li>Plate and serve</li> </ol> <p>Each sub-task can be further decomposed. \"Make coffee\" becomes: fill kettle, boil water, grind beans (freshly, obviously\u2014pre-ground is for emergencies only), add to French press, pour water at exactly 200\u00b0F, wait four minutes, plunge, pour. \u2615 Now we're cooking (or brewing). This is the most important sub-task, frankly.</p> Decomposition in Practice <p>When you're stuck on a programming problem, ask yourself:</p> <ul> <li>What are the inputs to this problem?</li> <li>What are the outputs I need?</li> <li>What are the steps between input and output?</li> <li>Can any of those steps be broken down further?</li> </ul> <p>Identifying similarities, trends, and regularities.</p> <p>Once you've decomposed a problem, you often notice that several pieces look suspiciously similar. That's a pattern\u2014and patterns are opportunities.</p> <p>Example: Form Validation</p> <p>Validating a registration form:</p> <ul> <li>Check that email is valid</li> <li>Check that password is long enough</li> <li>Check that username isn't taken</li> <li>Check that age is a number</li> </ul> <p>The pattern: each field needs a validation check that returns true/false. Instead of writing completely separate code for each, you can create a general validation framework.</p> <p>Example: Sorting Algorithms</p> <p>Many sorting algorithms follow a pattern:</p> <ol> <li>Compare two elements</li> <li>Swap if needed</li> <li>Repeat until sorted</li> </ol> <p>The specific how varies (bubble sort, quicksort, merge sort), but the underlying pattern is consistent.</p> <p>Why Patterns Matter:</p> <ul> <li>Patterns let you reuse solutions</li> <li>Recognizing a pattern means you might already know how to solve this</li> <li>Patterns reveal structure you can exploit</li> </ul> <p>Focusing on essential information while ignoring irrelevant details.</p> <p>Abstraction is the art of knowing what to leave out. A map of the subway doesn't show every building, tree, and fire hydrant\u2014it shows stations and lines. That's abstraction: keeping what matters, discarding what doesn't.</p> <p>Example: Driving a Car</p> <p>When you drive, you think in terms of:</p> <ul> <li>Steering wheel</li> <li>Gas pedal</li> <li>Brake pedal</li> <li>Turn signals</li> </ul> <p>You don't think about fuel injection timing, spark plug voltage, or transmission gear ratios. Those details are abstracted away behind simple interfaces.</p> <p>Example: Finite State Machines</p> <p>A Finite State Machine is pure abstraction\u2014it models systems (traffic lights, game AI, compilers) as just states and transitions, ignoring all implementation details. You don't need to know if it's running on hardware or software; the abstraction captures the essential behavior.</p> <p>Example: Functions in Programming</p> <p>Without abstraction, sending an email means dealing with all this complexity:</p>  Python - Without Abstraction JavaScript - Without Abstraction Go - Without Abstraction Rust - Without Abstraction Java - Without Abstraction C++ - Without Abstraction Sending Email Without Abstraction<pre><code># Without abstraction: caller needs to know everything\nimport smtplib\nfrom email.mime.text import MIMEText\n\nserver = smtplib.SMTP('smtp.gmail.com', 587)  # (1)!\nserver.starttls()  # (2)!\nserver.login('me@gmail.com', 'password123')  # (3)!\nmsg = MIMEText('Hi Bob!')  # (4)!\nmsg['Subject'] = 'Hello'\nmsg['To'] = 'bob@example.com'\nserver.send_message(msg)  # (5)!\nserver.quit()  # (6)!\n</code></pre> <ol> <li>Connect to Gmail's SMTP server on port 587</li> <li>Upgrade connection to secure TLS encryption</li> <li>Authenticate with username and password</li> <li>Construct email message with MIME formatting</li> <li>Send the constructed message through the server</li> <li>Close the connection properly</li> </ol> Sending Email Without Abstraction<pre><code>// Without abstraction: caller needs to know everything\nconst nodemailer = require('nodemailer');  // (1)!\n\nconst transporter = nodemailer.createTransport({  // (2)!\n    host: 'smtp.gmail.com',\n    port: 587,\n    secure: false,  // (3)!\n    auth: {  // (4)!\n        user: 'me@gmail.com',\n        pass: 'password123'\n    }\n});\n\ntransporter.sendMail({  // (5)!\n    from: 'me@gmail.com',\n    to: 'bob@example.com',\n    subject: 'Hello',\n    text: 'Hi Bob!'\n});\n</code></pre> <ol> <li>CommonJS module import for nodemailer (Node.js email library)</li> <li>Create transport object with all SMTP configuration details</li> <li>secure: false means use STARTTLS to upgrade connection (TLS on port 587)</li> <li>Authentication credentials passed as nested object</li> <li>Send mail using configured transport with message details as object literal</li> </ol> Sending Email Without Abstraction<pre><code>// Without abstraction: caller needs to know everything\nimport (\n    \"net/smtp\"\n)\n\nfrom := \"me@gmail.com\"\npassword := \"password123\"\nto := []string{\"bob@example.com\"}  // (1)!\nsmtpHost := \"smtp.gmail.com\"\nsmtpPort := \"587\"\n\nmessage := []byte(\"Subject: Hello\\r\\n\\r\\nHi Bob!\")  // (2)!\n\nauth := smtp.PlainAuth(\"\", from, password, smtpHost)  // (3)!\nerr := smtp.SendMail(smtpHost+\":\"+smtpPort, auth, from, to, message)  // (4)!\n</code></pre> <ol> <li>Recipients as string slice (Go's dynamic array type) - SendMail accepts multiple recipients</li> <li>Message as byte slice with RFC 5322 format (headers separated by \\r\\n\\r\\n from body)</li> <li>PlainAuth creates authentication mechanism using username and password</li> <li>SendMail combines host:port, returns error for Go's explicit error handling pattern</li> </ol> Sending Email Without Abstraction<pre><code>// Without abstraction: caller needs to know everything\nuse lettre::{Message, SmtpTransport, Transport};\nuse lettre::transport::smtp::authentication::Credentials;\n\nlet email = Message::builder()  // (1)!\n    .from(\"me@gmail.com\".parse().unwrap())  // (2)!\n    .to(\"bob@example.com\".parse().unwrap())\n    .subject(\"Hello\")\n    .body(String::from(\"Hi Bob!\"))\n    .unwrap();  // (3)!\n\nlet creds = Credentials::new(\"me@gmail.com\".to_string(),  // (4)!\n                             \"password123\".to_string());\n\nlet mailer = SmtpTransport::relay(\"smtp.gmail.com\")  // (5)!\n    .unwrap()\n    .credentials(creds)\n    .build();\n\nmailer.send(&amp;email).unwrap();  // (6)!\n</code></pre> <ol> <li>Builder pattern - chain method calls to construct email object incrementally</li> <li>parse() converts string to email address type, unwrap() panics if invalid</li> <li>Final unwrap() on builder - convert Result to Message (panic on error) <li>to_string() converts &amp;str to owned String type (Credentials requires String)</li> <li>relay() creates SMTP transport for relaying through server (unwrap Result)</li> <li>send() borrows email reference, unwrap() panics if send fails</li> Sending Email Without Abstraction<pre><code>// Without abstraction: caller needs to know everything\nimport javax.mail.*;\nimport javax.mail.internet.*;\nimport java.util.Properties;\n\nProperties props = new Properties();  // (1)!\nprops.put(\"mail.smtp.host\", \"smtp.gmail.com\");\nprops.put(\"mail.smtp.port\", \"587\");\nprops.put(\"mail.smtp.auth\", \"true\");\nprops.put(\"mail.smtp.starttls.enable\", \"true\");\n\nSession session = Session.getInstance(props, new Authenticator() {  // (2)!\n    protected PasswordAuthentication getPasswordAuthentication() {  // (3)!\n        return new PasswordAuthentication(\"me@gmail.com\", \"password123\");\n    }\n});\n\nMessage message = new MimeMessage(session);  // (4)!\nmessage.setFrom(new InternetAddress(\"me@gmail.com\"));\nmessage.setRecipients(Message.RecipientType.TO,\n    InternetAddress.parse(\"bob@example.com\"));\nmessage.setSubject(\"Hello\");\nmessage.setText(\"Hi Bob!\");\n\nTransport.send(message);  // (5)!\n</code></pre> <ol> <li>Properties object stores SMTP configuration as key-value pairs</li> <li>Anonymous inner class implements Authenticator interface inline</li> <li>Override getPasswordAuthentication() to provide credentials when needed</li> <li>MimeMessage constructed with session (contains all SMTP settings)</li> <li>Static Transport.send() method sends message using session configuration</li> </ol> Sending Email Without Abstraction<pre><code>// Without abstraction: caller needs to know everything\n#include &lt;curl/curl.h&gt;\n#include &lt;string&gt;\n\nCURL *curl = curl_easy_init();  // (1)!\nif(curl) {  // (2)!\n    curl_easy_setopt(curl, CURLOPT_URL, \"smtp://smtp.gmail.com:587\");  // (3)!\n    curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_ALL);\n    curl_easy_setopt(curl, CURLOPT_USERNAME, \"me@gmail.com\");\n    curl_easy_setopt(curl, CURLOPT_PASSWORD, \"password123\");\n    curl_easy_setopt(curl, CURLOPT_MAIL_FROM, \"&lt;me@gmail.com&gt;\");\n\n    struct curl_slist *recipients = NULL;  // (4)!\n    recipients = curl_slist_append(recipients, \"&lt;bob@example.com&gt;\");\n    curl_easy_setopt(curl, CURLOPT_MAIL_RCPT, recipients);\n\n    std::string payload = \"To: bob@example.com\\r\\n\"  // (5)!\n                        \"Subject: Hello\\r\\n\"\n                        \"\\r\\nHi Bob!\";\n    curl_easy_setopt(curl, CURLOPT_READDATA, &amp;payload);\n\n    curl_easy_perform(curl);  // (6)!\n    curl_easy_cleanup(curl);\n}\n</code></pre> <ol> <li>Initialize libcurl easy interface - returns handle (NULL on failure)</li> <li>Check handle validity before using (C-style error handling)</li> <li>curl_easy_setopt() sets options using enum constants (variadic function)</li> <li>curl_slist is linked list structure for recipient list (manual memory management)</li> <li>Construct RFC 5322 message format as string with proper \\r\\n line endings</li> <li>curl_easy_perform() sends email, curl_easy_cleanup() frees allocated memory</li> </ol> <p>With abstraction, all that complexity hides behind a simple interface:</p>  Python - With Abstraction JavaScript - With Abstraction Go - With Abstraction Rust - With Abstraction Java - With Abstraction C++ - With Abstraction Sending Email With Abstraction<pre><code># With abstraction: complexity hidden\nsend_email(\"bob@example.com\", \"Hello\", \"Hi Bob!\")  # (1)!\n</code></pre> <ol> <li>All the complexity from the previous example is now hidden inside this function - caller only needs to provide recipient, subject, and message</li> </ol> Sending Email With Abstraction<pre><code>// With abstraction: complexity hidden\nsendEmail(\"bob@example.com\", \"Hello\", \"Hi Bob!\");  // (1)!\n</code></pre> <ol> <li>All the complexity from the previous example is now hidden inside this function - caller only needs to provide recipient, subject, and message</li> </ol> Sending Email With Abstraction<pre><code>// With abstraction: complexity hidden\nsendEmail(\"bob@example.com\", \"Hello\", \"Hi Bob!\")  // (1)!\n</code></pre> <ol> <li>All the complexity from the previous example is now hidden inside this function - caller only needs to provide recipient, subject, and message</li> </ol> Sending Email With Abstraction<pre><code>// With abstraction: complexity hidden\nsend_email(\"bob@example.com\", \"Hello\", \"Hi Bob!\");  // (1)!\n</code></pre> <ol> <li>All the complexity from the previous example is now hidden inside this function - caller only needs to provide recipient, subject, and message</li> </ol> Sending Email With Abstraction<pre><code>// With abstraction: complexity hidden\nsendEmail(\"bob@example.com\", \"Hello\", \"Hi Bob!\");  // (1)!\n</code></pre> <ol> <li>All the complexity from the previous example is now hidden inside this function - caller only needs to provide recipient, subject, and message</li> </ol> Sending Email With Abstraction<pre><code>// With abstraction: complexity hidden\nsend_email(\"bob@example.com\", \"Hello\", \"Hi Bob!\");  // (1)!\n</code></pre> <ol> <li>All the complexity from the previous example is now hidden inside this function - caller only needs to provide recipient, subject, and message</li> </ol> <p>The caller doesn't need to know how emails work\u2014only that they can send one. The 50 lines of SMTP configuration, authentication, and error handling still exist, but they're someone else's problem now.</p> <p>Levels of Abstraction:</p> <p>Think of a computer:</p> Level What You Interact With / Build With User Apps, buttons, windows (the interface) Application Functions, objects, APIs (the building blocks) Operating System Processes, files, memory (the system's tools) Hardware CPU, RAM, circuits (the physical components) Physics Electrons, voltage, silicon (the fundamental reality) <p>Each level abstracts the one below. You can write Python without understanding transistors. That's powerful.</p> Abstraction in Data Structures <p>A prime example of abstraction in computing is the Abstract Data Type (ADT)\u2014a way of defining data structures by what they do rather than how they're implemented.</p> <p>When you use a Stack, you call <code>PUSH</code> and <code>POP</code> without caring whether it's built with arrays or linked lists. That's abstraction hiding complexity behind a clean interface.</p> <p>Creating step-by-step instructions to solve a problem.</p> <p>An algorithm is a recipe\u2014a sequence of unambiguous steps that, when followed, produce a desired result. The key word is unambiguous: every step must be precise enough that anyone (or any computer) could follow it.</p> <p>Example: Finding the Largest Number</p> <p>Given a list of numbers, find the largest:</p> <ol> <li>Assume the first number is the largest (call it <code>max</code>)</li> <li>For each remaining number:</li> <li>If it's greater than <code>max</code>, update <code>max</code></li> <li>Return <code>max</code></li> </ol> <p>This works for any list, any size. That's the power of a well-designed algorithm.</p> <p>Example: Making a Sandwich (Precise Edition)</p> <p>\"Make a peanut butter sandwich\" isn't precise enough for a computer. Try:</p> <ol> <li>Get two slices of bread from the bag</li> <li>Place both slices on a plate, flat side up</li> <li>Open the peanut butter jar (twist lid counter-clockwise)</li> <li>Insert knife into jar</li> <li>Scoop approximately 2 tablespoons of peanut butter</li> <li>Spread peanut butter evenly across one slice of bread</li> <li>Place the other slice on top, flat side down</li> <li>Close the peanut butter jar</li> </ol> <p>Tedious? Yes. Unambiguous? Also yes. That's algorithm design. \ud83e\udd6a</p> The Sandwich Exercise <p>This is a classic CS education exercise. Try writing instructions for making a sandwich, then have someone follow them literally. You'll quickly discover your assumptions. \"Spread the peanut butter\" \u2014 with what? On which side? How much? Computers need this level of detail.</p>"},{"location":"building_blocks/computational_thinking/#computational-thinking-in-action","title":"Computational Thinking in Action","text":"<p>Let's apply all four pillars to a real problem: building a search feature for a website.</p>"},{"location":"building_blocks/computational_thinking/#step-1-decomposition","title":"Step 1: Decomposition","text":"<p>Break it down:</p> <ul> <li>Get search query from user</li> <li>Find matching items in database</li> <li>Rank results by relevance</li> <li>Display results to user</li> <li>Handle \"no results found\" case</li> </ul>"},{"location":"building_blocks/computational_thinking/#step-2-pattern-recognition","title":"Step 2: Pattern Recognition","text":"<p>This looks like other problems we've solved:</p> <ul> <li>\"Find matching items\" is similar to filtering a list</li> <li>\"Rank by relevance\" is similar to sorting</li> <li>\"Display results\" follows our standard page template</li> </ul> <p>We can reuse patterns from those solutions.</p>"},{"location":"building_blocks/computational_thinking/#step-3-abstraction","title":"Step 3: Abstraction","text":"<p>What details can we hide?</p> <ul> <li>User doesn't need to know how the database query works</li> <li>Search algorithm doesn't need to know how results are displayed</li> <li>Display code doesn't need to know how ranking works</li> </ul> <p>Each component has a clean interface; internals are hidden.</p>"},{"location":"building_blocks/computational_thinking/#step-4-algorithm-design","title":"Step 4: Algorithm Design","text":"<p>For the matching algorithm:</p> <ol> <li>Split search query into individual words</li> <li>For each item in database:</li> <li>Count how many query words appear in item's title/description</li> <li>Store count as \"relevance score\"</li> <li>Sort items by relevance score (highest first)</li> <li>Return top 20 items</li> </ol>"},{"location":"building_blocks/computational_thinking/#computational-thinking-beyond-code","title":"Computational Thinking Beyond Code","text":"<p>Here's the thing: computational thinking isn't just for programmers. These skills apply everywhere.</p> Domain Application Medicine Decompose symptoms \u2192 Pattern match to conditions \u2192 Abstract to treatment categories Law Decompose case \u2192 Pattern match to precedents \u2192 Abstract legal principles Cooking Decompose recipe \u2192 Pattern match techniques \u2192 Abstract flavor profiles Music Decompose song \u2192 Pattern match chord progressions \u2192 Abstract genre conventions Debugging Life Decompose problem \u2192 Pattern match to past experiences \u2192 Abstract lessons learned \ud83d\udc1b <p>The formal name is \"computational thinking,\" but really it's just structured problem-solving.</p>"},{"location":"building_blocks/computational_thinking/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"building_blocks/computational_thinking/#decomposing-too-much-or-too-little","title":"Decomposing Too Much (or Too Little)","text":"<ul> <li>Too little: Chunks are still too big to tackle</li> <li>Too much: You're lost in trivial details</li> </ul> <p>Find the level where each piece is solvable but not trivial.</p>"},{"location":"building_blocks/computational_thinking/#seeing-patterns-that-arent-there","title":"Seeing Patterns That Aren't There","text":"<p>Not everything is a pattern. Sometimes two similar-looking things are genuinely different. Don't force-fit solutions from one domain into another.</p>"},{"location":"building_blocks/computational_thinking/#abstracting-away-the-wrong-things","title":"Abstracting Away the Wrong Things","text":"<p>Good abstraction hides complexity while preserving essential behavior. Bad abstraction hides things you actually needed to know.</p>"},{"location":"building_blocks/computational_thinking/#ambiguous-algorithms","title":"Ambiguous Algorithms","text":"<p>\"Sort the list\" isn't an algorithm\u2014it's a wish. Algorithms must be precise enough to execute mechanically.</p>"},{"location":"building_blocks/computational_thinking/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Decompose a Mobile App <p>You're building a mobile app for tracking daily habits. Decompose this into components and sub-components.</p> <p>How would you break down just the \"streak tracking\" feature?</p> Practice Problem 2: Spot the Pattern <p>These functions all do something similar:</p> <ul> <li><code>sum(list)</code> - adds all numbers in a list</li> <li><code>product(list)</code> - multiplies all numbers in a list</li> <li><code>max(list)</code> - finds the largest number in a list</li> <li><code>concat(list)</code> - joins all strings in a list</li> </ul> <p>What's the underlying pattern? Could you write one general function that handles all of these?</p> Practice Problem 3: Write an Algorithm <p>Write precise, unambiguous instructions for:</p> <ul> <li>Finding a specific book in a library</li> <li>Determining if a word is a palindrome</li> <li>Calculating a tip at a restaurant</li> </ul>"},{"location":"building_blocks/computational_thinking/#key-takeaways","title":"Key Takeaways","text":"Pillar Question to Ask Decomposition \"How can I break this into smaller pieces?\" Pattern Recognition \"Have I seen something like this before?\" Abstraction \"What details can I safely ignore?\" Algorithm Design \"What are the exact, unambiguous steps to solve this?\""},{"location":"building_blocks/computational_thinking/#further-resources","title":"Further Resources","text":"<ul> <li>Jeannette Wing, \"Computational Thinking\" \u2014 the video below is exceptional:</li> </ul> <ul> <li>Binary Trees &amp; Representation \u2014 Hierarchical structures and abstraction</li> <li>Recursive Transition Networks \u2014 Abstraction and decomposition in action</li> <li>Backus-Naur Form \u2014 Pattern recognition applied to language structure</li> </ul> <p>Computational thinking isn't about thinking like a computer\u2014computers don't actually think. It's about thinking clearly enough that you could explain your reasoning to a computer. And if you can do that, you can explain it to anyone. That's the real superpower. \ud83e\udde0</p>"},{"location":"building_blocks/computational_thinking/#video-summary","title":"Video Summary","text":""},{"location":"building_blocks/finite_state_machines/","title":"Finite State Machines (FSMs)","text":"<p>Imagine modeling any system that moves through distinct states\u2014a traffic light cycling through red, yellow, and green; a turnstile that's either locked or unlocked; a video game enemy switching between patrolling, chasing, and attacking. These are all Finite State Machines, one of the most elegant and foundational models in computer science.</p> <p>FSMs are everywhere: traffic lights, vending machines, elevators, video game AI, text parsers, network protocols, compilers. Once you understand them, you'll start seeing them in everything. \ud83d\udc40</p> <p>Understanding FSMs requires computational thinking: decomposing systems into states, recognizing patterns in transitions, abstracting away implementation details, and designing algorithms to process inputs.</p>"},{"location":"building_blocks/finite_state_machines/#what-is-a-finite-state-machine","title":"What is a Finite State Machine?","text":"<p>A Finite State Machine is an abstract model of computation that:</p> <ul> <li>Has a finite number of states (hence the name)</li> <li>Starts in an initial state</li> <li>Transitions between states based on inputs</li> <li>May have one or more accepting states (success!)</li> </ul> <p>That's it. No infinite memory, no complex calculations\u2014just states and transitions.</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; Off\n    Off --&gt; On: press\n    On --&gt; Off: press</code></pre> <p>This is an FSM for a light switch. Two states (On, Off), one input (press), deterministic behavior. Simple, but powerful.</p>"},{"location":"building_blocks/finite_state_machines/#formal-definition","title":"Formal Definition","text":"<p>For the mathematically inclined, an FSM is a 5-tuple \\((Q, \\Sigma, \\delta, q_0, F)\\):</p> Symbol Meaning \\(Q\\) Finite set of states \\(\\Sigma\\) Finite alphabet (possible inputs) \\(\\delta\\) Transition function \\((state \\times input \\to state)\\) \\(q_0\\) Initial state \\(F\\) Set of accepting/final states <p>Don't worry if that looks intimidating\u2014we'll work with diagrams.</p>"},{"location":"building_blocks/finite_state_machines/#example-turnstile","title":"Example: Turnstile","text":"<p>A classic FSM example is a subway turnstile:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; Locked\n    Locked --&gt; Locked: push\n    Locked --&gt; Unlocked: coin\n    Unlocked --&gt; Locked: push\n    Unlocked --&gt; Unlocked: coin</code></pre> <p>States: Locked, Unlocked</p> <p>Inputs: coin, push</p> <p>Behavior:</p> <ul> <li>Start Locked</li> <li>Insert coin \u2192 Unlocked</li> <li>Push while Unlocked \u2192 Locked (you go through)</li> <li>Push while Locked \u2192 stays Locked (nothing happens)</li> <li>Insert coin while Unlocked \u2192 stays Unlocked (thanks for the extra money! \ud83d\udcb0)</li> </ul> <p>This is a complete specification of turnstile behavior. No ambiguity.</p>"},{"location":"building_blocks/finite_state_machines/#example-validating-binary-numbers-divisible-by-3","title":"Example: Validating Binary Numbers Divisible by 3","text":"<p>Here's where FSMs get interesting. Can we build a machine that accepts binary numbers divisible by 3?</p> <pre><code>stateDiagram-v2\n    direction LR\n    classDef accepting fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff\n\n    [*] --&gt; S0\n    S0 --&gt; S0: 0\n    S0 --&gt; S1: 1\n    S1 --&gt; S2: 0\n    S1 --&gt; S0: 1\n    S2 --&gt; S1: 0\n    S2 --&gt; S2: 1\n    S0 ::: accepting</code></pre> <p>Formal Definition of this FSM:</p> <ul> <li>(Q = {S0, S1, S2}</li> <li>(\\Sigma = {0, 1}</li> <li>(q_0 = S0</li> <li>(F = {S0}</li> <li>\\(\\delta\\) is defined by the following table:</li> </ul> State Input '0' Input '1' S0 S0 S1 S1 S2 S0 S2 S1 S2 <p>States represent remainders when dividing by 3:</p> <ul> <li>S0 = remainder 0 (divisible by 3!)</li> <li>S1 = remainder 1</li> <li>S2 = remainder 2</li> </ul> <p>Trace through \"110\" (binary for 6):</p> <ol> <li>Start at S0 (remainder 0)</li> <li>Read '1': move to S1 (1 mod 3 = 1)</li> <li>Read '1': move to S0 (3 mod 3 = 0)</li> <li>Read '0': stay at S0 (6 mod 3 = 0)</li> <li>End at S0 \u2014 accept! 6 is divisible by 3. \u2713</li> </ol> Try It Yourself <p>Trace \"101\" (binary for 5). Does it end in an accepting state?</p> <p>What about \"1001\" (binary for 9)?</p>"},{"location":"building_blocks/finite_state_machines/#deterministic-vs-non-deterministic","title":"Deterministic vs Non-Deterministic","text":""},{"location":"building_blocks/finite_state_machines/#deterministic-fsm-dfa","title":"Deterministic FSM (DFA)","text":"<p>Every state has exactly one transition for each input. Given a state and input, you always know where to go next.</p>"},{"location":"building_blocks/finite_state_machines/#non-deterministic-fsm-nfa","title":"Non-Deterministic FSM (NFA)","text":"<p>A state might have:</p> <ul> <li>Multiple transitions for the same input</li> <li>Transitions on \"\u03b5\" (epsilon) \u2014 moving without consuming input</li> <li>No transition for some inputs</li> </ul> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; S0\n    S0 --&gt; S0: a\n    S0 --&gt; S1: a\n    S1 --&gt; S2: b</code></pre> <p>From S0, reading 'a' could go to S0 or S1. Non-deterministic!</p> <p>The magic: NFAs and DFAs are equally powerful. Any NFA can be converted to an equivalent DFA (though the DFA might have more states). NFAs are often easier to design; DFAs are easier to implement. Best of both worlds! \u2728</p>"},{"location":"building_blocks/finite_state_machines/#mealy-vs-moore-machines","title":"Mealy vs. Moore Machines","text":"<p>FSMs can be further categorized into two types based on how they produce output: Moore machines and Mealy machines.</p>"},{"location":"building_blocks/finite_state_machines/#moore-machine","title":"Moore Machine","text":"<p>In a Moore machine, the output is determined only by the current state.</p> <ul> <li>Example: Our \"divisible by 3\" FSM is a Moore machine. The \"output\" (whether the number so far is divisible by 3) is determined just by being in state <code>S0</code>. It doesn't matter how you got there.</li> </ul> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; S0\n    state \"remainder 0 (output: Yes)\" as S0\n    state \"remainder 1 (output: No)\" as S1\n    state \"remainder 2 (output: No)\" as S2\n    S0 --&gt; S1: 1\n    S1 --&gt; S0: 1\n    S0 --&gt; S0: 0\n    S1 --&gt; S2: 0\n    S2 --&gt; S1: 0\n    S2 --&gt; S2: 1</code></pre>"},{"location":"building_blocks/finite_state_machines/#mealy-machine","title":"Mealy Machine","text":"<p>In a Mealy machine, the output is determined by both the current state and the input. The output is associated with the transition.</p> <ul> <li>Example: A vending machine giving change is a Mealy machine. If you're in the \"10 cents\" state and you input a quarter, the output is \"dispense item and give 5 cents change\".</li> </ul> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; Locked\n    Locked --&gt; Unlocked: coin / unlock_gate\n    Unlocked --&gt; Locked: push / lock_gate</code></pre> <p>Here, the output (<code>unlock_gate</code>, <code>lock_gate</code>) is written on the transition path, separated by a <code>/</code>.</p>"},{"location":"building_blocks/finite_state_machines/#key-difference","title":"Key Difference","text":"Machine Output Depends On Example Moore State only \"Is this number valid?\" Mealy State and Input \"On this input, do X\" <p>Any Moore machine can be converted to an equivalent Mealy machine, and vice versa. They are computationally equivalent, but one might be more convenient for a specific problem.</p> Historical Note: Who Were Moore and Mealy? <p>These machines are named after the computer scientists who formalized these models in the 1950s:</p> <p>Moore Machine - Named after Edward F. Moore (1925-2003), an American mathematician and computer scientist. He described this model in his 1956 paper \"Gedanken-experiments on Sequential Machines.\"</p> <p>Mealy Machine - Named after George H. Mealy (1927-2010), who published \"A Method for Synthesizing Sequential Circuits\" in 1955, describing machines where output depends on both state and input.</p> <p>Both were working at Bell Labs during this era, which was a hotbed of early computer science and information theory research (along with folks like Claude Shannon). Their models became fundamental tools in digital circuit design and formal language theory.</p>"},{"location":"building_blocks/finite_state_machines/#fsms-and-regular-languages","title":"FSMs and Regular Languages","text":""},{"location":"building_blocks/finite_state_machines/#whats-a-language-in-computer-science","title":"What's a \"Language\" in Computer Science?","text":"<p>A language is simply a set of valid strings. Examples:</p> <ul> <li>\"All strings that start with 'a' and end with 'b'\"</li> <li>\"All valid email addresses\"</li> <li>\"All binary numbers divisible by 3\"</li> <li>\"All strings with balanced parentheses\"</li> </ul>"},{"location":"building_blocks/finite_state_machines/#what-does-recognize-mean","title":"What Does \"Recognize\" Mean?","text":"<p>An FSM \"recognizes\" a language if it can correctly accept valid strings (ending in an accepting state) and reject invalid ones (ending in a non-accepting state). The FSM is essentially a validator\u2014give it a string, and it tells you whether it belongs to the language.</p>"},{"location":"building_blocks/finite_state_machines/#the-fundamental-equivalence","title":"The Fundamental Equivalence","text":"<p>FSMs recognize exactly the regular languages\u2014the same languages described by regular expressions. This isn't a coincidence. These three formalisms describe exactly the same class of languages:</p> Formalism Description FSM (DFA/NFA) State diagrams Regular Expression Pattern syntax (<code>a*b+</code>) Regular Grammar Production rules <p>Practical meaning: If you can write a regex for something, you can build an FSM for it, and vice versa. They're two different notations for the exact same thing.</p>"},{"location":"building_blocks/finite_state_machines/#examples-regular-vs-not-regular","title":"Examples: Regular vs. Not Regular","text":"<p>\u2705 Regular languages (FSM \u2713, Regex \u2713):</p> <ul> <li>\"Strings with even number of a's\" \u2014 Regex: <code>(b*ab*ab*)*</code></li> <li>\"Strings ending with '.com'\" \u2014 Regex: <code>.*\\.com</code></li> <li>\"Binary numbers divisible by 3\" \u2014 (we built this FSM earlier!)</li> </ul> <p>\u274c Not regular languages (FSM \u2717, Regex \u2717):</p> <ul> <li>\"Same number of a's and b's\" \u2014 needs counting/memory</li> <li>\"Balanced parentheses\" \u2014 needs a stack to track nesting</li> <li>\\(a^nb^n\\) (equal a's and b's) \u2014 needs unbounded counting</li> </ul>"},{"location":"building_blocks/finite_state_machines/#what-fsms-cannot-do","title":"What FSMs Cannot Do","text":"<p>FSMs have no memory beyond their current state. This means they can't:</p> <ul> <li>Count unbounded quantities (\"same number of a's and b's\")</li> <li>Match nested structures (balanced parentheses)</li> <li>Remember arbitrary history</li> </ul> <p>Example: The \"Equal A's and B's\" Language</p> <p>The language \\(\\ L = \\{a^nb^n \\mid n \\geq 0\\} \\) is NOT regular. This notation means \"n a's followed by n b's, where n is any number 0 or greater\":</p> <ul> <li>When n=0: \"\" (empty string)</li> <li>When n=1: \"ab\"</li> <li>When n=2: \"aabb\"</li> <li>When n=3: \"aaabbb\"</li> <li>When n=100: 100 a's followed by 100 b's</li> </ul> <p>Why FSMs Can't Handle This:</p> <p>To validate these strings, you'd need to:</p> <ol> <li>Count the a's: \"I saw 5 a's\"</li> <li>Remember that count: \"I need to see exactly 5 b's\"</li> <li>Count the b's and compare: \"1... 2... 3... 4... 5... match!\"</li> </ol> <p>FSMs can't do step 2. To remember any possible count, you'd need states like:</p> <ul> <li>state_0_as, state_1_as, state_2_as, state_3_as, ..., state_1000_as, ...</li> </ul> <p>Here's what this impossible FSM would look like:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; S0\n    S0 --&gt; S1: a\n    S1 --&gt; S2: a\n    S2 --&gt; S3: a\n    S3 --&gt; S4: a\n    S4 --&gt; ...: a\n    note right of S4: This continues forever!&lt;br/&gt;Need infinite states to&lt;br/&gt;count unbounded a's</code></pre> <p>But there are infinitely many possible counts, and FSMs must have a FINITE number of states. That's the fundamental limitation.</p> <p>Contrast with \"divisible by 3\": That FSM only needs 3 states (remainder 0, 1, or 2) because we track the remainder, not the actual count. The remainder is bounded\u2014it's always 0, 1, or 2. Counting to arbitrary numbers is unbounded.</p> <p>For languages requiring this kind of counting or nesting (like balanced parentheses), we need more powerful models that add memory to the state machine concept\u2014like a call stack that tracks where we are in nested structures.</p>"},{"location":"building_blocks/finite_state_machines/#real-world-fsms","title":"Real-World FSMs","text":"Traffic Light Controller Video Game AI TCP Connection Lexical Analysis <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; Green\n    Green --&gt; Yellow: timer\n    Yellow --&gt; Red: timer\n    Red --&gt; Green: timer</code></pre> <p>Real traffic lights are more complex (handling multiple directions, pedestrian buttons, sensors), but the core is an FSM.</p> <p>Enemy behavior in many games:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; Patrol\n    Patrol --&gt; Chase: see_player\n    Chase --&gt; Attack: in_range\n    Chase --&gt; Patrol: lose_player\n    Attack --&gt; Chase: player_fled\n    Attack --&gt; Patrol: player_dead</code></pre> <p>This creates believable behavior from simple rules. \ud83c\udfae Not bad for a bunch of circles and arrows.</p> <p>Network protocols are often specified as FSMs:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; CLOSED\n    CLOSED --&gt; LISTEN: passive_open\n    CLOSED --&gt; SYN_SENT: active_open\n    LISTEN --&gt; SYN_RCVD: recv_SYN\n    SYN_SENT --&gt; ESTABLISHED: recv_SYN_ACK\n    SYN_RCVD --&gt; ESTABLISHED: recv_ACK\n    ESTABLISHED --&gt; FIN_WAIT: close\n    ESTABLISHED --&gt; CLOSE_WAIT: recv_FIN</code></pre> <p>(Simplified\u2014the real TCP state diagram has more states and transitions.)</p> <p>When a compiler reads your code, the first step is tokenizing\u2014breaking the code into meaningful chunks called tokens.</p> <p>Example: The code <code>x = 42 + y</code> gets broken into tokens:</p> <ul> <li><code>x</code> (identifier/variable name)</li> <li><code>=</code> (operator)</li> <li><code>42</code> (number)</li> <li><code>+</code> (operator)</li> <li><code>y</code> (identifier/variable name)</li> </ul> <p>Compilers use FSMs to recognize different token types. Here are two FSMs\u2014one for numbers, one for identifiers (variable/function names):</p> <p>State Names</p> <p>The state names like \"InNumber\" and \"InIdentifier\" are descriptive labels that tell us what the FSM is currently doing:</p> <ul> <li>InNumber = \"currently in the middle of reading a number\"</li> <li>InIdentifier = \"currently in the middle of reading an identifier\"</li> </ul> <p>Just like \"Locked/Unlocked\" for a turnstile, these names help us understand what's happening in each state.</p> <p>Recognizing Numbers:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; Start\n    Start --&gt; InNumber: digit (0-9)\n    InNumber --&gt; InNumber: digit\n    InNumber --&gt; [*]: space/operator</code></pre> <p>Recognizing Identifiers:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; Start\n    Start --&gt; InIdentifier: letter (a-z)\n    InIdentifier --&gt; InIdentifier: letter/digit\n    InIdentifier --&gt; [*]: space/operator</code></pre> <p>How it works:</p> <ul> <li>See a digit (0-9) first \u2192 InNumber state, keep reading digits until hitting something else (space, operator, etc.) \u2192 emit a number token</li> <li>See a letter (a-z, A-Z) first \u2192 InIdentifier state, keep reading letters/digits until hitting something else \u2192 emit an identifier token</li> </ul> <p>Example trace for <code>x42</code>:</p> <ol> <li>Start state</li> <li>See 'x' (letter) \u2192 InIdentifier</li> <li>See '4' (digit, allowed in identifiers) \u2192 stay InIdentifier</li> <li>See '2' (digit) \u2192 stay InIdentifier</li> <li>See space \u2192 done, emit identifier token <code>x42</code></li> </ol> <p>This is how compilers turn source code text into structured tokens for parsing!</p>"},{"location":"building_blocks/finite_state_machines/#beyond-fsms-adding-memory","title":"Beyond FSMs: Adding Memory","text":"<p>While FSMs are powerful for many tasks, they hit a fundamental limitation: they can't count or handle nested structures. More powerful computational models extend FSMs by adding memory:</p> Feature FSM Extended Models Memory Current state only State + stack/tape Power Regular languages Context-free &amp; beyond Recursion No Yes Nesting Can't handle Handles naturally Simplicity Simpler More powerful <p>These extended models essentially add a stack or other memory structure to track nesting depth, enabling recognition of nested structures like parentheses, HTML tags, and programming language syntax.</p>"},{"location":"building_blocks/finite_state_machines/#implementing-an-fsm","title":"Implementing an FSM","text":"<p>FSMs translate directly into code. Here's a turnstile implementation:</p>  Python - Class-Based JavaScript - Class-Based Go - Class-Based Rust - Class-Based Java - Class-Based C++ - Class-Based Turnstile FSM in Python<pre><code>class Turnstile:\n    def __init__(self):\n        self.state = \"locked\"  # (1)!\n\n    def transition(self, input):  # (2)!\n        if self.state == \"locked\":  # (3)!\n            if input == \"coin\":\n                self.state = \"unlocked\"  # (4)!\n            # push while locked: stay locked\n\n        elif self.state == \"unlocked\":\n            if input == \"push\":\n                self.state = \"locked\"  # (5)!\n            # coin while unlocked: stay unlocked\n\n        return self.state\n\n# Usage\nt = Turnstile()\nprint(t.transition(\"push\"))   # locked\nprint(t.transition(\"coin\"))   # unlocked\nprint(t.transition(\"push\"))   # locked\n</code></pre> <ol> <li>Initial state - turnstile starts locked</li> <li>Process an input event and transition to next state</li> <li>Check current state to determine which transitions are valid</li> <li>Transition from locked to unlocked when coin inserted</li> <li>Transition from unlocked to locked when pushed</li> </ol> Turnstile FSM in JavaScript<pre><code>class Turnstile {\n    constructor() {  // (1)!\n        this.state = \"locked\";  // (2)!\n    }\n\n    transition(input) {\n        if (this.state === \"locked\") {  // (3)!\n            if (input === \"coin\") {\n                this.state = \"unlocked\";\n            }\n            // push while locked: stay locked\n        } else if (this.state === \"unlocked\") {\n            if (input === \"push\") {\n                this.state = \"locked\";\n            }\n            // coin while unlocked: stay unlocked\n        }\n\n        return this.state;  // (4)!\n    }\n}\n\n// Usage\nconst t = new Turnstile();\nconsole.log(t.transition(\"push\"));   // locked\nconsole.log(t.transition(\"coin\"));   // unlocked\nconsole.log(t.transition(\"push\"));   // locked\n</code></pre> <ol> <li>Constructor method called automatically when creating new instance with <code>new</code></li> <li>Instance property using <code>this</code> - each Turnstile object has its own state</li> <li>Use strict equality <code>===</code> for string comparison (preferred over <code>==</code> in JavaScript)</li> <li>Return current state after transition for convenient chaining and logging</li> </ol> Turnstile FSM in Go<pre><code>package main\n\nimport \"fmt\"\n\ntype Turnstile struct {  // (1)!\n    state string\n}\n\nfunc NewTurnstile() *Turnstile {  // (2)!\n    return &amp;Turnstile{state: \"locked\"}  // (3)!\n}\n\nfunc (t *Turnstile) Transition(input string) string {  // (4)!\n    if t.state == \"locked\" {\n        if input == \"coin\" {\n            t.state = \"unlocked\"\n        }\n        // push while locked: stay locked\n    } else if t.state == \"unlocked\" {\n        if input == \"push\" {\n            t.state = \"locked\"\n        }\n        // coin while unlocked: stay unlocked\n    }\n\n    return t.state\n}\n\nfunc main() {\n    t := NewTurnstile()\n    fmt.Println(t.Transition(\"push\"))   // locked\n    fmt.Println(t.Transition(\"coin\"))   // unlocked\n    fmt.Println(t.Transition(\"push\"))   // locked\n}\n</code></pre> <ol> <li>Define struct type - Go's way of grouping data (like a class without inheritance)</li> <li>Constructor function pattern - Go convention to prefix with \"New\" and return pointer</li> <li>Return address (&amp;) of struct initialized with field syntax</li> <li>Method with pointer receiver (*Turnstile) - allows modifying the struct's state</li> </ol> Turnstile FSM in Rust<pre><code>#[derive(Debug)]  // (1)!\nenum State {  // (2)!\n    Locked,\n    Unlocked,\n}\n\nstruct Turnstile {\n    state: State,\n}\n\nimpl Turnstile {\n    fn new() -&gt; Self {\n        Turnstile { state: State::Locked }\n    }\n\n    fn transition(&amp;mut self, input: &amp;str) -&gt; &amp;State {  // (3)!\n        match (&amp;self.state, input) {  // (4)!\n            (State::Locked, \"coin\") =&gt; self.state = State::Unlocked,\n            (State::Unlocked, \"push\") =&gt; self.state = State::Locked,\n            _ =&gt; {}  // (5)!\n        }\n\n        &amp;self.state  // (6)!\n    }\n}\n\nfn main() {\n    let mut t = Turnstile::new();\n    println!(\"{:?}\", t.transition(\"push\"));   // Locked\n    println!(\"{:?}\", t.transition(\"coin\"));   // Unlocked\n    println!(\"{:?}\", t.transition(\"push\"));   // Locked\n}\n</code></pre> <ol> <li>Derive Debug trait to enable printing State values with <code>{:?}</code> format</li> <li>Enum for type-safe states - compiler ensures only Locked or Unlocked exist</li> <li>Mutable reference (&amp;mut) required to modify state; return immutable reference</li> <li>Match on tuple (state, input) - Rust's powerful pattern matching handles all cases</li> <li>Wildcard pattern <code>_</code> matches any unhandled case (no transition, stay in current state)</li> <li>Return reference to internal state (borrowing, not transferring ownership)</li> </ol> Turnstile FSM in Java<pre><code>public class Turnstile {\n    private String state;  // (1)!\n\n    public Turnstile() {  // (2)!\n        this.state = \"locked\";\n    }\n\n    public String transition(String input) {\n        if (state.equals(\"locked\")) {  // (3)!\n            if (input.equals(\"coin\")) {\n                state = \"unlocked\";\n            }\n            // push while locked: stay locked\n        } else if (state.equals(\"unlocked\")) {\n            if (input.equals(\"push\")) {\n                state = \"locked\";\n            }\n            // coin while unlocked: stay unlocked\n        }\n\n        return state;\n    }\n\n    public static void main(String[] args) {\n        Turnstile t = new Turnstile();\n        System.out.println(t.transition(\"push\"));   // locked\n        System.out.println(t.transition(\"coin\"));   // unlocked\n        System.out.println(t.transition(\"push\"));   // locked\n    }\n}\n</code></pre> <ol> <li>Private field with public methods (encapsulation) - standard Java pattern</li> <li>Constructor with same name as class - initializes state</li> <li>Use <code>.equals()</code> for string comparison (not <code>==</code> which compares references)</li> </ol> Turnstile FSM in C++<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Turnstile {\nprivate:\n    std::string state;\n\npublic:\n    Turnstile() : state(\"locked\") {}  // (1)!\n\n    std::string transition(const std::string&amp; input) {  // (2)!\n        if (state == \"locked\") {  // (3)!\n            if (input == \"coin\") {\n                state = \"unlocked\";\n            }\n            // push while locked: stay locked\n        } else if (state == \"unlocked\") {\n            if (input == \"push\") {\n                state = \"locked\";\n            }\n            // coin while unlocked: stay unlocked\n        }\n\n        return state;\n    }\n};\n\nint main() {\n    Turnstile t;\n    std::cout &lt;&lt; t.transition(\"push\") &lt;&lt; std::endl;   // locked\n    std::cout &lt;&lt; t.transition(\"coin\") &lt;&lt; std::endl;   // unlocked\n    std::cout &lt;&lt; t.transition(\"push\") &lt;&lt; std::endl;   // locked\n    return 0;\n}\n</code></pre> <ol> <li>Initializer list - more efficient than assignment in constructor body</li> <li>Pass string by const reference to avoid copying (performance optimization)</li> <li>C++ allows <code>==</code> for string comparison (std::string overloads the operator)</li> </ol> <p>Or using a transition table:</p>  Python - Table-Driven JavaScript - Table-Driven Go - Table-Driven Rust - Table-Driven Java - Table-Driven C++ - Table-Driven Table-Driven FSM Implementation<pre><code>transitions = {  # (1)!\n    (\"locked\", \"coin\"): \"unlocked\",\n    (\"locked\", \"push\"): \"locked\",\n    (\"unlocked\", \"coin\"): \"unlocked\",\n    (\"unlocked\", \"push\"): \"locked\",\n}\n\ndef next_state(current, input):  # (2)!\n    return transitions.get((current, input), current)  # (3)!\n\n# Usage\nstate = \"locked\"\nstate = next_state(state, \"push\")   # locked\nstate = next_state(state, \"coin\")   # unlocked\nstate = next_state(state, \"push\")   # locked\n</code></pre> <ol> <li>Define all state transitions as a dictionary mapping (state, input) tuples to next states</li> <li>Look up the next state based on current state and input</li> <li>Use .get() with current state as default - if transition not defined, stay in current state</li> </ol> Table-Driven FSM Implementation<pre><code>const transitions = new Map([  // (1)!\n    [JSON.stringify([\"locked\", \"coin\"]), \"unlocked\"],  // (2)!\n    [JSON.stringify([\"locked\", \"push\"]), \"locked\"],\n    [JSON.stringify([\"unlocked\", \"coin\"]), \"unlocked\"],\n    [JSON.stringify([\"unlocked\", \"push\"]), \"locked\"],\n]);\n\nfunction nextState(current, input) {\n    const key = JSON.stringify([current, input]);  // (3)!\n    return transitions.get(key) || current;  // (4)!\n}\n\n// Usage\nlet state = \"locked\";\nstate = nextState(state, \"push\");   // locked\nstate = nextState(state, \"coin\");   // unlocked\nstate = nextState(state, \"push\");   // locked\n</code></pre> <ol> <li>Map data structure for efficient key-value lookups</li> <li>Use JSON.stringify to create string keys from [state, input] arrays (Map requires unique keys)</li> <li>Convert current state and input to same JSON string format for lookup</li> <li>Use logical OR <code>||</code> to return current state if no transition found (default behavior)</li> </ol> Table-Driven FSM Implementation<pre><code>package main\n\nimport \"fmt\"\n\ntype StateInput struct {  // (1)!\n    state string\n    input string\n}\n\nvar transitions = map[StateInput]string{  // (2)!\n    {\"locked\", \"coin\"}:   \"unlocked\",  // (3)!\n    {\"locked\", \"push\"}:   \"locked\",\n    {\"unlocked\", \"coin\"}: \"unlocked\",\n    {\"unlocked\", \"push\"}: \"locked\",\n}\n\nfunc nextState(current, input string) string {\n    key := StateInput{current, input}\n    if next, ok := transitions[key]; ok {  // (4)!\n        return next\n    }\n    return current  // (5)!\n}\n\nfunc main() {\n    state := \"locked\"\n    state = nextState(state, \"push\")   // locked\n    state = nextState(state, \"coin\")   // unlocked\n    state = nextState(state, \"push\")   // locked\n    fmt.Println(state)\n}\n</code></pre> <ol> <li>Define custom struct to use as map key (Go maps require comparable types)</li> <li>Map with struct keys - Go's type-safe alternative to tuples</li> <li>Struct literal syntax - field names optional when in declaration order</li> <li>Two-value assignment from map lookup: value and \"ok\" boolean (comma-ok idiom)</li> <li>Return current state if key not found in map (default behavior)</li> </ol> Table-Driven FSM Implementation<pre><code>use std::collections::HashMap;\n\nfn next_state(current: &amp;str, input: &amp;str,\n              transitions: &amp;HashMap&lt;(&amp;str, &amp;str), &amp;str&gt;) -&gt; &amp;str {  // (1)!\n    transitions.get(&amp;(current, input)).unwrap_or(&amp;current)  // (2)!\n}\n\nfn main() {\n    let transitions: HashMap&lt;(&amp;str, &amp;str), &amp;str&gt; = [  // (3)!\n        ((\"locked\", \"coin\"), \"unlocked\"),\n        ((\"locked\", \"push\"), \"locked\"),\n        ((\"unlocked\", \"coin\"), \"unlocked\"),\n        ((\"unlocked\", \"push\"), \"locked\"),\n    ].iter().cloned().collect();  // (4)!\n\n    let mut state = \"locked\";\n    state = next_state(state, \"push\", &amp;transitions);   // locked\n    state = next_state(state, \"coin\", &amp;transitions);   // unlocked\n    state = next_state(state, \"push\", &amp;transitions);   // locked\n    println!(\"{}\", state);\n}\n</code></pre> <ol> <li>HashMap with tuple keys - Rust tuples are hashable and implement Eq/Hash</li> <li>unwrap_or returns reference to current state if key not found (Option handling)</li> <li>Type annotation shows HashMap maps (&amp;str, &amp;str) tuples to &amp;str values</li> <li>Convert array to HashMap using iterator: iter() creates iterator, cloned() copies elements, collect() builds HashMap</li> </ol> Table-Driven FSM Implementation<pre><code>import java.util.HashMap;\nimport java.util.Map;\n\nclass StateInput {  // (1)!\n    String state;\n    String input;\n\n    StateInput(String state, String input) {\n        this.state = state;\n        this.input = input;\n    }\n\n    @Override\n    public boolean equals(Object o) {  // (2)!\n        if (!(o instanceof StateInput)) return false;\n        StateInput si = (StateInput) o;\n        return state.equals(si.state) &amp;&amp; input.equals(si.input);\n    }\n\n    @Override\n    public int hashCode() {  // (3)!\n        return state.hashCode() * 31 + input.hashCode();\n    }\n}\n\npublic class FSM {\n    private static Map&lt;StateInput, String&gt; transitions = new HashMap&lt;&gt;();\n\n    static {  // (4)!\n        transitions.put(new StateInput(\"locked\", \"coin\"), \"unlocked\");\n        transitions.put(new StateInput(\"locked\", \"push\"), \"locked\");\n        transitions.put(new StateInput(\"unlocked\", \"coin\"), \"unlocked\");\n        transitions.put(new StateInput(\"unlocked\", \"push\"), \"locked\");\n    }\n\n    public static String nextState(String current, String input) {\n        return transitions.getOrDefault(new StateInput(current, input), current);  // (5)!\n    }\n\n    public static void main(String[] args) {\n        String state = \"locked\";\n        state = nextState(state, \"push\");   // locked\n        state = nextState(state, \"coin\");   // unlocked\n        state = nextState(state, \"push\");   // locked\n        System.out.println(state);\n    }\n}\n</code></pre> <ol> <li>Custom class needed as HashMap key (Java doesn't have tuple literals)</li> <li>Override equals() to define structural equality (required for HashMap lookups)</li> <li>Override hashCode() to match equals() contract (multiply by prime 31 to reduce collisions)</li> <li>Static initializer block - runs once when class loads to populate transitions</li> <li>getOrDefault() returns current state if key not in map (cleaner than null check)</li> </ol> Table-Driven FSM Implementation<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\nusing StateInput = std::pair&lt;std::string, std::string&gt;;  // (1)!\n\nstd::map&lt;StateInput, std::string&gt; transitions = {  // (2)!\n    {{\"locked\", \"coin\"}, \"unlocked\"},  // (3)!\n    {{\"locked\", \"push\"}, \"locked\"},\n    {{\"unlocked\", \"coin\"}, \"unlocked\"},\n    {{\"unlocked\", \"push\"}, \"locked\"},\n};\n\nstd::string nextState(const std::string&amp; current, const std::string&amp; input) {\n    StateInput key = {current, input};\n    auto it = transitions.find(key);  // (4)!\n    return (it != transitions.end()) ? it-&gt;second : current;  // (5)!\n}\n\nint main() {\n    std::string state = \"locked\";\n    state = nextState(state, \"push\");   // locked\n    state = nextState(state, \"coin\");   // unlocked\n    state = nextState(state, \"push\");   // locked\n    std::cout &lt;&lt; state &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <ol> <li>Type alias for std::pair - provides tuple-like behavior for map keys</li> <li>std::map automatically ordered by keys (uses &lt; operator on pairs)</li> <li>Nested braces: outer for map entry, inner for pair construction</li> <li>find() returns iterator to element (or end() if not found)</li> <li>Ternary operator checks if iterator valid, accesses value with -&gt;second, else returns current</li> </ol> <p>The table-driven approach scales better for complex FSMs.</p>"},{"location":"building_blocks/finite_state_machines/#minimizing-fsms","title":"Minimizing FSMs","text":"<p>Two FSMs are equivalent if they accept the same language. Often, an FSM can be minimized\u2014reduced to fewer states while maintaining the same behavior.</p>"},{"location":"building_blocks/finite_state_machines/#what-does-minimal-mean","title":"What Does \"Minimal\" Mean?","text":"<p>A minimal DFA is the smallest possible FSM (fewest states) that still recognizes the same language. Sometimes you can build different FSMs that accept exactly the same strings, but one has more states than necessary.</p> <p>Example: Two FSMs that both accept \"strings ending in 'ab'\" :</p> <ul> <li>Bloated version (5 states): Might have redundant states that behave identically\u2014like having two different \"saw an 'a'\" states</li> <li>Minimal version (3 states): Start \u2192 SawA \u2192 SawAB (accepting)</li> </ul> <p>Both accept the same language, but the minimal one is more efficient.</p>"},{"location":"building_blocks/finite_state_machines/#minimization-example","title":"Minimization Example","text":"<p>Consider an FSM that accepts strings containing either \"aa\" or \"bb\" as a substring.</p> <p>A non-minimal FSM:</p> <p>This FSM works, but states <code>S2</code> and <code>S4</code> are redundant. They are both accepting states, and from there on, any input leads back to the same state. They are functionally identical.</p> <pre><code>stateDiagram-v2\n    direction LR\n    classDef accepting fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff\n\n    [*] --&gt; S0\n    S0 --&gt; S1: a\n    S0 --&gt; S3: b\n    S1 --&gt; S2: a\n    S1 --&gt; S3: b\n    S2 --&gt; S2: a\n    S2 --&gt; S2: b\n    S3 --&gt; S1: a\n    S3 --&gt; S4: b\n    S4 --&gt; S4: a\n    S4 --&gt; S4: b\n    S2:::accepting\n    S4:::accepting</code></pre> <p>The minimal FSM:</p> <p>By merging the equivalent states <code>S2</code> and <code>S4</code> into a single accepting state (<code>S24</code>), we get a minimal FSM that recognizes the exact same language with fewer states.</p> <pre><code>stateDiagram-v2\n    direction LR\n    classDef accepting fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff\n\n    [*] --&gt; S0\n    S0 --&gt; S1: a\n    S0 --&gt; S3: b\n    S1 --&gt; S24: a\n    S1 --&gt; S3: b\n    S3 --&gt; S1: a\n    S3 --&gt; S24: b\n    S24 --&gt; S24: a\n    S24 --&gt; S24: b\n    S24:::accepting</code></pre>"},{"location":"building_blocks/finite_state_machines/#why-minimize","title":"Why Minimize?","text":"<ul> <li>Fewer states = less memory</li> <li>Fewer transitions = faster lookup</li> <li>Canonical form = minimal DFAs for the same language are identical, enabling comparison</li> </ul>"},{"location":"building_blocks/finite_state_machines/#hopcrofts-algorithm","title":"Hopcroft's Algorithm","text":"<p>Hopcroft's algorithm automatically finds and removes redundant states from any DFA, producing the minimal version. It's like a \"compression\" algorithm for FSMs.</p> <p>When is this useful?</p> <p>When you write a regex like <code>a*b+</code>, there are automatic algorithms that convert it into an FSM. But the generated FSM often has extra, redundant states. Minimization algorithms clean this up, giving you the most efficient FSM possible.</p>"},{"location":"building_blocks/finite_state_machines/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Design an FSM <p>Create an FSM that accepts strings over {a, b} that contain an even number of a's.</p> <p>Hint: How many states do you need? What do they represent?</p> Practice Problem 2: Vending Machine <p>Design an FSM for a vending machine that:</p> <ul> <li>Accepts nickels (5\u00a2), dimes (10\u00a2), and quarters (25\u00a2)</li> <li>Dispenses when total reaches 30\u00a2 or more</li> <li>Returns to start after dispensing</li> </ul> <p>What are your states? (Hint: think about accumulated amounts)</p> Practice Problem 3: Prove It's Not Regular <p>The language \\( L = \\{a^nb^n \\mid n \\geq 0\\} \\) is not regular.</p> <p>Try to design an FSM for it. Where do you get stuck? What would you need that an FSM doesn't have?</p>"},{"location":"building_blocks/finite_state_machines/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning State A configuration the machine can be in Transition Rule for moving between states Initial State Where computation begins Accepting State Success! Input is valid DFA Deterministic \u2014 one transition per input NFA Non-deterministic \u2014 multiple options possible Regular Language What FSMs can recognize"},{"location":"building_blocks/finite_state_machines/#further-reading","title":"Further Reading","text":"<p>More articles coming soon on related topics:</p> <ul> <li>Regular Expressions \u2014 Another notation for regular languages</li> <li>Recursive Transition Networks \u2014 FSMs with recursion</li> <li>Backus-Naur Form \u2014 Describing context-free languages</li> </ul> <p>FSMs are the \"hello world\" of computation theory\u2014simple enough to fully understand, powerful enough to be genuinely useful. Every computer scientist should have them in their mental toolkit. They're proof that sometimes, constraints (finite states, no memory) force elegant solutions. \ud83d\udd04</p>"},{"location":"building_blocks/finite_state_machines/#video-summary","title":"Video Summary","text":""},{"location":"building_blocks/how_parsers_work/","title":"How Parsers Work","text":""},{"location":"building_blocks/how_parsers_work/#description-from-raw-text-to-meaning-how-parsers-use-grammars-to-understand-code-and-data","title":"description: From raw text to meaning: How parsers use grammars to understand code and data.","text":""},{"location":"building_blocks/how_parsers_work/#how-parsers-work","title":"How Parsers Work","text":"<p>You've learned about RTNs, BNF, and Finite State Machines. These are all ways to describe languages. But how do we actually use these descriptions to process text? How does Python know that <code>print(\"hello\")</code> is valid but <code>print(\"hello</code> isn't?</p> <p>The answer is parsing\u2014the process of analyzing text according to a grammar. It's how compilers understand your code, how browsers render HTML, and how your JSON config files become usable data. \ud83c\udfaf</p>"},{"location":"building_blocks/how_parsers_work/#why-is-parsing-necessary","title":"Why Is Parsing Necessary?","text":"<p>Computers can't directly understand text\u2014not even simple code like <code>x = 2 + 3</code>. Here's why parsing is essential:</p> <p>The Problem: Text is ambiguous and unstructured</p> <p>When you write <code>2 + 3 * 4</code>, you know multiplication happens first. But to a computer, it's just a string: <code>\"2 + 3 * 4\"</code>. How does it know:</p> <ul> <li>What's an operator vs. a number?</li> <li>Which operation happens first?</li> <li>Whether the syntax is valid?</li> <li>How to represent nested structures like <code>f(g(x))</code>?</li> </ul> <p>What Happens Without Parsing?</p> <p>Imagine trying to execute code directly from text:</p> <ul> <li><code>\"x = 2 + 3 * 4\"</code> - Which <code>+</code> or <code>*</code> do you do first?</li> <li><code>\"if (x &gt; 5) print(x)\"</code> - Where does the condition end and the body begin?</li> <li><code>\"func(a, b)\"</code> - How do you know <code>func</code> is a function call and <code>a, b</code> are arguments?</li> </ul> <p>You'd need custom logic for every possible code pattern. It's chaos.</p> <p>The Solution: Structured Representation</p> <p>Parsing transforms unstructured text into a tree structure that:</p> <ol> <li>\u2713 Validates syntax (\"Is this valid code?\")</li> <li>\u2713 Captures meaning (\"What operations are being done?\")</li> <li>\u2713 Shows relationships (\"Which operations happen first?\")</li> <li>\u2713 Enables execution (\"Now I can evaluate/compile this!\")</li> </ol> <p>Without parsing, you can't compile, execute, or even validate code. It's the bridge between human-readable text and computer-executable instructions.</p>"},{"location":"building_blocks/how_parsers_work/#the-big-picture","title":"The Big Picture","text":"<p>When a compiler or interpreter processes your code, it goes through three stages:</p> <p>Step 1: Lexical Analysis <pre><code>flowchart LR\n    A[(\"&lt;b&gt;Source Code&lt;/b&gt;\")]\n    B[\"&lt;b&gt;Lexer&lt;/b&gt;\"]\n    C[(\"&lt;b&gt;Tokens&lt;/b&gt;\")]\n\n    A --&gt;|input| B\n    B --&gt;|output| C\n\n    style A fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style B fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style C fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre></p> <p>Step 2: Parsing <pre><code>flowchart LR\n    A[(\"&lt;b&gt;Tokens&lt;/b&gt;\")]\n    B[\"&lt;b&gt;Parser&lt;/b&gt;\"]\n    C[(\"&lt;b&gt;Parse Tree / AST&lt;/b&gt;\")]\n\n    A --&gt;|input| B\n    B --&gt;|output| C\n\n    style A fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style B fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style C fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre></p> <p>Step 3: Compilation/Interpretation <pre><code>flowchart LR\n    A[(\"&lt;b&gt;Parse Tree / AST&lt;/b&gt;\")]\n    B[\"&lt;b&gt;Compiler / Interpreter&lt;/b&gt;\"]\n    C[(\"&lt;b&gt;Result&lt;/b&gt;\")]\n\n    A --&gt;|input| B\n    B --&gt;|output| C\n\n    style A fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style B fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style C fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre></p> Stage Input Output What It Does Lexer Source Code Tokens Breaks text into meaningful chunksExample: <code>\"x = 42\"</code> \u2192 <code>[ID:x, EQUALS, NUM:42]</code> Parser Tokens Parse Tree / AST Builds a tree structure from tokensExample: Tokens \u2192 Tree with assignment node Compiler/Interpreter Parse Tree / AST Result Executes or compiles the treeExample: Tree \u2192 machine code or output <p>What is AST?</p> <p>AST stands for Abstract Syntax Tree - a simplified tree structure representing the code's meaning and structure, without unnecessary syntax details. More details below!</p> <p>We'll focus on the first two stages: lexing and parsing.</p>"},{"location":"building_blocks/how_parsers_work/#stage-1-lexical-analysis-lexing","title":"Stage 1: Lexical Analysis (Lexing)","text":"<p>The lexer (or tokenizer) breaks raw text into meaningful chunks called tokens. It's like turning a stream of characters into a stream of words.</p>"},{"location":"building_blocks/how_parsers_work/#what-tokens-look-like","title":"What Tokens Look Like","text":"<p>For the expression <code>total = price * 2 + tax</code>:</p> Token Type Value IDENTIFIER \"total\" EQUALS \"=\" IDENTIFIER \"price\" STAR \"*\" NUMBER \"2\" PLUS \"+\" IDENTIFIER \"tax\" <p>The lexer doesn't understand grammar\u2014it just recognizes patterns. \"Is this a number? A keyword? An operator?\" That's all it asks. Simple creature, the lexer. \ud83d\udd0d</p>"},{"location":"building_blocks/how_parsers_work/#lexer-implementation","title":"Lexer Implementation","text":"<p>Lexers are typically implemented as Finite State Machines and use Regular Expressions to define token patterns:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; Start\n    Start --&gt; InNumber: digit\n    InNumber --&gt; InNumber: digit\n    InNumber --&gt; Start: whitespace [emit NUMBER]\n    Start --&gt; InIdent: letter\n    InIdent --&gt; InIdent: letter/digit\n    InIdent --&gt; Start: whitespace [emit IDENTIFIER]\n    Start --&gt; Start: whitespace [skip]\n    Start --&gt; Start: + [emit PLUS]\n    Start --&gt; Start: * [emit STAR]\n    Start --&gt; Start: = [emit EQUALS]</code></pre> <p>Here's a simple lexer implementation:</p>  Python - Lexer JavaScript - Lexer Go - Lexer Rust - Lexer Java - Lexer C++ - Lexer Simple Lexer in Python<pre><code>import re\n\nTOKEN_SPEC = [  # (1)!\n    ('NUMBER',   r'\\d+'),\n    ('IDENT',    r'[a-zA-Z_][a-zA-Z0-9_]*'),\n    ('PLUS',     r'\\+'),\n    ('MINUS',    r'-'),\n    ('STAR',     r'\\*'),\n    ('SLASH',    r'/'),\n    ('EQUALS',   r'='),\n    ('LPAREN',   r'\\('),\n    ('RPAREN',   r'\\)'),\n    ('SKIP',     r'[ \\t]+'),  # (2)!\n]\n\ndef tokenize(text):\n    tokens = []\n    pos = 0  # (3)!\n    while pos &lt; len(text):\n        for token_type, pattern in TOKEN_SPEC:  # (4)!\n            regex = re.compile(pattern)\n            match = regex.match(text, pos)  # (5)!\n            if match:\n                if token_type != 'SKIP':  # (6)!\n                    tokens.append((token_type, match.group()))\n                pos = match.end()  # (7)!\n                break\n        else:  # (8)!\n            raise SyntaxError(f\"Unknown character: {text[pos]}\")\n    return tokens\n\nprint(tokenize(\"x = 42 + y\"))\n# Output: [('IDENT', 'x'), ('EQUALS', '='), ('NUMBER', '42'),\n#          ('PLUS', '+'), ('IDENT', 'y')]\n</code></pre> <ol> <li>Define all token types and their regex patterns as (name, pattern) tuples</li> <li>SKIP tokens (whitespace) are recognized but not added to the output</li> <li>Track current position in the input string</li> <li>Try each token pattern in order until one matches</li> <li>Try to match the pattern at the current position</li> <li>Only add non-whitespace tokens to the result</li> <li>Move position forward past the matched token</li> <li>If no pattern matches, we have an invalid character</li> </ol> Simple Lexer in JavaScript<pre><code>const TOKEN_SPEC = [  // (1)!\n    ['NUMBER',  /\\d+/],\n    ['IDENT',   /[a-zA-Z_][a-zA-Z0-9_]*/],\n    ['PLUS',    /\\+/],\n    ['MINUS',   /-/],\n    ['STAR',    /\\*/],\n    ['SLASH',   /\\//],\n    ['EQUALS',  /=/],\n    ['LPAREN',  /\\(/],\n    ['RPAREN',  /\\)/],\n    ['SKIP',    /[ \\t]+/],  // (2)!\n];\n\nfunction tokenize(text) {\n    const tokens = [];\n    let pos = 0;  // (3)!\n\n    while (pos &lt; text.length) {\n        let matched = false;\n\n        for (const [tokenType, pattern] of TOKEN_SPEC) {  // (4)!\n            const regex = new RegExp('^' + pattern.source);  // (5)!\n            const match = text.slice(pos).match(regex);  // (6)!\n\n            if (match) {\n                if (tokenType !== 'SKIP') {  // (7)!\n                    tokens.push([tokenType, match[0]]);\n                }\n                pos += match[0].length;  // (8)!\n                matched = true;\n                break;\n            }\n        }\n\n        if (!matched) {  // (9)!\n            throw new SyntaxError(`Unknown character: ${text[pos]}`);\n        }\n    }\n\n    return tokens;\n}\n\nconsole.log(tokenize(\"x = 42 + y\"));\n// Output: [['IDENT', 'x'], ['EQUALS', '='], ['NUMBER', '42'],\n//          ['PLUS', '+'], ['IDENT', 'y']]\n</code></pre> <ol> <li>Define token types as [name, regex] pairs (arrays in JS, not tuples)</li> <li>SKIP tokens recognized but not added to output</li> <li>Track current position in input string</li> <li>Destructuring assignment extracts tokenType and pattern from each pair</li> <li>Anchor regex with <code>^</code> to match only at current position</li> <li><code>slice(pos)</code> creates substring from current position to end</li> <li>Filter out whitespace tokens from final result</li> <li>Move position forward by length of matched token</li> <li>No pattern matched - input contains invalid character</li> </ol> Simple Lexer in Go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n\ntype TokenSpec struct {  // (1)!\n    tokenType string\n    pattern   *regexp.Regexp\n}\n\ntype Token struct {\n    Type  string\n    Value string\n}\n\nfunc tokenize(text string) ([]Token, error) {  // (2)!\n    tokenSpecs := []TokenSpec{  // (3)!\n        {\"NUMBER\", regexp.MustCompile(`^\\d+`)},  // (4)!\n        {\"IDENT\", regexp.MustCompile(`^[a-zA-Z_][a-zA-Z0-9_]*`)},\n        {\"PLUS\", regexp.MustCompile(`^\\+`)},\n        {\"MINUS\", regexp.MustCompile(`^-`)},\n        {\"STAR\", regexp.MustCompile(`^\\*`)},\n        {\"SLASH\", regexp.MustCompile(`^/`)},\n        {\"EQUALS\", regexp.MustCompile(`^=`)},\n        {\"LPAREN\", regexp.MustCompile(`^\\(`)},\n        {\"RPAREN\", regexp.MustCompile(`^\\)`)},\n        {\"SKIP\", regexp.MustCompile(`^[ \\t]+`)},  // (5)!\n    }\n\n    tokens := []Token{}\n    pos := 0  // (6)!\n\n    for pos &lt; len(text) {\n        matched := false\n\n        for _, spec := range tokenSpecs {  // (7)!\n            match := spec.pattern.FindString(text[pos:])  // (8)!\n            if match != \"\" {\n                if spec.tokenType != \"SKIP\" {  // (9)!\n                    tokens = append(tokens, Token{spec.tokenType, match})\n                }\n                pos += len(match)  // (10)!\n                matched = true\n                break\n            }\n        }\n\n        if !matched {  // (11)!\n            return nil, fmt.Errorf(\"unknown character: %c\", text[pos])\n        }\n    }\n\n    return tokens, nil\n}\n\nfunc main() {\n    tokens, _ := tokenize(\"x = 42 + y\")\n    fmt.Println(tokens)\n    // Output: [{IDENT x} {EQUALS =} {NUMBER 42} {PLUS +} {IDENT y}]\n}\n</code></pre> <ol> <li>Define struct to hold token type name and compiled regex pattern</li> <li>Returns slice of tokens and error (idiomatic Go error handling)</li> <li>Slice of TokenSpec structs initialized inline</li> <li>Raw string literals (backticks) used for regex patterns in Go</li> <li>SKIP tokens for whitespace (recognized but not stored)</li> <li>Track current position as integer index</li> <li>Underscore <code>_</code> discards the index (we only need the spec)</li> <li>Slice <code>text[pos:]</code> creates substring from position to end</li> <li>Filter out whitespace tokens from results</li> <li>Advance position by length of matched string</li> <li>No pattern matched - return error with unknown character</li> </ol> Simple Lexer in Rust<pre><code>use regex::Regex;\n\n#[derive(Debug)]  // (1)!\nstruct Token {\n    token_type: String,\n    value: String,\n}\n\nfn tokenize(text: &amp;str) -&gt; Result&lt;Vec&lt;Token&gt;, String&gt; {  // (2)!\n    let token_specs = vec![  // (3)!\n        (\"NUMBER\", Regex::new(r\"^\\d+\").unwrap()),  // (4)!\n        (\"IDENT\", Regex::new(r\"^[a-zA-Z_][a-zA-Z0-9_]*\").unwrap()),\n        (\"PLUS\", Regex::new(r\"^\\+\").unwrap()),\n        (\"MINUS\", Regex::new(r\"^-\").unwrap()),\n        (\"STAR\", Regex::new(r\"^\\*\").unwrap()),\n        (\"SLASH\", Regex::new(r\"^/\").unwrap()),\n        (\"EQUALS\", Regex::new(r\"^=\").unwrap()),\n        (\"LPAREN\", Regex::new(r\"^\\(\").unwrap()),\n        (\"RPAREN\", Regex::new(r\"^\\)\").unwrap()),\n        (\"SKIP\", Regex::new(r\"^[ \\t]+\").unwrap()),  // (5)!\n    ];\n\n    let mut tokens = Vec::new();\n    let mut pos = 0;  // (6)!\n\n    while pos &lt; text.len() {\n        let remaining = &amp;text[pos..];  // (7)!\n        let mut matched = false;\n\n        for (token_type, pattern) in &amp;token_specs {  // (8)!\n            if let Some(mat) = pattern.find(remaining) {  // (9)!\n                if *token_type != \"SKIP\" {  // (10)!\n                    tokens.push(Token {\n                        token_type: token_type.to_string(),\n                        value: mat.as_str().to_string(),\n                    });\n                }\n                pos += mat.end();  // (11)!\n                matched = true;\n                break;\n            }\n        }\n\n        if !matched {  // (12)!\n            return Err(format!(\"Unknown character: {}\", &amp;text[pos..pos+1]));\n        }\n    }\n\n    Ok(tokens)  // (13)!\n}\n\nfn main() {\n    let tokens = tokenize(\"x = 42 + y\").unwrap();\n    println!(\"{:?}\", tokens);\n    // Output: [Token { token_type: \"IDENT\", value: \"x\" }, ...]\n}\n</code></pre> <ol> <li>Auto-derive Debug trait for printing token structures</li> <li>Returns <code>Result&lt;Vec&lt;Token&gt;, String&gt;</code> - Rust's idiomatic error handling</li> <li>Vector of tuples containing token type strings and compiled regex patterns</li> <li>Raw strings <code>r\"...\"</code> don't require escaping backslashes in Rust</li> <li>SKIP tokens recognized but not added to result vector</li> <li>Track position as byte index (mut allows mutation)</li> <li>Create string slice from current position to end</li> <li>Borrow token_specs with <code>&amp;</code> to iterate without consuming</li> <li><code>if let</code> pattern matching extracts match if pattern succeeds</li> <li>Dereference <code>*token_type</code> to compare the &amp;str with string literal</li> <li>Advance position by number of bytes matched</li> <li>No pattern matched - return Err variant with error message</li> <li>Return Ok variant wrapping the successful token vector</li> </ol> Simple Lexer in Java<pre><code>import java.util.*;\nimport java.util.regex.*;\n\nclass Token {\n    String type;\n    String value;\n\n    Token(String type, String value) {\n        this.type = type;\n        this.value = value;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + type + \", \" + value + \")\";\n    }\n}\n\nclass Lexer {\n    static class TokenSpec {  // (1)!\n        String type;\n        Pattern pattern;\n\n        TokenSpec(String type, String pattern) {\n            this.type = type;\n            this.pattern = Pattern.compile(\"^\" + pattern);  // (2)!\n        }\n    }\n\n    public static List&lt;Token&gt; tokenize(String text) {\n        List&lt;TokenSpec&gt; specs = Arrays.asList(  // (3)!\n            new TokenSpec(\"NUMBER\", \"\\\\d+\"),  // (4)!\n            new TokenSpec(\"IDENT\", \"[a-zA-Z_][a-zA-Z0-9_]*\"),\n            new TokenSpec(\"PLUS\", \"\\\\+\"),\n            new TokenSpec(\"MINUS\", \"-\"),\n            new TokenSpec(\"STAR\", \"\\\\*\"),\n            new TokenSpec(\"SLASH\", \"/\"),\n            new TokenSpec(\"EQUALS\", \"=\"),\n            new TokenSpec(\"LPAREN\", \"\\\\(\"),\n            new TokenSpec(\"RPAREN\", \"\\\\)\"),\n            new TokenSpec(\"SKIP\", \"[ \\\\t]+\")  // (5)!\n        );\n\n        List&lt;Token&gt; tokens = new ArrayList&lt;&gt;();\n        int pos = 0;  // (6)!\n\n        while (pos &lt; text.length()) {\n            boolean matched = false;\n\n            for (TokenSpec spec : specs) {  // (7)!\n                Matcher matcher = spec.pattern.matcher(text.substring(pos));  // (8)!\n                if (matcher.find()) {\n                    if (!spec.type.equals(\"SKIP\")) {  // (9)!\n                        tokens.add(new Token(spec.type, matcher.group()));\n                    }\n                    pos += matcher.end();  // (10)!\n                    matched = true;\n                    break;\n                }\n            }\n\n            if (!matched) {  // (11)!\n                throw new RuntimeException(\"Unknown character: \" + text.charAt(pos));\n            }\n        }\n\n        return tokens;\n    }\n\n    public static void main(String[] args) {\n        List&lt;Token&gt; tokens = tokenize(\"x = 42 + y\");\n        System.out.println(tokens);\n        // Output: [(IDENT, x), (EQUALS, =), (NUMBER, 42), (PLUS, +), (IDENT, y)]\n    }\n}\n</code></pre> <ol> <li>Inner static class holds token type name and compiled regex Pattern</li> <li>Compile pattern with <code>^</code> anchor to match at start of string</li> <li>Create immutable list using Arrays.asList helper method</li> <li>Double backslash <code>\\\\</code> needed in Java strings to represent single backslash in regex</li> <li>SKIP tokens for whitespace (tabs and spaces)</li> <li>Track current position as integer index</li> <li>Enhanced for-loop iterates over token specs</li> <li>Create substring from current position and try to match pattern</li> <li>Filter out whitespace tokens from final result</li> <li>Advance position by length of matched region</li> <li>No pattern matched - throw runtime exception with character</li> </ol> Simple Lexer in C++<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;regex&gt;\n#include &lt;string&gt;\n#include &lt;stdexcept&gt;\n\nstruct Token {\n    std::string type;\n    std::string value;\n};\n\nstruct TokenSpec {  // (1)!\n    std::string type;\n    std::regex pattern;\n};\n\nstd::vector&lt;Token&gt; tokenize(const std::string&amp; text) {  // (2)!\n    std::vector&lt;TokenSpec&gt; specs = {  // (3)!\n        {\"NUMBER\", std::regex(R\"(^\\d+)\")},  // (4)!\n        {\"IDENT\", std::regex(R\"(^[a-zA-Z_][a-zA-Z0-9_]*)\")},\n        {\"PLUS\", std::regex(R\"(^\\+)\")},\n        {\"MINUS\", std::regex(R\"(^-)\")},\n        {\"STAR\", std::regex(R\"(^\\*)\")},\n        {\"SLASH\", std::regex(R\"(^/)\")},\n        {\"EQUALS\", std::regex(R\"(^=)\")},\n        {\"LPAREN\", std::regex(R\"(^\\()\")},\n        {\"RPAREN\", std::regex(R\"(^\\))\")},\n        {\"SKIP\", std::regex(R\"(^[ \\t]+)\")}  // (5)!\n    };\n\n    std::vector&lt;Token&gt; tokens;\n    size_t pos = 0;  // (6)!\n\n    while (pos &lt; text.length()) {\n        bool matched = false;\n        std::string remaining = text.substr(pos);  // (7)!\n\n        for (const auto&amp; spec : specs) {  // (8)!\n            std::smatch match;  // (9)!\n            if (std::regex_search(remaining, match, spec.pattern)) {  // (10)!\n                if (spec.type != \"SKIP\") {  // (11)!\n                    tokens.push_back({spec.type, match.str()});\n                }\n                pos += match.length();  // (12)!\n                matched = true;\n                break;\n            }\n        }\n\n        if (!matched) {  // (13)!\n            throw std::runtime_error(\"Unknown character: \" +\n                                   std::string(1, text[pos]));\n        }\n    }\n\n    return tokens;\n}\n\nint main() {\n    auto tokens = tokenize(\"x = 42 + y\");\n    for (const auto&amp; tok : tokens) {\n        std::cout &lt;&lt; \"(\" &lt;&lt; tok.type &lt;&lt; \", \" &lt;&lt; tok.value &lt;&lt; \") \";\n    }\n    std::cout &lt;&lt; std::endl;\n    // Output: (IDENT, x) (EQUALS, =) (NUMBER, 42) (PLUS, +) (IDENT, y)\n    return 0;\n}\n</code></pre> <ol> <li>Struct holds token type name and compiled std::regex pattern</li> <li>Pass string by const reference to avoid copying</li> <li>Initialize vector with brace-enclosed initializer list</li> <li>Raw string literals <code>R\"(...)\"</code> don't require escaping in C++11+</li> <li>SKIP tokens for whitespace recognition</li> <li>Track position as size_t (unsigned integer type)</li> <li>Create substring from current position to end</li> <li>Range-based for loop with const reference to avoid copying</li> <li>std::smatch stores regex match results</li> <li>Search for pattern match in remaining text</li> <li>Filter out whitespace tokens from results</li> <li>Advance position by length of matched text</li> <li>No pattern matched - throw runtime_error exception</li> </ol> <p>This produces a list of tokens, where each token is a tuple of <code>(TOKEN_TYPE, VALUE)</code>. The lexer has broken the input string into meaningful pieces that the parser can work with.</p>"},{"location":"building_blocks/how_parsers_work/#stage-2-parsing","title":"Stage 2: Parsing","text":"<p>The parser takes tokens and builds a structured representation\u2014usually a tree\u2014according to the grammar rules.</p>"},{"location":"building_blocks/how_parsers_work/#why-trees","title":"Why Trees?","text":"<p>A flat list of tokens doesn't capture the structure and relationships in code. Consider <code>2 + 3 * 4</code>:</p> <ul> <li>As tokens: <code>[NUM:2, PLUS, NUM:3, STAR, NUM:4]</code> - just a flat sequence</li> <li>As a tree: Shows that <code>3 * 4</code> happens first (nested deeper), then <code>2 +</code> the result</li> </ul> <p>Trees naturally represent:</p> <ol> <li>Operator precedence: Deeper operations execute first (<code>*</code> before <code>+</code>)</li> <li>Hierarchical structure: Nested expressions, function calls, code blocks</li> <li>Grammar rules: Each tree node represents a grammar rule being applied</li> <li>Evaluation order: Walk the tree to know what to compute when</li> </ol> <p>Without a tree, you'd need complex logic to figure out \"which operation happens first?\" The tree makes it obvious\u2014start at the leaves, work up to the root.</p> Connection to BNF and RTN <p>Remember BNF and RTN from earlier? They're grammar notations that describe valid syntax. The parser uses these rules to build the tree:</p> <ul> <li>Each BNF rule becomes a tree node: When the parser applies <code>&lt;expression&gt; ::= &lt;term&gt; \"+\" &lt;term&gt;</code>, it creates an expression node with two term children</li> <li>RTN paths trace tree construction: Following an RTN from start to end corresponds to building a subtree</li> <li>Recursion in grammar = Recursion in tree: Nested expressions in code become nested nodes in the tree</li> </ul> <p>The grammar is the blueprint; the tree is the structure built from that blueprint. The parser is the construction worker following the plans.</p>"},{"location":"building_blocks/how_parsers_work/#parse-trees-vs-abstract-syntax-trees","title":"Parse Trees vs Abstract Syntax Trees","text":"<p>Parse Tree (Concrete Syntax Tree): Shows every grammar rule applied.</p> <p>Abstract Syntax Tree (AST): Simplified tree focusing on meaning, not syntax.</p> <p>For <code>2 + 3 * 4</code>:</p> Concrete Syntax Tree<pre><code>         Expression\n              |\n    +---------+---------+\n    |         |         |\n  Term       '+'      Term\n    |                   |\n  Factor        +-------+-------+\n    |           |       |       |\n   '2'        Term     '*'   Factor\n               |\n            Factor              '4'\n               |\n              '3'\n</code></pre> Abstract Syntax Tree<pre><code>        +\n       / \\\n      2   *\n         / \\\n        3   4\n</code></pre> <p>The AST is what most compilers actually work with.</p> <p>Scheme: Where Parse Tree = AST</p> <p>In Scheme &amp; Parse Trees, you'll see a language where the written code is the AST. Because Scheme uses prefix notation with explicit parentheses <code>(+ 1 (* 2 3))</code>, there is no ambiguity, and the parse tree matches the code structure 1:1.</p> <p>Why ASTs Drop Punctuation</p> <p>Notice how the AST doesn't include parentheses, commas, or semicolons? That's intentional. Once you've parsed the code and built the tree structure, punctuation has served its purpose\u2014it told the parser how to group things.</p> <p>What gets dropped: - Parentheses <code>()</code> - the tree structure already shows grouping - Commas <code>,</code> - already represented as multiple children - Semicolons <code>;</code> - just statement separators, not meaningful after parsing - Keywords like <code>then</code>, <code>do</code> - the tree node type already captures the meaning</p> <p>What gets kept: - Operators <code>+</code>, <code>-</code>, <code>*</code> - needed to know which operation to perform - Literals <code>42</code>, <code>\"hello\"</code> - the actual values - Identifiers <code>x</code>, <code>foo</code> - variable and function names</p> <p>The AST keeps only what's needed for execution or compilation. This makes it smaller and easier to work with than the full parse tree.</p> SQL Execution Plans: A Related Concept <p>If you've worked with databases, you might recognize tree structures from SQL execution plans. They're related but different:</p> <p>Parse Tree/AST (what parsers build): - Represents the syntactic structure of the code - Shows what the query means grammatically - Created during parsing (before execution)</p> <p>Execution Plan (what query optimizers build): - Represents the execution strategy for running the query - Shows how to efficiently execute the query (which indexes, join order, etc.) - Created after parsing, during query optimization</p> <p>The full pipeline is: <code>SQL text \u2192 Lexer \u2192 Parser \u2192 AST \u2192 Query Optimizer \u2192 Execution Plan \u2192 Results</code></p> <p>When database administrators tune queries by examining execution plans, they're looking at a tree structure that comes after parsing\u2014it's the optimized plan for executing the already-parsed query. Both are trees showing hierarchical operations, but the AST captures syntax while the execution plan captures runtime strategy.</p>"},{"location":"building_blocks/how_parsers_work/#grammar-ambiguity","title":"Grammar Ambiguity","text":"<p>Some grammars are ambiguous\u2014they allow multiple valid parse trees for the same input. This is a problem because the program's meaning becomes unclear.</p>"},{"location":"building_blocks/how_parsers_work/#the-classic-example-dangling-else","title":"The Classic Example: Dangling Else","text":"<p>Consider this grammar for if-statements:</p> Ambiguous If-Statement Grammar<pre><code>&lt;statement&gt; ::= &lt;if-statement&gt; | &lt;other&gt;\n&lt;if-statement&gt; ::= \"if\" &lt;condition&gt; \"then\" &lt;statement&gt;\n                 | \"if\" &lt;condition&gt; \"then\" &lt;statement&gt; \"else\" &lt;statement&gt;\n</code></pre> <p>Now parse this code:</p> <pre><code>if a then if b then x else y\n</code></pre> <p>Two valid parse trees exist:</p> <p>Interpretation 1: The <code>else</code> belongs to the inner <code>if</code>: <pre><code>if a then (if b then x else y)\n</code></pre></p> <p>Interpretation 2: The <code>else</code> belongs to the outer <code>if</code>: <pre><code>if a then (if b then x) else y\n</code></pre></p> <p>Both are valid according to the grammar! This is the Dangling Else problem.</p>"},{"location":"building_blocks/how_parsers_work/#how-languages-solve-it","title":"How Languages Solve It","text":"<p>Most languages resolve this through precedence rules:</p> <ol> <li>Convention: The <code>else</code> matches the nearest unmatched <code>if</code> (Interpretation 1)</li> <li>Require explicit delimiters: Python uses indentation; C uses braces <code>{ }</code></li> <li>Require <code>end</code> keywords: Pascal and Ada make all blocks explicit</li> </ol>"},{"location":"building_blocks/how_parsers_work/#why-ambiguity-matters-for-parsing","title":"Why Ambiguity Matters for Parsing","text":"<ul> <li>Parsers must make choices: When faced with ambiguity, the parser picks one interpretation (usually via precedence rules)</li> <li>Different parsers might choose differently: Without explicit rules, two implementations could parse the same code differently</li> <li>Grammar design is crucial: Good language design avoids ambiguity through careful grammar construction</li> </ul> <p>Key insight: Ambiguity is a property of the grammar, not the parser. A well-designed grammar eliminates ambiguity before parsing begins.</p>"},{"location":"building_blocks/how_parsers_work/#parsing-strategies","title":"Parsing Strategies","text":"<p>Not all grammars are equally easy to parse, and different approaches have different trade-offs. Think of parsing strategies like different tools in a toolbox\u2014a hammer for some jobs, a screwdriver for others.</p>"},{"location":"building_blocks/how_parsers_work/#choosing-your-approach","title":"Choosing Your Approach","text":"<p>Why Different Strategies?</p> <p>Different parsing strategies exist because:</p> <ol> <li>Grammar constraints: Some grammars are ambiguous or have features (like left-recursion) that break certain parsing approaches</li> <li>Implementation complexity: Hand-written parsers need simplicity; generated parsers can be more complex</li> <li>Error handling: Some strategies give better error messages than others</li> <li>Performance: Different strategies have different speed and memory characteristics</li> <li>Parsing power: Some strategies can handle more complex grammars than others</li> </ol> <p>Which Strategy Should You Use?</p> Situation Recommended Strategy Why? Writing by hand Top-down (Recursive Descent) Easy to understand, maps directly to grammar, good error messages Using a parser generator Bottom-up (LR/LALR) More powerful, handles more grammars, tools do the hard work Simple expressions Top-down Quick to implement, sufficient for most expression grammars Complex language (C, Java) Bottom-up (via tool) Handles complex grammar features, proven at scale Educational purposes Top-down Easier to understand and trace execution <p>For most projects: start with recursive descent (top-down) because it's intuitive. Only reach for more powerful strategies when you hit limitations.</p>  Top-Down Parsing (LL) Bottom-Up Parsing (LR) <p>Strategy: Start with the goal (e.g., \"program\") and work down to terminals.</p> <p>Recursive Descent is the most intuitive top-down approach. Each grammar rule becomes a function:</p> <p>Given this grammar:</p> Expression Grammar<pre><code>&lt;expression&gt; ::= &lt;term&gt; { (\"+\" | \"-\") &lt;term&gt; }\n&lt;term&gt; ::= &lt;factor&gt; { (\"*\" | \"/\") &lt;factor&gt; }\n&lt;factor&gt; ::= NUMBER | \"(\" &lt;expression&gt; \")\"\n</code></pre> <p>Left Recursion: A Top-Down Parser Killer</p> <p>Top-down parsers cannot handle left-recursive grammars. A rule like this will cause infinite recursion:</p> <pre><code>&lt;expression&gt; ::= &lt;expression&gt; \"+\" &lt;term&gt;   # \u274c Left-recursive!\n</code></pre> <p>Why it breaks: When <code>parse_expression()</code> is called, the first thing it does is call <code>parse_expression()</code> again (to match <code>&lt;expression&gt;</code>), which calls <code>parse_expression()</code> again, forever. The parser never consumes a token!</p> <p>The fix: Rewrite left recursion as iteration (loops):</p> <pre><code># Instead of:\n&lt;expression&gt; ::= &lt;expression&gt; \"+\" &lt;term&gt;\n\n# Use:\n&lt;expression&gt; ::= &lt;term&gt; { \"+\" &lt;term&gt; }\n</code></pre> <p>The <code>{ }</code> notation means \"zero or more,\" which translates to a <code>while</code> loop in code. This is why our grammar above uses <code>{ ... }</code> - it avoids left recursion.</p> <p>Bottom-up parsers (LR) handle left recursion naturally, which is one reason they're more powerful.</p> <p>Here's a recursive descent parser implementation:</p>  Python - Parser JavaScript - Parser Go - Parser Rust - Parser Java - Parser C++ - Parser Recursive Descent Parser in Python<pre><code>class Parser:\n    def __init__(self, tokens):\n        self.tokens = tokens  # (1)!\n        self.pos = 0  # (2)!\n\n    def current_token(self):\n        if self.pos &lt; len(self.tokens):\n            return self.tokens[self.pos]\n        return None\n\n    def consume(self, expected_type=None):  # (3)!\n        token = self.current_token()\n        if expected_type and token[0] != expected_type:\n            raise SyntaxError(f\"Expected {expected_type}, got {token}\")\n        self.pos += 1  # (4)!\n        return token\n\n    def parse_expression(self):  # (5)!\n        \"\"\"expression = term { ('+' | '-') term }\"\"\"\n        left = self.parse_term()  # (6)!\n\n        while self.current_token() and self.current_token()[0] in ('PLUS', 'MINUS'):\n            op = self.consume()[1]\n            right = self.parse_term()\n            left = ('binop', op, left, right)  # (7)!\n\n        return left\n\n    def parse_term(self):  # (8)!\n        \"\"\"term = factor { ('*' | '/') factor }\"\"\"\n        left = self.parse_factor()\n\n        while self.current_token() and self.current_token()[0] in ('STAR', 'SLASH'):\n            op = self.consume()[1]\n            right = self.parse_factor()\n            left = ('binop', op, left, right)\n\n        return left\n\n    def parse_factor(self):  # (9)!\n        \"\"\"factor = NUMBER | '(' expression ')'\"\"\"\n        token = self.current_token()\n\n        if token[0] == 'NUMBER':\n            self.consume()\n            return ('number', int(token[1]))\n\n        elif token[0] == 'LPAREN':  # (10)!\n            self.consume('LPAREN')\n            expr = self.parse_expression()  # (11)!\n            self.consume('RPAREN')\n            return expr\n\n        else:\n            raise SyntaxError(f\"Unexpected token: {token}\")\n\n# Usage\ntokens = tokenize(\"2 + 3 * 4\")\nparser = Parser(tokens)\nast = parser.parse_expression()\nprint(ast)\n# Output: ('binop', '+', ('number', 2), ('binop', '*', ('number', 3), ('number', 4)))\n</code></pre> <ol> <li>Store the list of tokens from the lexer</li> <li>Track current position in the token list</li> <li>Consume one token and optionally validate its type</li> <li>Move to the next token after consuming</li> <li>Handles lowest precedence operators (+ and -)</li> <li>Start by parsing the higher-precedence term</li> <li>Build a binary operation node combining left and right operands</li> <li>Handles medium precedence operators (* and /)</li> <li>Handles highest precedence: numbers and parenthesized expressions</li> <li>Handle parenthesized sub-expressions</li> <li>Recursively parse the expression inside parentheses</li> </ol> Recursive Descent Parser in JavaScript<pre><code>class Parser {\n    constructor(tokens) {\n        this.tokens = tokens;  // (1)!\n        this.pos = 0;  // (2)!\n    }\n\n    currentToken() {\n        if (this.pos &lt; this.tokens.length) {\n            return this.tokens[this.pos];\n        }\n        return null;\n    }\n\n    consume(expectedType = null) {  // (3)!\n        const token = this.currentToken();\n        if (expectedType &amp;&amp; token[0] !== expectedType) {\n            throw new SyntaxError(`Expected ${expectedType}, got ${token}`);\n        }\n        this.pos++;  // (4)!\n        return token;\n    }\n\n    parseExpression() {  // (5)!\n        // expression = term { ('+' | '-') term }\n        let left = this.parseTerm();  // (6)!\n\n        while (this.currentToken() &amp;&amp;\n               ['PLUS', 'MINUS'].includes(this.currentToken()[0])) {\n            const op = this.consume()[1];\n            const right = this.parseTerm();\n            left = ['binop', op, left, right];  // (7)!\n        }\n\n        return left;\n    }\n\n    parseTerm() {  // (8)!\n        // term = factor { ('*' | '/') factor }\n        let left = this.parseFactor();\n\n        while (this.currentToken() &amp;&amp;\n               ['STAR', 'SLASH'].includes(this.currentToken()[0])) {\n            const op = this.consume()[1];\n            const right = this.parseFactor();\n            left = ['binop', op, left, right];\n        }\n\n        return left;\n    }\n\n    parseFactor() {  // (9)!\n        // factor = NUMBER | '(' expression ')'\n        const token = this.currentToken();\n\n        if (token[0] === 'NUMBER') {\n            this.consume();\n            return ['number', parseInt(token[1])];\n        }\n\n        if (token[0] === 'LPAREN') {  // (10)!\n            this.consume('LPAREN');\n            const expr = this.parseExpression();  // (11)!\n            this.consume('RPAREN');\n            return expr;\n        }\n\n        throw new SyntaxError(`Unexpected token: ${token}`);\n    }\n}\n\n// Usage\nconst tokens = tokenize(\"2 + 3 * 4\");\nconst parser = new Parser(tokens);\nconst ast = parser.parseExpression();\n    console.log(ast);\n    // Output: ['binop', '+', ['number', 2], ['binop', '*', ['number', 3], ['number', 4]]]\n</code></pre> <ol> <li>Store token array from lexer in instance variable</li> <li>Track current position as index into token array</li> <li>Default parameter <code>null</code> allows calling without expected type</li> <li>Increment position to move to next token</li> <li>Handles lowest precedence operators (+ and -)</li> <li>Start by parsing higher-precedence term</li> <li>Build binary operation array: [type, operator, left, right]</li> <li>Handles medium precedence operators (* and /)</li> <li>Handles highest precedence: numbers and parenthesized expressions</li> <li>Handle parenthesized sub-expressions for grouping</li> <li>Recursively parse expression inside parentheses</li> </ol> Recursive Descent Parser in Go<pre><code>package main\n\nimport \"fmt\"\n\ntype ASTNode interface{}\n\ntype Parser struct {\n    tokens []Token  // (1)!\n    pos    int  // (2)!\n}\n\nfunc NewParser(tokens []Token) *Parser {\n    return &amp;Parser{tokens: tokens, pos: 0}\n}\n\nfunc (p *Parser) currentToken() *Token {\n    if p.pos &lt; len(p.tokens) {\n        return &amp;p.tokens[p.pos]\n    }\n    return nil\n}\n\nfunc (p *Parser) consume(expectedType ...string) Token {  // (3)!\n    token := p.currentToken()\n    if token == nil {\n        panic(\"Unexpected end of tokens\")\n    }\n    if len(expectedType) &gt; 0 &amp;&amp; token.Type != expectedType[0] {\n        panic(fmt.Sprintf(\"Expected %s, got %s\", expectedType[0], token.Type))\n    }\n    p.pos++  // (4)!\n    return *token\n}\n\nfunc (p *Parser) parseExpression() ASTNode {  // (5)!\n    // expression = term { ('+' | '-') term }\n    left := p.parseTerm()  // (6)!\n\n    for p.currentToken() != nil &amp;&amp;\n        (p.currentToken().Type == \"PLUS\" || p.currentToken().Type == \"MINUS\") {\n        op := p.consume().Value\n        right := p.parseTerm()\n        left = []interface{}{\"binop\", op, left, right}  // (7)!\n    }\n\n    return left\n}\n\nfunc (p *Parser) parseTerm() ASTNode {  // (8)!\n    // term = factor { ('*' | '/') factor }\n    left := p.parseFactor()\n\n    for p.currentToken() != nil &amp;&amp;\n        (p.currentToken().Type == \"STAR\" || p.currentToken().Type == \"SLASH\") {\n        op := p.consume().Value\n        right := p.parseFactor()\n        left = []interface{}{\"binop\", op, left, right}\n    }\n\n    return left\n}\n\nfunc (p *Parser) parseFactor() ASTNode {  // (9)!\n    // factor = NUMBER | '(' expression ')'\n    token := p.currentToken()\n\n    if token.Type == \"NUMBER\" {\n        p.consume()\n        return []interface{}{\"number\", token.Value}\n    }\n\n    if token.Type == \"LPAREN\" {  // (10)!\n        p.consume(\"LPAREN\")\n        expr := p.parseExpression()  // (11)!\n        p.consume(\"RPAREN\")\n        return expr\n    }\n\n    panic(fmt.Sprintf(\"Unexpected token: %v\", token))\n}\n\nfunc main() {\n    tokens, _ := tokenize(\"2 + 3 * 4\")\n    parser := NewParser(tokens)\n    ast := parser.parseExpression()\n        fmt.Printf(\"%v\\n\", ast)\n        // Output: [binop + [number 2] [binop * [number 3] [number 4]]]\n    }\n</code></pre> <ol> <li>Store slice of tokens from lexer</li> <li>Track current position as integer index</li> <li>Variadic parameter <code>...string</code> allows optional expected type</li> <li>Increment position to advance to next token</li> <li>Handles lowest precedence operators (+ and -)</li> <li>Start with higher-precedence term</li> <li>Build slice representing binary operation node</li> <li>Handles medium precedence operators (* and /)</li> <li>Handles highest precedence: numbers and parentheses</li> <li>Handle parenthesized sub-expressions for grouping</li> <li>Recursive call parses expression inside parentheses</li> </ol> Recursive Descent Parser in Rust<pre><code>#[derive(Debug, Clone)]\nenum ASTNode {  // (1)!\n    Number(i32),\n    BinOp {\n        op: String,\n        left: Box&lt;ASTNode&gt;,  // (2)!\n        right: Box&lt;ASTNode&gt;,\n    },\n}\n\nstruct Parser {\n    tokens: Vec&lt;Token&gt;,  // (3)!\n    pos: usize,  // (4)!\n}\n\nimpl Parser {\n    fn new(tokens: Vec&lt;Token&gt;) -&gt; Self {\n        Parser { tokens, pos: 0 }\n    }\n\n    fn current_token(&amp;self) -&gt; Option&lt;&amp;Token&gt; {\n        self.tokens.get(self.pos)\n    }\n\n    fn consume(&amp;mut self, expected_type: Option&lt;&amp;str&gt;) -&gt; Result&lt;Token, String&gt; {  // (5)!\n        match self.current_token() {\n            None =&gt; Err(\"Unexpected end of tokens\".to_string()),\n            Some(token) =&gt; {\n                if let Some(exp) = expected_type {\n                    if &amp;token.token_type != exp {\n                        return Err(format!(\"Expected {}, got {}\", exp, token.token_type));\n                    }\n                }\n                self.pos += 1;  // (6)!\n                Ok(token.clone())\n            }\n        }\n    }\n\n    fn parse_expression(&amp;mut self) -&gt; Result&lt;ASTNode, String&gt; {  // (7)!\n        // expression = term { ('+' | '-') term }\n        let mut left = self.parse_term()?;  // (8)!\n\n        while let Some(token) = self.current_token() {\n            if token.token_type == \"PLUS\" || token.token_type == \"MINUS\" {\n                let op = self.consume(None)?.value;\n                let right = self.parse_term()?;\n                left = ASTNode::BinOp {  // (9)!\n                    op,\n                    left: Box::new(left),\n                    right: Box::new(right),\n                };\n            } else {\n                break;\n            }\n        }\n\n        Ok(left)\n    }\n\n    fn parse_term(&amp;mut self) -&gt; Result&lt;ASTNode, String&gt; {  // (10)!\n        // term = factor { ('*' | '/') factor }\n        let mut left = self.parse_factor()?;\n\n        while let Some(token) = self.current_token() {\n            if token.token_type == \"STAR\" || token.token_type == \"SLASH\" {\n                let op = self.consume(None)?.value;\n                let right = self.parse_factor()?;\n                left = ASTNode::BinOp {\n                    op,\n                    left: Box::new(left),\n                    right: Box::new(right),\n                };\n            } else {\n                break;\n            }\n        }\n\n        Ok(left)\n    }\n\n    fn parse_factor(&amp;mut self) -&gt; Result&lt;ASTNode, String&gt; {  // (11)!\n        // factor = NUMBER | '(' expression ')'\n        match self.current_token() {\n            None =&gt; Err(\"Unexpected end of tokens\".to_string()),\n            Some(token) =&gt; {\n                if token.token_type == \"NUMBER\" {\n                    let value = token.value.parse::&lt;i32&gt;().unwrap();\n                    self.consume(None)?;\n                    Ok(ASTNode::Number(value))\n                } else if token.token_type == \"LPAREN\" {  // (12)!\n                    self.consume(Some(\"LPAREN\"))?;\n                    let expr = self.parse_expression()?;  // (13)!\n                    self.consume(Some(\"RPAREN\"))?;\n                    Ok(expr)\n                } else {\n                    Err(format!(\"Unexpected token: {:?}\", token))\n                }\n            }\n        }\n    }\n}\n\nfn main() {\n    let tokens = tokenize(\"2 + 3 * 4\").unwrap();\n    let mut parser = Parser::new(tokens);\n    let ast = parser.parse_expression().unwrap();\n        println!(\"{:?}\", ast);\n        // Output: BinOp { op: \"+\", left: Number(2), right: BinOp { op: \"*\", left: Number(3), right: Number(4) } }\n    }\n</code></pre> <ol> <li>Enum defines AST node types (Number or Binary Operation)</li> <li>Box heap-allocates nodes to allow recursive tree structure</li> <li>Store vector of tokens from lexer</li> <li>Track current position as usize (unsigned integer)</li> <li>Returns Result type for idiomatic Rust error handling</li> <li>Increment position to move to next token</li> <li>Handles lowest precedence operators (+ and -)</li> <li><code>?</code> operator propagates errors up the call stack</li> <li>Create BinOp variant with boxed left/right children</li> <li>Handles medium precedence operators (* and /)</li> <li>Handles highest precedence: numbers and parentheses</li> <li>Handle parenthesized sub-expressions for grouping</li> <li>Recursive call parses expression inside parentheses</li> </ol> Recursive Descent Parser in Java<pre><code>import java.util.*;\n\ninterface ASTNode {}\n\nclass NumberNode implements ASTNode {\n    int value;\n    NumberNode(int value) { this.value = value; }\n    @Override\n    public String toString() { return \"Number(\" + value + \")\"; }\n}\n\nclass BinOpNode implements ASTNode {\n    String op;\n    ASTNode left, right;\n    BinOpNode(String op, ASTNode left, ASTNode right) {\n        this.op = op;\n        this.left = left;\n        this.right = right;\n    }\n    @Override\n    public String toString() {\n        return \"BinOp(\" + op + \", \" + left + \", \" + right + \")\";\n    }\n}\n\nclass Parser {\n    List&lt;Token&gt; tokens;  // (1)!\n    int pos;  // (2)!\n\n    Parser(List&lt;Token&gt; tokens) {\n        this.tokens = tokens;\n        this.pos = 0;\n    }\n\n    Token currentToken() {\n        if (pos &lt; tokens.size()) {\n            return tokens.get(pos);\n        }\n        return null;\n    }\n\n    Token consume(String expectedType) {  // (3)!\n        Token token = currentToken();\n        if (token == null) {\n            throw new RuntimeException(\"Unexpected end of tokens\");\n        }\n        if (expectedType != null &amp;&amp; !token.type.equals(expectedType)) {\n            throw new RuntimeException(\"Expected \" + expectedType + \", got \" + token.type);\n        }\n        pos++;  // (4)!\n        return token;\n    }\n\n    Token consume() {\n        return consume(null);\n    }\n\n    ASTNode parseExpression() {  // (5)!\n        // expression = term { ('+' | '-') term }\n        ASTNode left = parseTerm();  // (6)!\n\n        while (currentToken() != null &amp;&amp;\n               (currentToken().type.equals(\"PLUS\") || currentToken().type.equals(\"MINUS\"))) {\n            String op = consume().value;\n            ASTNode right = parseTerm();\n            left = new BinOpNode(op, left, right);  // (7)!\n        }\n\n        return left;\n    }\n\n    ASTNode parseTerm() {  // (8)!\n        // term = factor { ('*' | '/') factor }\n        ASTNode left = parseFactor();\n\n        while (currentToken() != null &amp;&amp;\n               (currentToken().type.equals(\"STAR\") || currentToken().type.equals(\"SLASH\"))) {\n            String op = consume().value;\n            ASTNode right = parseFactor();\n            left = new BinOpNode(op, left, right);\n        }\n\n        return left;\n    }\n\n    ASTNode parseFactor() {  // (9)!\n        // factor = NUMBER | '(' expression ')'\n        Token token = currentToken();\n\n        if (token.type.equals(\"NUMBER\")) {\n            consume();\n            return new NumberNode(Integer.parseInt(token.value));\n        }\n\n        if (token.type.equals(\"LPAREN\")) {  // (10)!\n            consume(\"LPAREN\");\n            ASTNode expr = parseExpression();  // (11)!\n            consume(\"RPAREN\");\n            return expr;\n        }\n\n        throw new RuntimeException(\"Unexpected token: \" + token);\n    }\n\n    public static void main(String[] args) {\n        List&lt;Token&gt; tokens = Lexer.tokenize(\"2 + 3 * 4\");\n        Parser parser = new Parser(tokens);\n        ASTNode ast = parser.parseExpression();\n            System.out.println(ast);\n            // Output: BinOp(+, Number(2), BinOp(*, Number(3), Number(4)))\n        }\n    }\n</code></pre> <ol> <li>Store List of tokens from lexer</li> <li>Track current position as integer index</li> <li>Method overloading allows optional expectedType parameter</li> <li>Increment position to move to next token</li> <li>Handles lowest precedence operators (+ and -)</li> <li>Start with higher-precedence term</li> <li>Create new BinOpNode object for binary operation</li> <li>Handles medium precedence operators (* and /)</li> <li>Handles highest precedence: numbers and parentheses</li> <li>Handle parenthesized sub-expressions for grouping</li> <li>Recursive call parses expression inside parentheses</li> </ol> Recursive Descent Parser in C++<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;stdexcept&gt;\n\nstruct ASTNode {\n    virtual ~ASTNode() = default;\n    virtual std::string toString() const = 0;\n};\n\nstruct NumberNode : ASTNode {\n    int value;\n    NumberNode(int v) : value(v) {}\n    std::string toString() const override {\n        return \"Number(\" + std::to_string(value) + \")\";\n    }\n};\n\nstruct BinOpNode : ASTNode {\n    std::string op;\n    std::unique_ptr&lt;ASTNode&gt; left;\n    std::unique_ptr&lt;ASTNode&gt; right;\n\n    BinOpNode(std::string o, std::unique_ptr&lt;ASTNode&gt; l, std::unique_ptr&lt;ASTNode&gt; r)\n        : op(o), left(std::move(l)), right(std::move(r)) {}\n\n    std::string toString() const override {\n        return \"BinOp(\" + op + \", \" + left-&gt;toString() + \", \" + right-&gt;toString() + \")\";\n    }\n};\n\nclass Parser {\n    std::vector&lt;Token&gt; tokens;  // (1)!\n    size_t pos;  // (2)!\n\npublic:\n    Parser(const std::vector&lt;Token&gt;&amp; toks) : tokens(toks), pos(0) {}\n\n    const Token* currentToken() {\n        if (pos &lt; tokens.size()) {\n            return &amp;tokens[pos];\n        }\n        return nullptr;\n    }\n\n    Token consume(const std::string&amp; expectedType = \"\") {  // (3)!\n        auto token = currentToken();\n        if (!token) {\n            throw std::runtime_error(\"Unexpected end of tokens\");\n        }\n        if (!expectedType.empty() &amp;&amp; token-&gt;type != expectedType) {\n            throw std::runtime_error(\"Expected \" + expectedType + \", got \" + token-&gt;type);\n        }\n        pos++;  // (4)!\n        return *token;\n    }\n\n    std::unique_ptr&lt;ASTNode&gt; parseExpression() {  // (5)!\n        // expression = term { ('+' | '-') term }\n        auto left = parseTerm();  // (6)!\n\n        while (currentToken() &amp;&amp;\n               (currentToken()-&gt;type == \"PLUS\" || currentToken()-&gt;type == \"MINUS\")) {\n            std::string op = consume().value;\n            auto right = parseTerm();\n            left = std::make_unique&lt;BinOpNode&gt;(op, std::move(left), std::move(right));  // (7)!\n        }\n\n        return left;\n    }\n\n    std::unique_ptr&lt;ASTNode&gt; parseTerm() {  // (8)!\n        // term = factor { ('*' | '/') factor }\n        auto left = parseFactor();\n\n        while (currentToken() &amp;&amp;\n               (currentToken()-&gt;type == \"STAR\" || currentToken()-&gt;type == \"SLASH\")) {\n            std::string op = consume().value;\n            auto right = parseFactor();\n            left = std::make_unique&lt;BinOpNode&gt;(op, std::move(left), std::move(right));\n        }\n\n        return left;\n    }\n\n    std::unique_ptr&lt;ASTNode&gt; parseFactor() {  // (9)!\n        // factor = NUMBER | '(' expression ')'\n        auto token = currentToken();\n\n        if (token-&gt;type == \"NUMBER\") {\n            consume();\n            return std::make_unique&lt;NumberNode&gt;(std::stoi(token-&gt;value));\n        }\n\n        if (token-&gt;type == \"LPAREN\") {  // (10)!\n            consume(\"LPAREN\");\n            auto expr = parseExpression();  // (11)!\n            consume(\"RPAREN\");\n            return expr;\n        }\n\n        throw std::runtime_error(\"Unexpected token: \" + token-&gt;type);\n    }\n};\n\nint main() {\n    auto tokens = tokenize(\"2 + 3 * 4\");\n    Parser parser(tokens);\n    auto ast = parser.parseExpression();\n        std::cout &lt;&lt; ast-&gt;toString() &lt;&lt; std::endl;\n        // Output: BinOp(+, Number(2), BinOp(*, Number(3), Number(4)))\n        return 0;\n    }\n</code></pre> <ol> <li>Store vector of tokens from lexer</li> <li>Track position as size_t (unsigned integer type)</li> <li>Default parameter allows calling without expectedType</li> <li>Increment position to advance to next token</li> <li>Returns unique_ptr for automatic memory management</li> <li>Start with higher-precedence term</li> <li><code>std::move</code> transfers ownership to new BinOpNode</li> <li>Handles medium precedence operators (* and /)</li> <li>Handles highest precedence: numbers and parentheses</li> <li>Handle parenthesized sub-expressions for grouping</li> <li>Recursive call parses expression inside parentheses</li> </ol> <p>This is a tree structure represented as nested tuples\u2014our AST! Each tuple is a node:</p> <ul> <li><code>('binop', '+', left, right)</code> = a binary operation node with operator <code>+</code></li> <li><code>('number', 2)</code> = a leaf node containing the value <code>2</code></li> <li>The nesting shows the tree structure: <code>2 + (3 * 4)</code></li> </ul> <p>Compare this to the lexer's flat list of tokens\u2014the parser has transformed that flat list into a hierarchical tree that captures the meaning and precedence.</p> Notice the Structure <p>The parser functions mirror the grammar exactly:</p> <ul> <li><code>parse_expression</code> handles <code>+</code> and <code>-</code></li> <li><code>parse_term</code> handles <code>*</code> and <code>/</code></li> <li><code>parse_factor</code> handles numbers and parentheses</li> </ul> <p>This is why BNF translates so directly into code!</p> Recursion and the Call Stack <p>Notice how <code>parse_factor</code> can call <code>parse_expression</code>, which calls <code>parse_term</code>, which calls <code>parse_factor</code> again? This mutual recursion works because each function call is managed by the function call stack.</p> <p>When parsing <code>(2 + 3)</code>, the call stack looks like: <pre><code>parse_factor()      \u2190 handles the parentheses\n  \u2192 parse_expression() \u2190 handles the + inside\n    \u2192 parse_term()\n      \u2192 parse_factor() \u2190 handles 2\n</code></pre></p> <p>When the innermost call completes, it returns to the previous function\u2014classic LIFO behavior. Without the call stack, recursive parsing would be impossible.</p> <p>How It Handles Operator Precedence:</p> <p>Our grammar naturally handles precedence! Here's why:</p> <ol> <li><code>expression</code> handles <code>+</code> and <code>-</code></li> <li><code>term</code> handles <code>*</code> and <code>/</code></li> <li><code>factor</code> handles numbers and parentheses</li> </ol> <p>Since <code>term</code> is nested inside <code>expression</code>, multiplication happens \"deeper\" in the tree\u2014which means it's evaluated first.</p> <p>For <code>2 + 3 * 4</code>:</p> <pre><code>     +          (evaluated last)\n    / \\\n   2   *        (evaluated first)\n      / \\\n     3   4\n</code></pre> <p>Result: 2 + (3 * 4) = 14 \u2713</p> <p>Adding More Precedence Levels:</p> <p>Want to add exponentiation (<code>^</code>) with highest precedence?</p> Grammar with Exponentiation<pre><code>&lt;expression&gt; ::= &lt;term&gt; { (\"+\" | \"-\") &lt;term&gt; }\n&lt;term&gt; ::= &lt;power&gt; { (\"*\" | \"/\") &lt;power&gt; }\n&lt;power&gt; ::= &lt;factor&gt; [ \"^\" &lt;power&gt; ]\n&lt;factor&gt; ::= NUMBER | \"(\" &lt;expression&gt; \")\"\n</code></pre> <p>Notice <code>&lt;power&gt;</code> calls itself on the right side\u2014this makes <code>^</code> right-associative: \\(2^{3^4} = 2^{(3^4)}\\).</p> <p>Strategy: Start with tokens and combine them into larger structures, building the parse tree from the leaves up to the root.</p> <p>How it works:</p> <ul> <li>Begin with individual tokens</li> <li>Recognize patterns that match the right-hand side of grammar rules</li> <li>\"Reduce\" those patterns to non-terminals</li> <li>Continue until reaching the start symbol</li> </ul> <p>Advantages:</p> <ul> <li>More powerful than top-down (handles more grammars)</li> <li>Naturally handles left-recursive grammars</li> <li>Can detect syntax errors earlier</li> </ul> <p>Disadvantages:</p> <ul> <li>More complex to implement by hand</li> <li>Harder to understand and debug</li> <li>Error messages can be less intuitive</li> </ul> <p>In practice: Bottom-up parsers are typically generated by tools like YACC and GNU Bison rather than written by hand. These tools take a grammar specification and automatically generate efficient parser code.</p>"},{"location":"building_blocks/how_parsers_work/#understanding-ll-and-lr","title":"Understanding LL and LR","text":"<p>Now that we've seen both approaches, let's compare them:</p> Type Reads Builds Tree Used By LL(k) Left-to-right Leftmost derivation (top-down) Recursive descent, ANTLR LR(k) Left-to-right Rightmost derivation (bottom-up) YACC, GNU Bison <p>What \"Leftmost\" and \"Rightmost\" Derivation Mean:</p> <p>These terms describe the order in which the parser builds the parse tree:</p> <p>Leftmost Derivation (LL - Top-Down):</p> <ul> <li>Start with the goal (e.g., <code>&lt;expression&gt;</code>)</li> <li>Expand grammar rules from left to right, top to bottom</li> <li>Like reading: start with the big picture, fill in details left-to-right</li> </ul> <pre><code>Example: 2 + 3\n&lt;expression&gt;\n  \u2192 &lt;term&gt; + &lt;term&gt;           (expand expression)\n  \u2192 &lt;number&gt; + &lt;term&gt;          (expand leftmost term first)\n  \u2192 2 + &lt;term&gt;                 (substitute 2)\n  \u2192 2 + &lt;number&gt;               (expand remaining term)\n  \u2192 2 + 3                      (substitute 3)\n</code></pre> <p>Rightmost Derivation (LR - Bottom-Up):</p> <ul> <li>Start with the tokens (e.g., <code>2</code>, <code>+</code>, <code>3</code>)</li> <li>Combine them into larger structures, working right-to-left when choosing what to reduce</li> <li>Like building with blocks: start with pieces, assemble upward</li> </ul> <pre><code>Example: 2 + 3\n2 + 3\n  \u2192 &lt;number&gt; + 3               (reduce rightmost number first)\n  \u2192 &lt;number&gt; + &lt;number&gt;        (reduce left number)\n  \u2192 &lt;term&gt; + &lt;term&gt;            (reduce to terms)\n  \u2192 &lt;expression&gt;               (reduce to expression)\n</code></pre> <p>For practical purposes: LL is top-down (goal \u2192 tokens), LR is bottom-up (tokens \u2192 goal). The \"leftmost/rightmost\" distinction matters for formal theory but the key difference is the direction.</p>"},{"location":"building_blocks/how_parsers_work/#understanding-lookahead-the-k-parameter","title":"Understanding Lookahead: The \"(k)\" Parameter","text":"<p>The \"(k)\" means how many tokens ahead the parser peeks to decide which grammar rule to apply.</p> <p>LL(1) - One Token Lookahead:</p> <p>When parsing, you often need to decide between alternatives. With LL(1), you look at the next token to decide:</p> <pre><code>        ```python title=\"LL(1) Lookahead Example\" linenums=\"1\"\n# Grammar rule with alternatives:\n# &lt;factor&gt; ::= NUMBER | \"(\" &lt;expression&gt; \")\"\n\ndef parse_factor(self):\n    token = self.current_token()  # Look at next token\n\n    if token[0] == 'NUMBER':      # Lookahead says: it's a number\n        return self.parse_number()\n    elif token[0] == 'LPAREN':    # Lookahead says: it's a parenthesized expr\n        return self.parse_paren_expr()\n        ```\n</code></pre> <p>One token is enough to decide which path to take.</p> <p>When You Need More Lookahead:</p> <p>Some grammars need LL(2) or LL(3):</p> <pre><code># Ambiguous with LL(1):\n&lt;statement&gt; ::= \"if\" &lt;expr&gt; \"then\" &lt;stmt&gt;\n              | \"if\" &lt;expr&gt; \"then\" &lt;stmt&gt; \"else\" &lt;stmt&gt;\n</code></pre> <p>After seeing <code>if</code>, both rules start the same way. You might need to look ahead 3-4 tokens to distinguish them.</p> <p>Why Lookahead Matters:</p> <ul> <li>LL(1) is simplest and most efficient (what recursive descent typically uses)</li> <li>LL(k) for k&gt;1 requires more complex logic</li> <li>LR(1) is more powerful than LL(1) - can handle more grammars with just 1 token lookahead</li> <li>More lookahead = more memory and complexity</li> </ul> <p>Most hand-written parsers use LL(1) because it's simple. Parser generators can handle larger k values automatically.</p>"},{"location":"building_blocks/how_parsers_work/#working-with-parse-trees","title":"Working with Parse Trees","text":"<p>Once you have a parse tree or AST, you need to do something with it\u2014evaluate it, compile it, or analyze it. This section covers common operations.</p>"},{"location":"building_blocks/how_parsers_work/#evaluating-the-ast","title":"Evaluating the AST","text":"<p>Once you have an AST, you can walk it to compute results:</p>  Python - Evaluator JavaScript - Evaluator Go - Evaluator Rust - Evaluator Java - Evaluator C++ - Evaluator <pre><code>    ```python title=\"AST Evaluator in Python\" linenums=\"1\"\ndef evaluate(node):  # (1)!\n    if node[0] == 'number':  # (2)!\n        return node[1]\n\n    elif node[0] == 'binop':  # (3)!\n        op, left, right = node[1], node[2], node[3]  # (4)!\n        left_val = evaluate(left)  # (5)!\n        right_val = evaluate(right)\n\n        if op == '+': return left_val + right_val  # (6)!\n        if op == '-': return left_val - right_val\n        if op == '*': return left_val * right_val\n        if op == '/': return left_val / right_val\n\n    raise ValueError(f\"Unknown node type: {node[0]}\")\n\n# Using our earlier AST\nast = ('binop', '+', ('number', 2), ('binop', '*', ('number', 3), ('number', 4)))\nprint(evaluate(ast))  # 14\n    ```\n</code></pre> <ol> <li>Recursively evaluate an AST node and return its computed value</li> <li>Base case: if it's a number node, return its value</li> <li>If it's a binary operation, evaluate both operands and apply the operator</li> <li>Unpack the operator and operands from the tuple</li> <li>Recursively evaluate left and right subtrees first</li> <li>Apply the operator to the evaluated operands</li> </ol> AST Evaluator in JavaScript<pre><code>function evaluate(node) {\n    if (node[0] === 'number') {\n        return node[1];\n    }\n\n    if (node[0] === 'binop') {\n        const [, op, left, right] = node;\n        const leftVal = evaluate(left);\n        const rightVal = evaluate(right);\n\n        if (op === '+') return leftVal + rightVal;\n        if (op === '-') return leftVal - rightVal;\n        if (op === '*') return leftVal * rightVal;\n        if (op === '/') return leftVal / rightVal;\n    }\n\n    throw new Error(`Unknown node type: ${node[0]}`);\n}\n\n// Using our earlier AST\nconst ast = ['binop', '+', ['number', 2], ['binop', '*', ['number', 3], ['number', 4]]];\nconsole.log(evaluate(ast));  // 14\n</code></pre> AST Evaluator in Go<pre><code>func evaluate(node ASTNode) float64 {\n    switch n := node.(type) {\n    case []interface{}:\n        nodeType := n[0].(string)\n\n        if nodeType == \"number\" {\n            switch v := n[1].(type) {\n            case int:\n                return float64(v)\n            case float64:\n                return v\n            }\n        }\n\n        if nodeType == \"binop\" {\n            op := n[1].(string)\n            left := evaluate(n[2])\n            right := evaluate(n[3])\n\n            switch op {\n            case \"+\": return left + right\n            case \"-\": return left - right\n            case \"*\": return left * right\n            case \"/\": return left / right\n            }\n        }\n    }\n\n    panic(fmt.Sprintf(\"Unknown node type: %v\", node))\n}\n\n// Using our earlier AST\nast := []interface{}{\"binop\", \"+\", []interface{}{\"number\", 2},\n                    []interface{}{\"binop\", \"*\", []interface{}{\"number\", 3},\n                    []interface{}{\"number\", 4}}}\nfmt.Println(evaluate(ast))  // 14\n</code></pre> AST Evaluator in Rust<pre><code>fn evaluate(node: &amp;ASTNode) -&gt; Result&lt;i32, String&gt; {\n    match node {\n        ASTNode::Number(n) =&gt; Ok(*n),\n\n        ASTNode::BinOp { op, left, right } =&gt; {\n            let left_val = evaluate(left)?;\n            let right_val = evaluate(right)?;\n\n            match op.as_str() {\n                \"+\" =&gt; Ok(left_val + right_val),\n                \"-\" =&gt; Ok(left_val - right_val),\n                \"*\" =&gt; Ok(left_val * right_val),\n                \"/\" =&gt; Ok(left_val / right_val),\n                _ =&gt; Err(format!(\"Unknown operator: {}\", op)),\n            }\n        }\n    }\n}\n\n// Using our earlier AST\nlet ast = ASTNode::BinOp {\n    op: \"+\".to_string(),\n    left: Box::new(ASTNode::Number(2)),\n    right: Box::new(ASTNode::BinOp {\n        op: \"*\".to_string(),\n        left: Box::new(ASTNode::Number(3)),\n        right: Box::new(ASTNode::Number(4)),\n    }),\n};\nprintln!(\"{}\", evaluate(&amp;ast).unwrap());  // 14\n</code></pre> AST Evaluator in Java<pre><code>public static int evaluate(ASTNode node) {\n    if (node instanceof NumberNode) {\n        return ((NumberNode) node).value;\n    }\n\n    if (node instanceof BinOpNode) {\n        BinOpNode binOp = (BinOpNode) node;\n        int leftVal = evaluate(binOp.left);\n        int rightVal = evaluate(binOp.right);\n\n        switch (binOp.op) {\n            case \"+\": return leftVal + rightVal;\n            case \"-\": return leftVal - rightVal;\n            case \"*\": return leftVal * rightVal;\n            case \"/\": return leftVal / rightVal;\n        }\n    }\n\n    throw new RuntimeException(\"Unknown node type: \" + node.getClass());\n}\n\n// Using our earlier AST\nASTNode ast = new BinOpNode(\"+\",\n    new NumberNode(2),\n    new BinOpNode(\"*\", new NumberNode(3), new NumberNode(4))\n);\nSystem.out.println(evaluate(ast));  // 14\n</code></pre> AST Evaluator in C++<pre><code>int evaluate(const ASTNode* node) {\n    if (auto num = dynamic_cast&lt;const NumberNode*&gt;(node)) {\n        return num-&gt;value;\n    }\n\n    if (auto binOp = dynamic_cast&lt;const BinOpNode*&gt;(node)) {\n        int leftVal = evaluate(binOp-&gt;left.get());\n        int rightVal = evaluate(binOp-&gt;right.get());\n\n        if (binOp-&gt;op == \"+\") return leftVal + rightVal;\n        if (binOp-&gt;op == \"-\") return leftVal - rightVal;\n        if (binOp-&gt;op == \"*\") return leftVal * rightVal;\n        if (binOp-&gt;op == \"/\") return leftVal / rightVal;\n    }\n\n    throw std::runtime_error(\"Unknown node type\");\n}\n\n// Using our earlier AST\nauto ast = std::make_unique&lt;BinOpNode&gt;(\"+\",\n    std::make_unique&lt;NumberNode&gt;(2),\n    std::make_unique&lt;BinOpNode&gt;(\"*\",\n        std::make_unique&lt;NumberNode&gt;(3),\n        std::make_unique&lt;NumberNode&gt;(4)\n    )\n);\nstd::cout &lt;&lt; evaluate(ast.get()) &lt;&lt; std::endl;  // 14\n</code></pre> <p>This tree-walking interpreter is the simplest approach. Real interpreters might:</p> <ul> <li>Compile the AST to bytecode</li> <li>Optimize the tree before execution</li> <li>Generate machine code</li> </ul>"},{"location":"building_blocks/how_parsers_work/#error-handling","title":"Error Handling","text":"<p>Good parsers give helpful error messages:</p> <pre><code>        ```python title=\"Error Handling in Parser\" linenums=\"1\"\ndef consume(self, expected_type):\n    token = self.current_token()\n    if token is None:  # (1)!\n        raise SyntaxError(f\"Unexpected end of input, expected {expected_type}\")\n    if token[0] != expected_type:  # (2)!\n        raise SyntaxError(\n            f\"Line {self.line}, column {self.column}: \"  # (3)!\n            f\"Expected {expected_type}, got {token[0]} ('{token[1]}')\"\n        )\n    self.pos += 1\n    return token\n        ```\n</code></pre> <ol> <li>Check if we've run out of tokens unexpectedly</li> <li>Validate that the token type matches what we expected</li> <li>Provide location information (line and column) for better error messages</li> </ol> <p>More sophisticated parsers can:</p> <ul> <li>Recover from errors and continue parsing</li> <li>Suggest corrections (\"Did you mean...?\"')</li> <li>Highlight the exact location of the problem</li> </ul>"},{"location":"building_blocks/how_parsers_work/#parser-generators","title":"Parser Generators","text":"<p>Writing parsers by hand is educational, but for real projects, consider parser generators:</p> Tool Language Grammar Style ANTLR Java, Python, etc. EBNF-like PLY Python YACC-like Lark Python EBNF Peggy (formerly PEG.js) JavaScript PEG GNU Bison C/C++ YACC <p>You write the grammar, the tool generates the parser code. \u2728 Laziness is a virtue in programming.</p> <p>Example with Lark (Python):</p> <pre><code>        ```python title=\"Parser Generator with Lark\" linenums=\"1\"\nfrom lark import Lark\n\ngrammar = \"\"\"  # (1)!\n    start: expr  # (2)!\n    expr: term ((\"|\"|\"-\") term)*  # (3)!\n    term: factor ((\"*\"|\"/\") factor)*  # (4)!\n    factor: NUMBER | \"(\" expr \")\"  # (5)!\n    NUMBER: /\\d+/  # (6)!\n    %ignore \" \"  # (7)!\n\"\"\"\n\nparser = Lark(grammar)  # (8)!\ntree = parser.parse(\"2 + 3 * 4\")\nprint(tree.pretty())\n        ```\n</code></pre> <ol> <li>Define grammar using EBNF-like syntax as a multi-line string</li> <li>Entry point of the grammar - must start with an expression</li> <li>Expression handles lowest precedence: addition and subtraction</li> <li>Term handles higher precedence: multiplication and division</li> <li>Factor handles highest precedence: numbers and parenthesized expressions</li> <li>Define what a NUMBER token looks like using regex</li> <li>Ignore whitespace in the input</li> <li>Create parser from grammar - Lark generates all parsing code automatically</li> </ol>"},{"location":"building_blocks/how_parsers_work/#real-world-parsing","title":"Real-World Parsing","text":"JSON Parser HTML Parser Programming Language Parsers <p>JSON is simple enough to parse by hand:</p> <pre><code>value   = object | array | string | number | \"true\" | \"false\" | \"null\"\nobject  = \"{\" [ pair { \",\" pair } ] \"}\"\npair    = string \":\" value\narray   = \"[\" [ value { \",\" value } ] \"]\"\n</code></pre> <p>Most languages have built-in JSON parsers because it's so common. The grammar is regular enough that a hand-written recursive descent parser works well.</p> <p>HTML is messy\u2014browsers handle malformed HTML gracefully. Real HTML parsers use complex error recovery:</p> Malformed HTML Example<pre><code>&lt;p&gt;This is &lt;b&gt;bold and &lt;i&gt;italic&lt;/b&gt; text&lt;/i&gt;\n</code></pre> <p>Technically invalid, but browsers render it anyway! The web is wild.</p> <p>Why HTML parsing is hard:</p> <ul> <li>Browsers must handle broken HTML (unclosed tags, misnested elements)</li> <li>Contextual parsing rules (what's valid inside <code>&lt;script&gt;</code> differs from <code>&lt;div&gt;</code>)</li> <li>Historical quirks mode for backward compatibility</li> </ul> <p>Modern language parsers are sophisticated:</p> <p>Error recovery \u2014 IDE features like syntax highlighting and autocomplete work even with incomplete/invalid code</p> <p>Incremental parsing \u2014 Fast re-parsing on edits by only updating changed parts of the tree</p> <p>Loose parsing modes \u2014 Handle incomplete code during typing for real-time feedback</p>"},{"location":"building_blocks/how_parsers_work/#practice-problems","title":"Practice Problems","text":"Challenge 1: Add Unary Minus <p>Modify the expression grammar and parser to handle unary minus:</p> <ul> <li><code>-5</code></li> <li><code>2 + -3</code></li> <li><code>-(-4)</code></li> </ul> <p>Where does the new rule go in the precedence hierarchy?</p> Challenge 2: Parse Variable Assignments <p>Extend the grammar to handle:</p> <pre><code>x = 10\ny = x + 5\n</code></pre> <p>You'll need to track variable names and store their values.</p> Challenge 3: Error Messages <p>Improve the parser to give line and column numbers in error messages. What information do you need to track during lexing?</p>"},{"location":"building_blocks/how_parsers_work/#key-takeaways","title":"Key Takeaways","text":"Concept What It Does Lexer Breaks text into tokens Parser Builds tree from tokens Token Meaningful chunk (keyword, number, operator) AST Tree representing program structure Recursive Descent Each grammar rule = one function Precedence Handled by grammar structure (nesting depth)"},{"location":"building_blocks/how_parsers_work/#further-reading","title":"Further Reading","text":"<ul> <li>Binary Trees &amp; Representation \u2014 Tree structures and hierarchical data</li> <li>Recursive Transition Networks \u2014 Visual grammars</li> <li>Backus-Naur Form \u2014 Grammar notation</li> <li>Finite State Machines \u2014 Foundation for lexers</li> <li>Crafting Interpreters by Robert Nystrom \u2014 Free online book, excellent deep dive</li> </ul> <p>Parsing bridges the gap between human-readable text and computer-manipulable structure. It's where theory meets practice\u2014where BNF rules become working code. Once you understand parsing, you can build your own languages, transform code, and peek behind the curtain of every compiler and interpreter you use. That's real power. \ud83d\udd27</p>"},{"location":"building_blocks/how_parsers_work/#video-summary","title":"Video Summary","text":""},{"location":"building_blocks/recursive_transition_networks/","title":"Recursive Transition Networks","text":""},{"location":"building_blocks/recursive_transition_networks/#description-recursive-transition-networks-rtns-the-visual-way-to-describe-complex-nested-grammars","title":"description: Recursive Transition Networks (RTNs): The visual way to describe complex, nested grammars.","text":""},{"location":"building_blocks/recursive_transition_networks/#recursive-transition-networks-rtns","title":"Recursive Transition Networks (RTNs)","text":"<p>When you write <code>x = 3 + 4 * 2</code> in any programming language, the compiler knows\u2014without ambiguity\u2014that this means <code>3 + (4 * 2)</code>, not <code>(3 + 4) * 2</code>. When you type \"The cat sat on the mat,\" a grammar checker can instantly tell it's valid English, while \"Cat the mat on sat the\" is nonsense. How do these systems make such determinations?</p> <p>The answer lies in Recursive Transition Networks\u2014a visual, intuitive formalism for describing the grammatical structure of languages, whether programming languages, natural languages, or anything with compositional rules.</p> <p>RTNs extend Finite State Machines with a crucial capability: the ability to call other networks recursively. This single addition transforms them from recognizers of simple patterns into powerful tools for parsing arbitrarily nested structures.</p>"},{"location":"building_blocks/recursive_transition_networks/#what-is-a-recursive-transition-network","title":"What is a Recursive Transition Network?","text":"<p>A Recursive Transition Network is a directed graph that describes a grammar:</p> <ul> <li>Nodes represent states in the parsing process</li> <li>Edges represent transitions based on input</li> <li>Labels on edges can be terminals (actual symbols like <code>+</code> or <code>the</code>) or non-terminals (references to other RTNs)</li> <li>Start state indicates where parsing begins</li> <li>End state(s) mark successful completion</li> </ul> <p>The defining feature: edges can reference other RTNs. An RTN for \"Expression\" might call an RTN for \"Term,\" which calls \"Factor,\" which calls back to \"Expression.\" This circular reference\u2014recursion\u2014enables parsing of nested structures like <code>((1 + 2) * (3 + 4))</code>.</p>"},{"location":"building_blocks/recursive_transition_networks/#formal-definition","title":"Formal Definition","text":"<p>An RTN is defined by a set of networks, where each network N is a 5-tuple \u0011(Q, \u03a3, \u0393, \u03b4, q_0, F)\u0011:</p> Symbol Meaning \u0011Q\u0011 Finite set of states \u0011\u03a3\u0011 Finite alphabet of terminal symbols (actual tokens) \u0011\u0393\u0011 Finite set of non-terminal symbols (network names) \u0011\u03b4\u0011 Transition function: \u0011Q \u0017 (\u03a3 \u0011\u0011 \u0393) \u0017 Q\u0011 \u0011q_0\u0011 Initial state \u0011(q_0 \u2208 Q)\u0011 \u0011F\u0011 Set of final/accepting states \u0011(F \u2286 Q)\u0011 <p>The key distinction from finite state machines: transitions can be on non-terminals, which invoke other networks recursively.</p>"},{"location":"building_blocks/recursive_transition_networks/#a-simple-example-greetings","title":"A Simple Example: Greetings","text":"<p>Let's build an RTN for simple greetings. Valid greetings include:</p> <ul> <li>\"Hello\"</li> <li>\"Hi\"</li> <li>\"Hello there\"</li> <li>\"Hi friend\"</li> <li>\"Hello there friend\"</li> </ul> <p>Here's the RTN:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; s1\n    s1 --&gt; s2: Hello\n    s1 --&gt; s2: Hi\n    s2 --&gt; [*]\n    s2 --&gt; s3: there\n    s3 --&gt; [*]\n    s3 --&gt; s4: friend\n    s2 --&gt; s4: friend\n    s4 --&gt; [*]</code></pre> <p>How to read this:</p> <ol> <li>Start at the initial state</li> <li>Must consume either \"Hello\" or \"Hi\" to reach <code>s2</code></li> <li>From <code>s2</code>, can exit (valid greeting), or continue with \"there\" or \"friend\"</li> <li>From <code>s3</code> (after \"there\"), can exit or add \"friend\"</li> <li>Any path reaching a final state is valid</li> </ol> <p>Trace example: \"Hi there friend\"</p> <ul> <li>Start \u2192 (Hi) \u2192 s2 \u2192 (there) \u2192 s3 \u2192 (friend) \u2192 s4 \u2192 End \u2713</li> </ul> <p>Invalid example: \"Hello friend there\"</p> <ul> <li>Start \u2192 (Hello) \u2192 s2 \u2192 (friend) \u2192 s4 \u2192 (there?) \u2192 stuck (no transition)</li> </ul> Practice Tracing <p>Try tracing \"Hello there\" and \"Hi\" through the network. What about just \"there friend\" without a greeting? Where does it fail?</p>"},{"location":"building_blocks/recursive_transition_networks/#recognizing-unsigned-integers","title":"Recognizing Unsigned Integers","text":"<p>Let's define a more interesting pattern: unsigned integers (one or more digits).</p> <p>Valid:</p> <ul> <li>\"7\"</li> <li>\"42\"</li> <li>\"1337\"</li> </ul> <p>Invalid:</p> <ul> <li>\"\" (empty)</li> <li>\"12.5\" (contains a decimal point)</li> </ul> <p>The RTN:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; s1\n    s1 --&gt; s2: Digit\n    s2 --&gt; s2: Digit\n    s2 --&gt; [*]</code></pre> <p>Analysis:</p> <ul> <li>Requires at least one digit to reach <code>s2</code> (rejects empty string)</li> <li>Loop on <code>s2</code> accepts zero or more additional digits</li> <li>Can exit after any digit</li> </ul> <p>This compact representation says \"one or more digits\"\u2014a pattern that would require infinitely many states if we tried to enumerate every possible number explicitly.</p>"},{"location":"building_blocks/recursive_transition_networks/#expression-rtn","title":"The Power of Recursion: Arithmetic Expressions","text":"<p>Here's where RTNs demonstrate their real power. We want to parse arithmetic expressions like:</p> <ul> <li><code>5</code></li> <li><code>3 + 7</code></li> <li><code>(2 + 3) * 4</code></li> <li><code>3 + 4 * 2</code></li> <li><code>((1 + 2) * (3 + 4))</code></li> </ul> <p>The challenge: expressions can contain other expressions (via parentheses), and we need to enforce operator precedence (<code>*</code> and <code>/</code> bind tighter than <code>+</code> and <code>-</code>).</p>"},{"location":"building_blocks/recursive_transition_networks/#why-operator-precedence-matters","title":"Why Operator Precedence Matters","text":"<p>When parsing <code>3 + 4 * 2</code>, we want:</p> <ul> <li>Correct: <code>3 + (4 * 2) = 11</code></li> <li>Incorrect: <code>(3 + 4) * 2 = 14</code></li> </ul> <p>The grammar itself must encode this precedence. We accomplish this through a hierarchy of RTNs.</p>"},{"location":"building_blocks/recursive_transition_networks/#the-three-level-hierarchy","title":"The Three-Level Hierarchy","text":"<p>We define three mutually recursive networks that work together to enforce operator precedence:</p>  Expression (Loosest Binding) Term (Medium Binding) Factor (Tightest Binding) <p>An Expression handles addition and subtraction (<code>+</code> and <code>-</code>).</p> <p>Conceptually: An Expression is one or more Terms added or subtracted together.</p> <p>RTN Diagram:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; s1\n    s1 --&gt; s2: Term\n    s2 --&gt; [*]\n    s2 --&gt; s3: +\n    s2 --&gt; s3: -\n    s3 --&gt; s2: Term</code></pre> <p>How it works: An expression is a term, optionally followed by <code>+</code> or <code>-</code> and another term (repeatable).</p> <p>Key observation: Expression calls Term first, ensuring multiplication/division are handled before returning. This means <code>3 + 4 * 2</code> naturally parses as (term: 3) + (term: 4 \u0017 2).</p> <p>A Term handles multiplication and division (<code>*</code> and <code>/</code>).</p> <p>Conceptually: A Term is one or more Factors multiplied or divided together.</p> <p>RTN Diagram:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; t1\n    t1 --&gt; t2: Factor\n    t2 --&gt; [*]\n    t2 --&gt; t3: *\n    t2 --&gt; t3: /\n    t3 --&gt; t2: Factor</code></pre> <p>How it works: A term is a factor, optionally followed by <code>*</code> or <code>/</code> and another factor (repeatable).</p> <p>Key observation: Term calls Factor, grouping numbers/parenthesized expressions before returning to Expression. This ensures multiplication happens before addition.</p> <p>A Factor handles numbers and parenthesized expressions.</p> <p>Conceptually: A Factor is the smallest unit\u2014either a number or a parenthesized expression.</p> <p>RTN Diagram:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; f1\n    f1 --&gt; f2: Number\n    f1 --&gt; f3: (\n    f3 --&gt; f4: Expression\n    f4 --&gt; f2: )\n    f2 --&gt; [*]</code></pre> <p>How it works: A factor is either a number or an expression wrapped in parentheses.</p> <p>Key observation: Factor can call Expression recursively, enabling nested parentheses like <code>((1 + 2))</code>. This is where the recursion becomes circular\u2014Expression calls Term, Term calls Factor, Factor can call Expression again.</p> <p>How the Calling Chain Encodes Precedence</p> <p>The recursion structure determines precedence:</p> <pre><code>graph TD\n    E[Expression&lt;br/&gt;handles + and -]\n    T[Term&lt;br/&gt;handles * and /]\n    F[Factor&lt;br/&gt;handles numbers &amp; parentheses]\n\n    E --&gt;|calls| T\n    T --&gt;|calls| F\n    F -.-&gt;|can call| E\n\n    style E fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style T fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style F fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>The calling order enforces precedence:</p> <ol> <li>Expression must call Term (can't skip to Factor)</li> <li>Term must call Factor (can't skip to numbers)</li> <li>Factor may call Expression (for parentheses)</li> </ol> <p>Because Term processes multiplication/division before returning to Expression (which handles addition/subtraction), the grammar itself encodes precedence. No special case handling needed.</p>"},{"location":"building_blocks/recursive_transition_networks/#trace-example-1-3-4-2","title":"Trace Example 1: <code>3 + 4 * 2</code>","text":"<p>Step-by-step parsing:</p> <ol> <li>Expression enters, calls Term</li> <li>Term calls Factor \u2192 consumes <code>3</code>, returns to Term</li> <li>Term looks ahead: sees <code>+</code> (not <code>*</code> or <code>/</code>), so returns <code>3</code> to Expression</li> <li>Expression sees <code>+</code>, transitions to expect another Term</li> <li>Second Term calls Factor \u2192 consumes <code>4</code>, returns</li> <li>Term sees <code>*</code>, transitions to expect another Factor</li> <li>Factor consumes <code>2</code>, returns to Term</li> <li>Term returns <code>4 * 2</code> (as a unit) to Expression</li> <li>Expression completes with structure: <code>3 + (4 * 2)</code></li> </ol> <p>Result: Correctly parsed as <code>3 + (4 * 2) = 11</code>, not <code>(3 + 4) * 2 = 14</code>.</p> <p>The hierarchical calling structure forced multiplication to complete before addition.</p>"},{"location":"building_blocks/recursive_transition_networks/#trace-example-2-2-3-4","title":"Trace Example 2: <code>(2 + 3) * 4</code>","text":"<p>Parentheses override precedence:</p> <ol> <li>Expression calls Term</li> <li>Term calls Factor</li> <li>Factor sees <code>(</code>, transitions to expect Expression (recursive call)</li> <li>Inner Expression calls Term \u2192 Factor \u2192 consumes <code>2</code></li> <li>Inner Expression sees <code>+</code>, calls another Term \u2192 Factor \u2192 consumes <code>3</code></li> <li>Inner Expression completes, returns <code>2 + 3</code> to Factor</li> <li>Factor expects <code>)</code>, finds it, returns to Term</li> <li>Term sees <code>*</code>, calls another Factor \u2192 consumes <code>4</code></li> <li>Term completes with structure: <code>(2 + 3) * 4</code></li> <li>Expression completes</li> </ol> <p>Result: Parentheses created a nested Expression evaluated before the multiplication.</p>"},{"location":"building_blocks/recursive_transition_networks/#rtns-for-natural-language","title":"RTNs for Natural Language","text":"<p>RTNs originated in natural language processing research in the 1970s. They provide a visual way to specify syntactic structure.</p>"},{"location":"building_blocks/recursive_transition_networks/#simple-english-sentences","title":"Simple English Sentences","text":"<p>A basic sentence has a noun phrase followed by a verb phrase:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; sent1\n    sent1 --&gt; sent2: NounPhrase\n    sent2 --&gt; sent3: VerbPhrase\n    sent3 --&gt; [*]</code></pre>"},{"location":"building_blocks/recursive_transition_networks/#noun-phrase-rtn","title":"Noun Phrase RTN","text":"<p>A noun phrase consists of an optional article, zero or more adjectives, and a noun:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; np1\n    np1 --&gt; np2: Article\n    np1 --&gt; np2: (skip)\n    np2 --&gt; np3: Adjective\n    np2 --&gt; np3: (skip)\n    np3 --&gt; np3: Adjective\n    np3 --&gt; np4: Noun\n    np4 --&gt; [*]</code></pre>"},{"location":"building_blocks/recursive_transition_networks/#verb-phrase-rtn","title":"Verb Phrase RTN","text":"<p>A verb phrase is a verb, optionally followed by a noun phrase:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; vp1\n    vp1 --&gt; vp2: Verb\n    vp2 --&gt; [*]\n    vp2 --&gt; vp3: NounPhrase\n    vp3 --&gt; [*]</code></pre> <p>Example sentences these RTNs accept:</p> <ul> <li>\"Cats sleep\"</li> <li>\"The cat sleeps\"</li> <li>\"The big fluffy cat chased the tiny mouse\"</li> <li>\"A small dog barked\"</li> </ul> <p>Trace: \"The cat sleeps\"</p> <ol> <li>Sentence \u2192 NounPhrase</li> <li>NounPhrase: <code>The</code> (Article) \u2192 (no Adjectives) \u2192 <code>cat</code> (Noun) \u2192 complete</li> <li>Sentence \u2192 VerbPhrase</li> <li>VerbPhrase: <code>sleeps</code> (Verb) \u2192 (no NounPhrase) \u2192 complete</li> <li>Sentence complete \u2713</li> </ol> <p>Of course, real natural language is vastly more complex (prepositional phrases, relative clauses, conjunctions, etc.), but these RTNs demonstrate the principle.</p>"},{"location":"building_blocks/recursive_transition_networks/#historical-context","title":"Historical Context","text":"<p>Recursive Transition Networks were developed in the early 1970s for computational linguistics and natural language understanding. William A. Woods formalized RTNs in his influential 1970 paper \"Transition Network Grammars for Natural Language Analysis.\"</p> <p>RTNs were part of a broader effort to move beyond simple finite state machines for language processing. They bridged the gap between FSMs (too limited for nested structures) and full context-free grammars (more expressive but less intuitive to work with visually).</p> <p>Augmented Transition Networks (ATNs), introduced by Woods shortly after, extended RTNs with registers and conditions, making them even more powerful. ATNs were used in early natural language interfaces and question-answering systems.</p> <p>While modern parsers often use other formalisms (LL, LR, Earley parsers based on context-free grammars), RTNs remain pedagogically valuable for understanding how grammars work.</p>"},{"location":"building_blocks/recursive_transition_networks/#relationship-to-other-formalisms","title":"Relationship to Other Formalisms","text":"<p>RTNs sit in a hierarchy of formal language tools:</p> Formalism Power Visual? Best For Finite State Machine Regular languages Yes Simple patterns (no nesting) Recursive Transition Network Context-free languages Yes Nested structures with visual clarity Context-Free Grammar (BNF) Context-free languages No Precise textual specification Pushdown Automaton Context-free languages Rarely Theoretical analysis <p>RTNs and context-free grammars are equally powerful\u2014they recognize the same class of languages (context-free languages). The choice between them is often about convenience and clarity:</p> <ul> <li>RTNs: More intuitive visually; easier to trace by hand</li> <li>BNF/CFG: More compact textually; easier to process algorithmically</li> </ul>"},{"location":"building_blocks/recursive_transition_networks/#implementation-considerations","title":"Implementation Considerations","text":"<p>RTNs translate naturally into recursive descent parsers. Each network becomes a function that calls other functions for non-terminals.</p> <p>Pseudocode for Expression RTN:</p> <pre><code>function Expression():\n    result = Term()\n    while next_token in ['+', '-']:\n        operator = consume_token()\n        right = Term()\n        result = combine(result, operator, right)\n    return result\n</code></pre> <p>This recursive structure mirrors the RTN diagram directly, making implementation straightforward.</p>"},{"location":"building_blocks/recursive_transition_networks/#limitations-of-rtns","title":"Limitations of RTNs","text":"<p>Despite their elegance, RTNs have limitations:</p>"},{"location":"building_blocks/recursive_transition_networks/#1-ambiguity","title":"1. Ambiguity","text":"<p>RTNs can be ambiguous. Consider a grammar where an expression could be parsed multiple ways. The RTN doesn't specify which interpretation to choose.</p> <p>Example: The expression <code>3 - 4 - 5</code> could be:</p> <ul> <li>Left-associative: <code>(3 - 4) - 5 = -6</code></li> <li>Right-associative: <code>3 - (4 - 5) = 4</code></li> </ul> <p>Our RTN's loop structure naturally creates left-associativity, but this isn't explicit in the diagram.</p>"},{"location":"building_blocks/recursive_transition_networks/#2-not-all-context-free-languages","title":"2. Not All Context-Free Languages","text":"<p>While RTNs recognize context-free languages, they can't enforce context-sensitive constraints like \"variables must be declared before use\" or \"function call has correct number of arguments.\" These require additional mechanisms (semantic analysis).</p>"},{"location":"building_blocks/recursive_transition_networks/#3-efficiency","title":"3. Efficiency","text":"<p>Naive RTN traversal can be inefficient for some grammars, requiring backtracking. Modern parsing algorithms optimize this.</p>"},{"location":"building_blocks/recursive_transition_networks/#why-rtns-matter","title":"Why RTNs Matter","text":"<p>Understanding RTNs provides insight into:</p> <ul> <li>Compiler design: How programming languages are parsed</li> <li>Natural language processing: How sentence structure is analyzed</li> <li>Data validation: How formats like JSON or XML are validated</li> <li>Computational thinking: Breaking complex structures into composable, recursive pieces</li> </ul> <p>RTNs make the abstract concrete. They turn \"grammar\" from a vague concept into a precise, traceable mechanism you can follow by hand or implement in code.</p>"},{"location":"building_blocks/recursive_transition_networks/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Email Addresses <p>Design an RTN for simplified email addresses like <code>user@domain.com</code>.</p> <p>Components: - Username: one or more letters/digits - <code>@</code> symbol - Domain: one or more letters/digits - <code>.</code> symbol - Extension: one or more letters</p> <p>Hint: Create separate networks for Username, Domain, and Extension, then combine them.</p> Solution Sketch <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; s1\n    s1 --&gt; s2: Username\n    s2 --&gt; s3: @\n    s3 --&gt; s4: Domain\n    s4 --&gt; s5: .\n    s5 --&gt; s6: Extension\n    s6 --&gt; [*]</code></pre> <p>Where Username, Domain, and Extension each follow the \"one or more alphanumeric\" pattern (similar to our unsigned integer RTN).</p> Practice Problem 2: Trace an Expression <p>Trace <code>2 * 3 + 4</code> through the Expression/Term/Factor RTNs.</p> <p>What structure does it produce? Is it <code>(2 * 3) + 4</code> or <code>2 * (3 + 4)</code>?</p> Solution <p>Trace:</p> <ol> <li>Expression \u2192 Term</li> <li>Term \u2192 Factor \u2192 <code>2</code></li> <li>Term sees <code>*</code> \u2192 Factor \u2192 <code>3</code></li> <li>Term returns <code>2 * 3</code> to Expression</li> <li>Expression sees <code>+</code> \u2192 Term</li> <li>Term \u2192 Factor \u2192 <code>4</code></li> <li>Expression completes with <code>(2 * 3) + 4</code></li> </ol> <p>Result: <code>(2 * 3) + 4 = 10</code>, not <code>2 * (3 + 4) = 14</code>. Correct precedence!</p> Practice Problem 3: Extend the Grammar <p>How would you modify the arithmetic RTNs to support exponentiation (<code>^</code>), which should have higher precedence than multiplication?</p> <p>Hint: Where does it fit in the Expression \u2192 Term \u2192 Factor hierarchy?</p> Solution <p>Add a fourth level between Term and Factor:</p> <ul> <li>Expression \u2192 Term \u2192 Power \u2192 Factor</li> <li>Power handles <code>^</code></li> <li>Term would then call Power instead of Factor</li> </ul> <p>Power RTN:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; p1\n    p1 --&gt; p2: Factor\n    p2 --&gt; [*]\n    p2 --&gt; p3: ^\n    p3 --&gt; p2: Factor</code></pre> <p>Now <code>2 + 3 * 4 ^ 5</code> parses as <code>2 + (3 * (4 ^ 5))</code> \u2713</p> Practice Problem 4: Ambiguity <p>The natural language RTNs above are ambiguous. Find a sentence that could have multiple valid parses.</p> <p>Example sentence: \"The cat saw the dog with the telescope\"</p> Solution <p>This sentence has two interpretations:</p> <ol> <li>The cat used a telescope to see the dog</li> <li>The cat saw a dog that has a telescope</li> </ol> <p>Both are structurally valid given our simple RTNs, but mean different things. Resolving such ambiguity requires either:</p> <ul> <li>More sophisticated grammar rules (subcategorization)</li> <li>Semantic analysis (understanding meaning)</li> <li>Probabilistic models (choosing most likely interpretation)</li> </ul> <p>This is a fundamental challenge in natural language processing.</p>"},{"location":"building_blocks/recursive_transition_networks/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning RTN Finite state machine extended with network calls Terminal Actual token/symbol in input (e.g., <code>+</code>, <code>the</code>) Non-terminal Reference to another RTN (e.g., <code>Expression</code>) Recursion Network calling itself (directly or indirectly) Precedence Hierarchy of networks encodes operator priority Context-Free Class of languages RTNs recognize Parse Tree Structure produced by successful parse"},{"location":"building_blocks/recursive_transition_networks/#further-reading","title":"Further Reading","text":"<ul> <li>William A. Woods (1970) \u2014 \"Transition Network Grammars for Natural Language Analysis\" (the original paper)</li> <li>David Evans, Introduction to Computing \u2014 Chapter 2 covers RTNs and formal languages</li> <li>Scheme &amp; Parse Trees \u2014 A language where the grammar is just nested lists</li> <li>Binary Trees &amp; Representation \u2014 Tree structures and parse trees</li> <li>Computational Thinking \u2014 RTNs exemplify decomposition and abstraction</li> <li>Backus-Naur Form \u2014 Textual notation for context-free grammars</li> </ul> <p>Recursive Transition Networks transform the abstract notion of \"grammar\" into something you can see, trace, and reason about. They bridge the gap between finite state machines (too simple for nesting) and full context-free grammars (precise but less visual). In doing so, they make parsing\u2014a fundamental task in computer science\u2014accessible and intuitive.</p> <p>Every time a compiler checks your code or a grammar checker analyzes your writing, something very much like an RTN is working behind the scenes. Understanding how these networks operate gives you insight into one of the most ubiquitous problems in computing: making sense of structured input.</p>"},{"location":"building_blocks/recursive_transition_networks/#video-summary","title":"Video Summary","text":""},{"location":"building_blocks/regular_expressions/","title":"Regular Expressions","text":""},{"location":"building_blocks/regular_expressions/#description-a-practical-guide-to-regex-the-text-processing-powerhouse-used-in-every-modern-programming-language","title":"description: A practical guide to Regex: the text processing powerhouse used in every modern programming language.","text":""},{"location":"building_blocks/regular_expressions/#regular-expressions","title":"Regular Expressions","text":"<p>You've seen Finite State Machines\u2014elegant diagrams showing states and transitions. You've seen BNF\u2014formal grammar notation. But when you need to actually use pattern matching in your code, you reach for regular expressions (regex).</p> <p>Regex is the practical face of formal language theory. It's the same mathematical power as FSMs, wrapped in a terse syntax that fits in a single line. Love them or hate them (often both), regular expressions are an essential tool.</p>"},{"location":"building_blocks/regular_expressions/#why-regular-expressions-matter","title":"Why Regular Expressions Matter","text":"<p>Regular expressions are embedded in virtually every modern programming language and tool. They're the Swiss Army knife of text processing:</p> <ul> <li>Validation: Email addresses, phone numbers, passwords, credit cards</li> <li>Search and Replace: Find complex patterns across codebases (grep, IDE search)</li> <li>Parsing: Extract data from logs, CSV files, API responses</li> <li>Lexical Analysis: The first stage of compilation\u2014breaking source code into tokens</li> <li>Data Cleaning: Normalize messy input, strip unwanted characters</li> <li>URL Routing: Web frameworks use regex to match request paths</li> </ul> <p>The return on investment is massive. Spend an hour learning regex fundamentals, unlock decades of productivity. What would take 50 lines of string manipulation code becomes a single elegant pattern.</p> <p>They're not just for programmers. Journalists use regex to analyze leaked documents. Scientists extract data from research papers. Anyone working with text at scale needs this tool.</p>"},{"location":"building_blocks/regular_expressions/#what-is-a-regular-expression","title":"What is a Regular Expression?","text":"<p>A regular expression is a pattern that describes a set of strings. Instead of listing every valid string, you describe the rules for what makes a string valid.</p> Email Address Pattern<pre><code>^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\n</code></pre> <p>That monstrosity? It matches email addresses. \ud83d\ude05 Let's learn to read (and write) these things.</p>"},{"location":"building_blocks/regular_expressions/#basic-building-blocks","title":"Basic Building Blocks","text":""},{"location":"building_blocks/regular_expressions/#literal-characters","title":"Literal Characters","text":"<p>Most characters match themselves:</p> Pattern Matches <code>cat</code> \"cat\" <code>hello</code> \"hello\" <code>123</code> \"123\""},{"location":"building_blocks/regular_expressions/#metacharacters","title":"Metacharacters","text":"<p>Some characters have special meaning:</p> Character Meaning Example Matches <code>.</code> Any single character <code>c.t</code> \"cat\", \"cot\", \"c9t\" <code>^</code> Start of string <code>^hello</code> \"hello world\" (at start) <code>$</code> End of string <code>world$</code> \"hello world\" (at end) <code>\\</code> Escape special char <code>\\.</code> literal \".\""},{"location":"building_blocks/regular_expressions/#character-classes","title":"Character Classes","text":"<p>Match one character from a set:</p> Pattern Meaning Matches <code>[aeiou]</code> Any vowel \"a\", \"e\", \"i\", \"o\", \"u\" <code>[0-9]</code> Any digit \"0\" through \"9\" <code>[a-zA-Z]</code> Any letter \"a\"-\"z\", \"A\"-\"Z\" <code>[^0-9]</code> NOT a digit anything except \"0\"-\"9\""},{"location":"building_blocks/regular_expressions/#shorthand-classes","title":"Shorthand Classes","text":"<p>Common patterns have shortcuts:</p> Shorthand Equivalent Meaning <code>\\d</code> <code>[0-9]</code> Digit <code>\\D</code> <code>[^0-9]</code> Not a digit <code>\\w</code> <code>[a-zA-Z0-9_]</code> Word character <code>\\W</code> <code>[^a-zA-Z0-9_]</code> Not a word character <code>\\s</code> <code>[ \\t\\n\\r]</code> Whitespace <code>\\S</code> <code>[^ \\t\\n\\r]</code> Not whitespace Unicode Characters <p>By default in many regex engines, <code>\\w</code> matches only ASCII characters (a-z, A-Z, 0-9, _).</p> <p>This means <code>\\w</code> WON'T match:</p> <ul> <li>Accented letters: \"\u00e9\", \"\u00f1\", \"\u00fc\"</li> <li>Non-Latin alphabets: \"\u03c0\", \"\u3053\", \"\u05d0\"</li> <li>Emoji: \"\ud83d\ude00\"</li> </ul> <p>Solutions:</p> <ul> <li>JavaScript: Use the <code>u</code> flag: <code>/\\w+/u</code></li> <li>Python: Use <code>re.UNICODE</code> flag (default in Python 3): <code>re.search(r'\\w+', text, re.UNICODE)</code></li> <li>Or be explicit: Use <code>[a-zA-Z\u00c0-\u00ff]</code> for Latin with accents, or custom character classes</li> </ul> <p>For truly international text, consider using Unicode categories like <code>\\p{L}</code> (any letter) if your engine supports them.</p> Concept Check 1: Three-Letter Words <p>Write a regex pattern that matches three letters starting with a vowel.</p> Solution <p>Pattern: <code>[aeiouAEIOU][a-zA-Z][a-zA-Z]</code></p> <ul> <li><code>[aeiouAEIOU]</code> - starts with a vowel</li> <li><code>[a-zA-Z]</code> - second letter</li> <li><code>[a-zA-Z]</code> - third letter</li> </ul> <p>Note: This matches the pattern anywhere in text. Later we'll learn about word boundaries (<code>\\b</code>) to match complete words only.</p> Concept Check 2: Postal Codes <p>Write a regex pattern that matches a Canadian postal code format (like \"K1A 0B1\" - letter, digit, letter, space, digit, letter, digit).</p> Solution <p>Pattern: <code>[A-Z]\\d[A-Z] \\d[A-Z]\\d</code></p> <ul> <li><code>[A-Z]</code> - uppercase letter</li> <li><code>\\d</code> - digit</li> <li><code>[A-Z]</code> - uppercase letter</li> <li><code></code> - space</li> <li><code>\\d</code> - digit</li> <li><code>[A-Z]</code> - uppercase letter</li> <li><code>\\d</code> - digit</li> </ul>"},{"location":"building_blocks/regular_expressions/#quantifiers-how-many","title":"Quantifiers: How Many?","text":"<p>Quantifiers specify repetition:</p> Quantifier Meaning Example Matches <code>*</code> Zero or more <code>ab*c</code> \"ac\", \"abc\", \"abbc\", \"abbbc\"... <code>+</code> One or more <code>ab+c</code> \"abc\", \"abbc\", \"abbbc\"... (not \"ac\") <code>?</code> Zero or one <code>colou?r</code> \"color\", \"colour\" <code>{n}</code> Exactly n <code>a{3}</code> \"aaa\" <code>{n,}</code> n or more <code>a{2,}</code> \"aa\", \"aaa\", \"aaaa\"... <code>{n,m}</code> Between n and m <code>a{2,4}</code> \"aa\", \"aaa\", \"aaaa\""},{"location":"building_blocks/regular_expressions/#greedy-vs-lazy","title":"Greedy vs Lazy","text":"<p>By default, quantifiers are greedy\u2014they match as much as possible.</p> Greedy Matching Example<pre><code>Pattern: &lt;.*&gt;\nString:  &lt;div&gt;hello&lt;/div&gt;\nMatch:   &lt;div&gt;hello&lt;/div&gt;  (the whole thing!)\n</code></pre> <p>Add <code>?</code> for lazy matching\u2014match as little as possible:</p> Lazy Matching Example<pre><code>Pattern: &lt;.*?&gt;\nString:  &lt;div&gt;hello&lt;/div&gt;\nMatch:   &lt;div&gt;  (just the first tag)\n</code></pre> Concept Check 3: Password Length <p>Write a regex pattern for a password that's exactly 8-16 characters long (no more, no less).</p> Solution <p>Pattern: <code>^.{8,16}$</code></p> <ul> <li><code>^</code> - start of string</li> <li><code>.</code> - any character</li> <li><code>{8,16}</code> - between 8 and 16 times</li> <li><code>$</code> - end of string</li> </ul> Concept Check 4: Hashtags <p>Write a regex pattern that matches a hashtag (starts with #, followed by one or more word characters).</p> Solution <p>Pattern: <code>#\\w+</code></p> <ul> <li><code>#</code> - literal hashtag</li> <li><code>\\w+</code> - one or more word characters</li> </ul> Concept Check 5: Multiple Spaces <p>Write a regex pattern that matches multiple spaces (two or more consecutive spaces).</p> Solution <p>Pattern: <code>{2,}</code> or <code>+</code></p> <ul> <li><code>{2,}</code> - space character, 2 or more times</li> <li><code>+</code> - two spaces followed by zero or more spaces</li> </ul>"},{"location":"building_blocks/regular_expressions/#grouping-and-alternatives","title":"Grouping and Alternatives","text":""},{"location":"building_blocks/regular_expressions/#groups","title":"Groups: <code>( )</code>","text":"<p>Parentheses group patterns together:</p> Grouping Examples<pre><code>(ab)+     # One or more \"ab\": \"ab\", \"abab\", \"ababab\"\n(cat|dog) # \"cat\" or \"dog\"\n</code></pre>"},{"location":"building_blocks/regular_expressions/#capturing-groups","title":"Capturing Groups","text":"<p>Groups also capture what they match for later use. Think of parentheses as creating a \"memory slot\" that saves whatever matched inside them.</p> <p>Why capture? You often want to extract specific parts of a match, not just verify a pattern exists.</p> <p>For example, if you're matching a phone number like <code>555-1234</code>, you might want to:</p> <ul> <li>Extract just the first three digits (<code>555</code>)</li> <li>Extract just the last four digits (<code>1234</code>)</li> <li>Rearrange the parts into a different format</li> </ul> <p>How it works:</p> Capturing Groups in Python<pre><code>import re\n\nmatch = re.search(r'(\\d{3})-(\\d{4})', 'Call 555-1234')  # (1)!\nprint(match.group(0))  # \"555-1234\" (entire match)  # (2)!\nprint(match.group(1))  # \"555\" (first capture group)  # (3)!\nprint(match.group(2))  # \"1234\" (second capture group)  # (4)!\n</code></pre> <ol> <li>Search for pattern with two capturing groups: 3 digits, hyphen, 4 digits</li> <li>Group 0 is always the entire matched string</li> <li>Group 1 captures the first parenthesized sub-pattern (3 digits)</li> <li>Group 2 captures the second parenthesized sub-pattern (4 digits)</li> </ol> <p>Breaking it down:</p> Part What it does <code>(\\d{3})</code> Group 1: Captures first 3 digits <code>-</code> Matches literal hyphen (not captured) <code>(\\d{4})</code> Group 2: Captures last 4 digits <p>The parentheses create numbered groups (1, 2, 3...). Group 0 is always the entire match.</p> <p>Another example - Parsing dates:</p> Extracting Date Components<pre><code>import re\n\ntext = \"Born on 1995-08-23\"\nmatch = re.search(r'(\\d{4})-(\\d{2})-(\\d{2})', text)  # (1)!\n\nyear = match.group(1)   # \"1995\"  # (2)!\nmonth = match.group(2)  # \"08\"\nday = match.group(3)    # \"23\"\n\nprint(f\"Year: {year}, Month: {month}, Day: {day}\")\n# Output: Year: 1995, Month: 08, Day: 23\n</code></pre> <ol> <li>Pattern with three groups: 4 digits (year), 2 digits (month), 2 digits (day)</li> <li>Extract each component by accessing numbered capture groups</li> </ol> <p>Practical use - Reformatting:</p> Reformatting Phone Numbers<pre><code>import re\n\nphone = \"555-123-4567\"\n# Capture three groups\nmatch = re.search(r'(\\d{3})-(\\d{3})-(\\d{4})', phone)  # (1)!\n\n# Rearrange into different format\nformatted = f\"({match.group(1)}) {match.group(2)}-{match.group(3)}\"  # (2)!\nprint(formatted)  # Output: (555) 123-4567\n</code></pre> <ol> <li>Capture three groups: area code, exchange, and line number</li> <li>Reconstruct the phone number in a different format using the captured groups</li> </ol> <p>Key insight: Parentheses do two things:</p> <ol> <li>Group patterns together for quantifiers (like <code>(ab)+</code>)</li> <li>Capture the matched text for later use</li> </ol> <p>When you need grouping but don't want to capture, use non-capturing groups <code>(?:...)</code> (explained next).</p>"},{"location":"building_blocks/regular_expressions/#non-capturing-groups","title":"Non-Capturing Groups: <code>(?: )</code>","text":"<p>When you need grouping but don't need to capture:</p> Non-Capturing Group Example<pre><code>(?:ab)+   # Groups without capturing\n</code></pre>"},{"location":"building_blocks/regular_expressions/#backreferences","title":"Backreferences","text":"<p>A backreference lets you match the same text again that was captured by an earlier group. Instead of matching a pattern, you're matching the exact string that was already captured.</p> <p>Why use backreferences? To find repeated or matching patterns where you don't know in advance what the text will be, only that it should be the same.</p> <p>Basic example - Finding duplicate words:</p> Backreference Example<pre><code>(\\w+)\\s+\\1   # Matches repeated words: \"the the\", \"is is\"\n</code></pre> <p>How it works:</p> <ol> <li><code>(\\w+)</code> - Captures one or more word characters (this is Group 1)</li> <li><code>\\s+</code> - Matches one or more whitespace characters</li> <li><code>\\1</code> - Matches exactly the same text that Group 1 captured</li> </ol> <p>So if Group 1 captured \"the\", then <code>\\1</code> will only match \"the\" (not \"a\" or \"dog\" or anything else).</p> <p>Step-by-step with \"the the\":</p> Step Pattern Part Matches Group 1 Contains 1 <code>(\\w+)</code> \"the\" \"the\" 2 <code>\\s+</code> \" \" (space) \"the\" 3 <code>\\1</code> \"the\" (must match exactly!) \"the\" <p>If the text were \"the dog\", it wouldn't match because <code>\\1</code> looks for \"the\" again (not \"dog\").</p> <p>Finding matching HTML tags:</p> Matching Opening and Closing Tags<pre><code>&lt;(\\w+)&gt;.*?&lt;/\\1&gt;\n</code></pre> <p>This matches paired HTML tags like <code>&lt;div&gt;content&lt;/div&gt;</code> or <code>&lt;span&gt;text&lt;/span&gt;</code>:</p> <ul> <li><code>&lt;(\\w+)&gt;</code> - Captures the opening tag name (Group 1)</li> <li><code>.*?</code> - Matches any content (lazy)</li> <li><code>&lt;/\\1&gt;</code> - Matches closing tag with the same name as Group 1</li> </ul> <p>Breaking it down:</p> <p>For the string <code>&lt;div&gt;hello&lt;/div&gt;</code>:</p> Part Matches Group 1 <code>&lt;(\\w+)&gt;</code> <code>&lt;div&gt;</code> \"div\" <code>.*?</code> \"hello\" \"div\" <code>&lt;/\\1&gt;</code> <code>&lt;/div&gt;</code> \"div\" <p>But <code>&lt;div&gt;hello&lt;/span&gt;</code> wouldn't match because <code>\\1</code> is \"div\", not \"span\".</p> <p>Multiple backreferences:</p> Multiple Backreferences Example<pre><code>(\\w+) and \\1, (\\w+) and \\2\n</code></pre> <p>This matches patterns like \"cats and cats, dogs and dogs\":</p> <ul> <li><code>(\\w+)</code> - Group 1 captures first word</li> <li><code>and \\1</code> - Matches \" and \" followed by same word as Group 1</li> <li><code>, (\\w+)</code> - Group 2 captures second word</li> <li><code>and \\2</code> - Matches \" and \" followed by same word as Group 2</li> </ul> <p>Backreference numbers:</p> <ul> <li><code>\\1</code> refers to Group 1</li> <li><code>\\2</code> refers to Group 2</li> <li><code>\\3</code> refers to Group 3</li> <li>And so on...</li> </ul> <p>Important: Backreferences match the captured text, not the pattern. If <code>(\\d+)</code> captures \"42\", then <code>\\1</code> will only match \"42\" exactly, not any other number.</p> Concept Check 6: Color Spelling <p>Write a regex pattern that matches either \"color\" or \"colour\" using alternation.</p> Solution <p>Pattern: <code>colou?r</code> (simpler) or <code>col(o|ou)r</code> (using alternation)</p> <ul> <li>Both work, but <code>colou?r</code> is more concise</li> </ul> Concept Check 7: HTML Tag Capture <p>Write a regex pattern that matches HTML tags like <code>&lt;div&gt;</code>, <code>&lt;span&gt;</code>, <code>&lt;p&gt;</code> and captures the tag name.</p> Solution <p>Pattern: <code>&lt;(\\w+)&gt;</code></p> <ul> <li><code>&lt;</code> - literal less-than</li> <li><code>(\\w+)</code> - capture group for tag name (one or more word chars)</li> <li><code>&gt;</code> - literal greater-than</li> </ul> Concept Check 8: Doubled Words <p>Write a regex pattern that finds doubled words like \"the the\" or \"is is\".</p> Solution <p>Pattern: <code>(\\w+)\\s+\\1</code></p> <ul> <li><code>(\\w+)</code> - capture one or more word characters</li> <li><code>\\s+</code> - one or more whitespace</li> <li><code>\\1</code> - backreference to first captured group (must match the same text)</li> </ul> <p>Note: This pattern works but may match partial words. Later we'll learn about word boundaries (<code>\\b</code>) to match complete words only.</p>"},{"location":"building_blocks/regular_expressions/#anchors-and-boundaries","title":"Anchors and Boundaries","text":"Anchor Meaning <code>^</code> Start of string (or line with multiline flag) <code>$</code> End of string (or line with multiline flag) <code>\\b</code> Word boundary <code>\\B</code> Not a word boundary <p>Word boundaries are incredibly useful:</p> Word Boundary Example<pre><code>Pattern: \\bcat\\b\nMatches: \"the cat sat\" \u2713\nDoesn't match: \"category\" \u2717, \"bobcat\" \u2717\n</code></pre> Concept Check 9: TODO Lines <p>Write a regex pattern that matches lines that start with \"TODO:\".</p> Solution <p>Pattern: <code>^TODO:</code></p> <ul> <li><code>^</code> - start of line</li> <li><code>TODO:</code> - literal text</li> </ul> Concept Check 10: File Extensions <p>Write a regex pattern that matches files that end with <code>.md</code> or <code>.txt</code>.</p> Solution <p>Pattern: <code>\\.(md|txt)$</code></p> <ul> <li><code>\\.</code> - literal dot (escaped)</li> <li><code>(md|txt)</code> - either \"md\" or \"txt\"</li> <li><code>$</code> - end of string</li> </ul> Concept Check 11: Word Boundaries <p>Write a regex pattern that matches the word \"run\" as a standalone word (not in \"running\" or \"runner\").</p> Solution <p>Pattern: <code>\\brun\\b</code></p> <ul> <li><code>\\b</code> - word boundary</li> <li><code>run</code> - literal text</li> <li><code>\\b</code> - word boundary</li> <li>This won't match \"running\" or \"runner\" because of the boundaries</li> </ul>"},{"location":"building_blocks/regular_expressions/#lookahead-and-lookbehind","title":"Lookahead and Lookbehind","text":"<p>These match a position without consuming characters:</p> Syntax Name Meaning <code>(?=...)</code> Positive lookahead Followed by ... <code>(?!...)</code> Negative lookahead NOT followed by ... <code>(?&lt;=...)</code> Positive lookbehind Preceded by ... <code>(?&lt;!...)</code> Negative lookbehind NOT preceded by ... <p>Example: Password Validation</p> <p>Password must have a digit and a letter:</p> Password Validation Pattern<pre><code>^(?=.*\\d)(?=.*[a-zA-Z]).{8,}$\n</code></pre> <p>Breaking it down:</p> <ul> <li><code>^</code> \u2014 start</li> <li><code>(?=.*\\d)</code> \u2014 somewhere ahead, there's a digit</li> <li><code>(?=.*[a-zA-Z])</code> \u2014 somewhere ahead, there's a letter</li> <li><code>.{8,}</code> \u2014 at least 8 characters total</li> <li><code>$</code> \u2014 end</li> </ul> Concept Check 12: Contains Uppercase <p>Write a regex pattern that matches a string that contains at least one uppercase letter (anywhere).</p> Solution <p>Pattern: <code>^(?=.*[A-Z]).+$</code></p> <ul> <li><code>^</code> - start</li> <li><code>(?=.*[A-Z])</code> - positive lookahead: somewhere there's an uppercase</li> <li><code>.+</code> - one or more characters</li> <li><code>$</code> - end</li> </ul> Concept Check 13: Password Validation <p>Write a regex pattern for a password with at least one digit AND at least one special character (!@#$%).</p> Solution <p>Pattern: <code>^(?=.*\\d)(?=.*[!@#$%]).{8,}$</code></p> <ul> <li><code>^</code> - start</li> <li><code>(?=.*\\d)</code> - lookahead: contains a digit</li> <li><code>(?=.*[!@#$%])</code> - lookahead: contains a special character</li> <li><code>.{8,}</code> - at least 8 characters</li> <li><code>$</code> - end</li> </ul> Concept Check 14: Lookahead Without Capture <p>Write a regex pattern that matches a dollar amount that's followed by \"USD\" (but don't capture \"USD\").</p> Solution <p>Pattern: <code>\\$\\d+(?:\\.\\d{2})?(?= USD)</code></p> <ul> <li><code>\\$</code> - literal dollar sign</li> <li><code>\\d+</code> - one or more digits</li> <li><code>(?:\\.\\d{2})?</code> - optional decimal point and 2 digits</li> <li><code>(?= USD)</code> - positive lookahead: followed by \" USD\" (not captured)</li> </ul>"},{"location":"building_blocks/regular_expressions/#flags-and-modifiers","title":"Flags and Modifiers","text":"<p>Flags (also called modifiers) change how the regex engine interprets your pattern. They're added after the closing delimiter in most languages.</p>"},{"location":"building_blocks/regular_expressions/#common-flags","title":"Common Flags","text":"Flag Name What It Does <code>i</code> Case insensitive Match both uppercase and lowercase <code>g</code> Global Find all matches (not just first) <code>m</code> Multiline <code>^</code> and <code>$</code> match line starts/ends, not just string <code>s</code> Dotall <code>.</code> matches newlines too"},{"location":"building_blocks/regular_expressions/#flag-syntax-by-language","title":"Flag Syntax by Language","text":"Python - Flags JavaScript - Flags Go - Flags Rust - Flags Java - Flags C++ - Flags Flags in Python<pre><code>import re\n\nre.search(r'hello', text, re.I)              # Case insensitive (re.IGNORECASE)\nre.findall(r'\\d+', text)                     # findall is inherently global\nre.search(r'^line', text, re.M)              # Multiline (re.MULTILINE)\nre.search(r'.', text, re.S)                  # Dotall (re.DOTALL)\nre.search(r'hello', text, re.I | re.M)       # Multiple flags with |\n</code></pre> Flags in JavaScript<pre><code>/pattern/flags\n\n/hello/i          // Case insensitive\n/\\d+/g            // Global - find all numbers\n/^line/m          // Multiline - ^ matches line starts\n/./s              // Dotall - . matches newlines\n/hello/gi         // Multiple flags: global + case insensitive\n</code></pre> Flags in Go<pre><code>import \"regexp\"\n\n// Go regex is always case-sensitive by default\nregexp.MatchString(`(?i)hello`, text)        // Case insensitive (inline flag)\nregexp.FindAllString(`\\d+`, text, -1)        // Find all (use -1 for all matches)\nregexp.MatchString(`(?m)^line`, text)        // Multiline (inline flag)\nregexp.MatchString(`(?s).`, text)            // Dotall (inline flag)\nregexp.MatchString(`(?im)hello`, text)       // Multiple flags (inline)\n</code></pre> Flags in Rust<pre><code>use regex::Regex;\n\n// Case insensitive - use (?i) inline flag\nlet re = Regex::new(r\"(?i)hello\").unwrap();\nre.is_match(text);\n\n// Find all matches\nlet re = Regex::new(r\"\\d+\").unwrap();\nlet matches: Vec&lt;_&gt; = re.find_iter(text).collect();\n\n// Multiline - use (?m) inline flag\nlet re = Regex::new(r\"(?m)^line\").unwrap();\n\n// Dotall - use (?s) inline flag\nlet re = Regex::new(r\"(?s).\").unwrap();\n\n// Multiple flags\nlet re = Regex::new(r\"(?im)hello\").unwrap();\n</code></pre> Flags in Java<pre><code>import java.util.regex.*;\n\n// Case insensitive\nPattern.compile(\"hello\", Pattern.CASE_INSENSITIVE);\nPattern.compile(\"(?i)hello\");  // Inline flag alternative\n\n// Find all matches (use Matcher.find() in loop)\nPattern p = Pattern.compile(\"\\\\d+\");\nMatcher m = p.matcher(text);\nwhile (m.find()) { /* ... */ }\n\n// Multiline\nPattern.compile(\"^line\", Pattern.MULTILINE);\n\n// Dotall\nPattern.compile(\".\", Pattern.DOTALL);\n\n// Multiple flags\nPattern.compile(\"hello\", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);\n</code></pre> Flags in C++<pre><code>#include &lt;regex&gt;\n\n// Case insensitive\nstd::regex re(\"hello\", std::regex::icase);\n\n// Find all matches (use std::sregex_iterator)\nstd::regex re(\"\\\\d+\");\nauto matches = std::sregex_iterator(text.begin(), text.end(), re);\n\n// Multiline (use ECMAScript grammar with multiline)\nstd::regex re(\"^line\", std::regex::multiline);\n\n// Dotall - not directly supported in C++11, use [\\s\\S] instead\nstd::regex re(\"[\\\\s\\\\S]\");  // Workaround for dotall\n\n// Multiple flags\nstd::regex re(\"hello\", std::regex::icase | std::regex::multiline);\n</code></pre>"},{"location":"building_blocks/regular_expressions/#example-case-insensitive-matching","title":"Example: Case Insensitive Matching","text":"<p>Without flag:</p> Case Sensitive (Default)<pre><code>/cat/              # Matches: \"cat\"\n                   # Doesn't match: \"Cat\", \"CAT\"\n</code></pre> <p>With <code>i</code> flag:</p> Case Insensitive<pre><code>/cat/i             # Matches: \"cat\", \"Cat\", \"CAT\", \"CaT\"\n</code></pre>"},{"location":"building_blocks/regular_expressions/#example-global-flag","title":"Example: Global Flag","text":"<p>The global flag controls whether to find just the first match or all matches:</p>  Python - Global JavaScript - Global Go - Global Rust - Global Java - Global C++ - Global Find All vs Find First in Python<pre><code>import re\n\ntext = \"2024-12-15\"\n\n# Find first match only\nfirst = re.search(r'\\d+', text)\nprint(first.group())  # \"2024\"\n\n# Find all matches\nall_matches = re.findall(r'\\d+', text)\nprint(all_matches)  # [\"2024\", \"12\", \"15\"]\n</code></pre> Global vs Non-Global in JavaScript<pre><code>const text = \"2024-12-15\";\n\n// Without g - finds first match only\ntext.match(/\\d+/)     // [\"2024\"]\n\n// With g - finds all matches\ntext.match(/\\d+/g)    // [\"2024\", \"12\", \"15\"]\n</code></pre> Find All vs Find First in Go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc main() {\n    text := \"2024-12-15\"\n    re := regexp.MustCompile(`\\d+`)  // (1)!\n\n    // Find first match only\n    first := re.FindString(text)  // (2)!\n    fmt.Println(first)  // \"2024\"\n\n    // Find all matches\n    all := re.FindAllString(text, -1)  // (3)!\n    fmt.Println(all)  // [\"2024\" \"12\" \"15\"]\n}\n</code></pre> <ol> <li><code>MustCompile</code> panics on invalid regex (use <code>Compile</code> for error handling)</li> <li><code>FindString</code> returns first match as string (empty string if no match)</li> <li>Second parameter <code>-1</code> means find all matches (positive number limits results)</li> </ol> Find All vs Find First in Rust<pre><code>use regex::Regex;\n\nfn main() {\n    let text = \"2024-12-15\";\n    let re = Regex::new(r\"\\d+\").unwrap();  // (1)!\n\n    // Find first match only\n    if let Some(first) = re.find(text) {  // (2)!\n        println!(\"{}\", first.as_str());  // \"2024\"\n    }\n\n    // Find all matches\n    let all: Vec&lt;&amp;str&gt; = re.find_iter(text)  // (3)!\n        .map(|m| m.as_str())  // (4)!\n        .collect();\n    println!(\"{:?}\", all);  // [\"2024\", \"12\", \"15\"]\n}\n</code></pre> <ol> <li><code>unwrap()</code> panics on invalid regex (prefer <code>?</code> in real code)</li> <li><code>find()</code> returns <code>Option&lt;Match&gt;</code> - use <code>if let</code> to handle</li> <li><code>find_iter()</code> returns iterator over all matches (lazy evaluation)</li> <li><code>map()</code> extracts string slice from each Match object</li> </ol> Find All vs Find First in Java<pre><code>import java.util.regex.*;\nimport java.util.*;\n\npublic class GlobalFlag {\n    public static void main(String[] args) {\n        String text = \"2024-12-15\";\n        Pattern pattern = Pattern.compile(\"\\\\d+\");  // (1)!\n        Matcher matcher = pattern.matcher(text);  // (2)!\n\n        // Find first match only\n        if (matcher.find()) {  // (3)!\n            System.out.println(matcher.group());  // \"2024\"\n        }\n\n        // Find all matches\n        matcher.reset();  // (4)!\n        List&lt;String&gt; all = new ArrayList&lt;&gt;();\n        while (matcher.find()) {  // (5)!\n            all.add(matcher.group());\n        }\n        System.out.println(all);  // [2024, 12, 15]\n    }\n}\n</code></pre> <ol> <li>Compile pattern once for reuse (throws <code>PatternSyntaxException</code> on invalid regex)</li> <li>Create Matcher object that performs operations on the input text</li> <li><code>find()</code> advances to next match each call (stateful operation)</li> <li><code>reset()</code> returns matcher to start of string for re-scanning</li> <li>Loop repeatedly calling <code>find()</code> to get all matches (Java's \"global\" approach)</li> </ol> Find All vs Find First in C++<pre><code>#include &lt;iostream&gt;\n#include &lt;regex&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::string text = \"2024-12-15\";\n    std::regex re(R\"(\\d+)\");  // (1)!\n\n    // Find first match only\n    std::smatch match;  // (2)!\n    if (std::regex_search(text, match, re)) {  // (3)!\n        std::cout &lt;&lt; match[0] &lt;&lt; std::endl;  // \"2024\"\n    }\n\n    // Find all matches\n    auto begin = std::sregex_iterator(text.begin(), text.end(), re);  // (4)!\n    auto end = std::sregex_iterator();  // (5)!\n    std::vector&lt;std::string&gt; all;\n    for (auto i = begin; i != end; ++i) {  // (6)!\n        all.push_back(i-&gt;str());\n    }\n    // Prints: 2024, 12, 15\n    for (const auto&amp; s : all) {\n        std::cout &lt;&lt; s &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <ol> <li>Raw string literal <code>R\"(...)\"</code> avoids escaping backslashes</li> <li><code>std::smatch</code> stores match results for strings (use <code>std::cmatch</code> for C-strings)</li> <li><code>regex_search</code> finds first match and populates match object</li> <li><code>sregex_iterator</code> iterates over all matches (begin points to first match)</li> <li>Default-constructed iterator serves as end sentinel</li> <li>Dereference iterator to get match_results, then call <code>str()</code> for matched text</li> </ol>"},{"location":"building_blocks/regular_expressions/#example-multiline-flag","title":"Example: Multiline Flag","text":"<p>Changes how <code>^</code> and <code>$</code> work:</p>  Python - Multiline JavaScript - Multiline Go - Multiline Rust - Multiline Java - Multiline C++ - Multiline Multiline Flag in Python<pre><code>import re\n\ntext = \"\"\"Line 1\nLine 2\nLine 3\"\"\"\n\n# Without MULTILINE: ^ matches only start of entire string\nmatches = re.findall(r'^Line', text)\nprint(matches)  # ['Line'] - only first line\n\n# With MULTILINE: ^ matches start of any line\nmatches = re.findall(r'^Line', text, re.MULTILINE)\nprint(matches)  # ['Line', 'Line', 'Line'] - all three lines\n</code></pre> Multiline Flag in JavaScript<pre><code>const text = `Line 1\nLine 2\nLine 3`;\n\n// Without m: ^ matches only start of entire string\n/^Line/              // Matches \"Line 1\" only\n\n// With m: ^ matches start of any line\n/^Line/m             // Matches at start of each line\n\n// Example with matchAll\nArray.from(text.matchAll(/^Line/gm))  // 3 matches\n</code></pre> Multiline Flag in Go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc main() {\n    text := `Line 1\nLine 2\nLine 3`\n\n    // Without multiline mode (default in Go is multiline)\n    // Go's regexp always treats ^ and $ as multiline\n    re := regexp.MustCompile(`(?m)^Line`)\n    matches := re.FindAllString(text, -1)\n    fmt.Println(matches)  // [Line Line Line]\n}\n</code></pre> Multiline Flag in Rust<pre><code>use regex::Regex;\n\nfn main() {\n    let text = \"Line 1\\nLine 2\\nLine 3\";\n\n    // Without multiline: ^ matches only start of entire string\n    let re = Regex::new(r\"^Line\").unwrap();\n    let count = re.find_iter(text).count();\n    println!(\"{}\", count);  // 1 - only first line\n\n    // With multiline: ^ matches start of any line\n    let re_multi = Regex::new(r\"(?m)^Line\").unwrap();\n    let count = re_multi.find_iter(text).count();\n    println!(\"{}\", count);  // 3 - all three lines\n}\n</code></pre> Multiline Flag in Java<pre><code>import java.util.regex.*;\n\npublic class MultilineFlag {\n    public static void main(String[] args) {\n        String text = \"Line 1\\nLine 2\\nLine 3\";\n\n        // Without MULTILINE: ^ matches only start of entire string\n        Pattern pattern = Pattern.compile(\"^Line\");\n        Matcher matcher = pattern.matcher(text);\n        int count = 0;\n        while (matcher.find()) count++;\n        System.out.println(count);  // 1\n\n        // With MULTILINE: ^ matches start of any line\n        Pattern multiPattern = Pattern.compile(\"^Line\", Pattern.MULTILINE);\n        Matcher multiMatcher = multiPattern.matcher(text);\n        count = 0;\n        while (multiMatcher.find()) count++;\n        System.out.println(count);  // 3\n    }\n}\n</code></pre> Multiline Flag in C++<pre><code>#include &lt;iostream&gt;\n#include &lt;regex&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string text = \"Line 1\\nLine 2\\nLine 3\";\n\n    // Without multiline (C++ default is NOT multiline)\n    std::regex re(\"^Line\");\n    auto begin = std::sregex_iterator(text.begin(), text.end(), re);\n    auto end = std::sregex_iterator();\n    std::cout &lt;&lt; std::distance(begin, end) &lt;&lt; std::endl;  // 1\n\n    // With multiline (use ECMAScript multiline syntax)\n    std::regex re_multi(\"^Line\", std::regex::multiline);\n    begin = std::sregex_iterator(text.begin(), text.end(), re_multi);\n    std::cout &lt;&lt; std::distance(begin, end) &lt;&lt; std::endl;  // 3\n    return 0;\n}\n</code></pre>"},{"location":"building_blocks/regular_expressions/#example-dotall-flag","title":"Example: Dotall Flag","text":"<p>Makes <code>.</code> match newlines:</p>  Python - Dotall JavaScript - Dotall Go - Dotall Rust - Dotall Java - Dotall C++ - Dotall Dotall Flag in Python<pre><code>import re\n\ntext = \"Hello\\nWorld\"\n\n# Without DOTALL: . doesn't match newlines\nmatch = re.search(r'Hello.World', text)\nprint(match)  # None\n\n# With DOTALL: . matches newlines too\nmatch = re.search(r'Hello.World', text, re.DOTALL)\nprint(match.group())  # \"Hello\\nWorld\"\n</code></pre> Dotall Flag in JavaScript<pre><code>const text = \"Hello\\nWorld\";\n\n// Without s: . doesn't match newlines\n/Hello.World/        // Doesn't match\n\n// With s: . matches newlines too\n/Hello.World/s       // Matches!\n\n// Using test()\n/Hello.World/s.test(text)  // true\n</code></pre> Dotall Flag in Go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"regexp\"\n)\n\nfunc main() {\n    text := \"Hello\\nWorld\"\n\n    // Without dotall: . doesn't match newlines (Go default)\n    re := regexp.MustCompile(`Hello.World`)\n    fmt.Println(re.MatchString(text))  // false\n\n    // With dotall: . matches newlines (use (?s) flag)\n    re_dotall := regexp.MustCompile(`(?s)Hello.World`)\n    fmt.Println(re_dotall.MatchString(text))  // true\n}\n</code></pre> Dotall Flag in Rust<pre><code>use regex::Regex;\n\nfn main() {\n    let text = \"Hello\\nWorld\";\n\n    // Without dotall: . doesn't match newlines\n    let re = Regex::new(r\"Hello.World\").unwrap();\n    println!(\"{}\", re.is_match(text));  // false\n\n    // With dotall: . matches newlines (use (?s) flag)\n    let re_dotall = Regex::new(r\"(?s)Hello.World\").unwrap();\n    println!(\"{}\", re_dotall.is_match(text));  // true\n}\n</code></pre> Dotall Flag in Java<pre><code>import java.util.regex.*;\n\npublic class DotallFlag {\n    public static void main(String[] args) {\n        String text = \"Hello\\nWorld\";\n\n        // Without DOTALL: . doesn't match newlines\n        Pattern pattern = Pattern.compile(\"Hello.World\");\n        Matcher matcher = pattern.matcher(text);\n        System.out.println(matcher.find());  // false\n\n        // With DOTALL: . matches newlines\n        Pattern dotallPattern = Pattern.compile(\"Hello.World\", Pattern.DOTALL);\n        Matcher dotallMatcher = dotallPattern.matcher(text);\n        System.out.println(dotallMatcher.find());  // true\n    }\n}\n</code></pre> Dotall Flag in C++<pre><code>#include &lt;iostream&gt;\n#include &lt;regex&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string text = \"Hello\\nWorld\";\n\n    // Without dotall: . doesn't match newlines (C++ default)\n    std::regex re(\"Hello.World\");\n    std::cout &lt;&lt; std::regex_search(text, re) &lt;&lt; std::endl;  // false (0)\n\n    // C++ doesn't have direct dotall flag\n    // Workaround: use [\\s\\S] instead of .\n    std::regex re_workaround(R\"(Hello[\\s\\S]World)\");\n    std::cout &lt;&lt; std::regex_search(text, re_workaround) &lt;&lt; std::endl;  // true (1)\n    return 0;\n}\n</code></pre> Concept Check 15: Case Insensitive Email <p>Modify the email pattern to match emails regardless of case (e.g., \"User@EXAMPLE.COM\").</p> Solution <p>JavaScript: <code>/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/i</code></p> <p>Python: <code>re.search(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$', email, re.I)</code></p> <p>The <code>i</code> flag makes the match case insensitive, so you don't need both <code>[a-z]</code> and <code>[A-Z]</code> anymore.</p>"},{"location":"building_blocks/regular_expressions/#practical-examples","title":"Practical Examples","text":"Email Address Phone Numbers IP Address Log Parsing Email Address Pattern<pre><code>^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\n</code></pre> Part Meaning <code>^</code> Start <code>[a-zA-Z0-9._%+-]+</code> Local part (one or more valid chars) <code>@</code> Literal @ <code>[a-zA-Z0-9.-]+</code> Domain name <code>\\.</code> Literal dot <code>[a-zA-Z]{2,}</code> TLD (at least 2 letters) <code>$</code> End Email Validation Reality <p>This regex is a simplification. The actual email spec (RFC 5322) is absurdly complex. \ud83e\udd2f In practice, just check for <code>@</code> and send a confirmation email.</p> US Phone Number Pattern (Simplified)<pre><code>^\\(?(\\d{3})\\)?[-.\\s]?(\\d{3})[-.\\s]?(\\d{4})$\n</code></pre> <p>Matches:</p> <ul> <li><code>5551234567</code></li> <li><code>555-123-4567</code></li> <li><code>(555) 123-4567</code></li> <li><code>555.123.4567</code></li> </ul> Mismatched Parentheses <p>This pattern has a flaw: it allows mismatched parentheses!</p> <p>Invalid matches it allows:</p> <ul> <li><code>(555-123-4567</code> (opening paren, no closing)</li> <li><code>555)-123-4567</code> (closing paren, no opening)</li> </ul> <p>Fixed version (requires both or neither):</p> Phone Number with Matched Parentheses<pre><code>^(\\d{3}|(\\(\\d{3}\\)))[-.\\s]?(\\d{3})[-.\\s]?(\\d{4})$\n</code></pre> <p>Or more explicitly with alternation:</p> Phone Number - Strict Parentheses<pre><code>^(\\(\\d{3}\\)|\\d{3})[-.\\s]?(\\d{3})[-.\\s]?(\\d{4})$\n</code></pre> <p>This says: \"Either <code>(555)</code> OR <code>555</code>, but not a mix.\"</p> IPv4 Address Pattern<pre><code>^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$\n</code></pre> This Isn't Perfect <p>This matches <code>999.999.999.999</code>, which isn't a valid IP. For true validation, you'd need <code>(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)</code> for each octet, or just parse the numbers and check in code.</p> Log Parsing Pattern<pre><code>^\\[(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\\] \\[(\\w+)\\] (.*)$\n</code></pre> <p>For: <code>[2024-03-15 14:30:45] [ERROR] Something went wrong</code></p> <ul> <li>Group 1: <code>2024-03-15 14:30:45</code></li> <li>Group 2: <code>ERROR</code></li> <li>Group 3: <code>Something went wrong</code></li> </ul>"},{"location":"building_blocks/regular_expressions/#regex-in-different-languages","title":"Regex in Different Languages","text":"<p>Most languages use similar syntax, with minor variations:</p>  Python - Usage JavaScript - Usage Rust - Usage Command Line (grep) Regular Expressions in Python<pre><code>import re\n\n# Search for pattern\nmatch = re.search(r'\\d+', 'Order 12345')  # (1)!\nprint(match.group())  # \"12345\"\n\n# Find all matches\nmatches = re.findall(r'\\d+', 'Items: 5, 10, 15')  # (2)!\nprint(matches)  # ['5', '10', '15']\n\n# Replace\nresult = re.sub(r'\\d+', 'X', 'Order 123')  # (3)!\nprint(result)  # \"Order X\"\n</code></pre> <ol> <li><code>search()</code> finds the first match in the string and returns a match object</li> <li><code>findall()</code> returns a list of all non-overlapping matches</li> <li><code>sub()</code> replaces all matches with a replacement string</li> </ol> Regular Expressions in JavaScript<pre><code>// Test if pattern matches\n/\\d+/.test('Order 12345')  // true  // (1)!\n\n// Find match\n'Order 12345'.match(/\\d+/)  // ['12345']  // (2)!\n\n// Replace\n'Order 123'.replace(/\\d+/, 'X')  // \"Order X\"  // (3)!\n</code></pre> <ol> <li><code>test()</code> returns boolean - true if pattern is found anywhere in string</li> <li><code>match()</code> returns array of matches (use <code>/g</code> flag for all matches)</li> <li><code>replace()</code> substitutes first match with replacement (use <code>/g</code> for all)</li> </ol> Regular Expressions in Rust<pre><code>use regex::Regex;  // (1)!\n\n// Search for pattern\nlet re = Regex::new(r\"\\d+\").unwrap();\nif let Some(mat) = re.find(\"Order 12345\") {  // (2)!\n    println!(\"{}\", mat.as_str());  // \"12345\"\n}\n\n// Find all matches\nlet caps: Vec&lt;&amp;str&gt; = re\n    .find_iter(\"Items: 5, 10, 15\")  // (3)!\n    .map(|m| m.as_str())\n    .collect();\nprintln!(\"{:?}\", caps);  // [\"5\", \"10\", \"15\"]\n\n// Replace\nlet result = re.replace_all(\"Order 123\", \"X\");  // (4)!\nprintln!(\"{}\", result);  // \"Order X\"\n</code></pre> <ol> <li>Requires <code>regex</code> crate: add <code>regex = \"1\"</code> to <code>Cargo.toml</code></li> <li><code>find()</code> returns <code>Option&lt;Match&gt;</code> for the first match</li> <li><code>find_iter()</code> returns an iterator over all matches</li> <li><code>replace_all()</code> substitutes all matches with replacement string</li> </ol> Regular Expressions in grep<pre><code># Find lines containing \"error\"\ngrep -E 'error' logfile.txt\n\n# Find lines starting with a date\ngrep -E '^[0-9]{4}-[0-9]{2}-[0-9]{2}' logfile.txt\n</code></pre>"},{"location":"building_blocks/regular_expressions/#the-connection-to-theory","title":"The Connection to Theory","text":"<p>Remember how we said FSMs and regular expressions describe the same languages? Here's the connection:</p> Regex FSM Equivalent <code>ab</code> Sequence of states <code>a|b</code> Branch (two paths from same state) <code>a*</code> Loop back to same state <code>a+</code> Transition + loop <code>a?</code> Optional path (epsilon transition) <p>Every regex can be converted to an NFA (Non-deterministic Finite Automaton), then to a DFA (Deterministic Finite Automaton), then executed efficiently. That's what regex engines do under the hood.</p> <p>Example: The regex <code>ab*c</code> converts to this FSM:</p> <pre><code>stateDiagram-v2\n    direction LR\n\n    [*] --&gt; S0\n    S0 --&gt; S1: a\n    S1 --&gt; S1: b\n    S1 --&gt; S2: c\n    S2 --&gt; [*]</code></pre> <ul> <li>Start at S0</li> <li>Read 'a' \u2192 move to S1</li> <li>Read zero or more 'b's \u2192 loop on S1</li> <li>Read 'c' \u2192 move to S2 (accepting state)</li> </ul>"},{"location":"building_blocks/regular_expressions/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"building_blocks/regular_expressions/#catastrophic-backtracking","title":"Catastrophic Backtracking","text":"<p>Some patterns cause exponential backtracking:</p> Catastrophic Backtracking<pre><code>(a+)+b\n</code></pre> <p>Against a string like <code>aaaaaaaaaaaaaaaaac</code>, the engine tries every possible way to divide the a's among the groups\u2014and there are exponentially many. This can freeze your program. \u2744\ufe0f Not fun.</p> <p>Solutions:</p> <ol> <li>Refactor to avoid nested quantifiers (universal solution):</li> </ol> Avoiding Nested Quantifiers<pre><code># Bad - nested quantifiers\n(a+)+b\n\n# Better - single quantifier\na+b\n</code></pre> <ol> <li>Use atomic groups (advanced, not supported everywhere):</li> </ol> <p>An atomic group <code>(?&gt;...)</code> matches like a normal group, but once it succeeds, the regex engine \"commits\" to that match and won't backtrack into it.</p> <p>How it works:</p> <ul> <li>Normal group <code>(a+)</code>: If the overall pattern fails, the engine can backtrack and try matching fewer a's</li> <li>Atomic group <code>(?&gt;a+)</code>: Once matched, the engine won't reconsider - it's \"locked in\"</li> </ul> <p>Example:</p> Atomic Groups<pre><code># Without atomic group - catastrophic backtracking\n(a+)+b    # Against \"aaaaaac\", tries every way to split a's\n\n# With atomic group - no backtracking inside\n(?&gt;a+)+b  # Matches all a's in one chunk, can't backtrack into it\n</code></pre> <p>The atomic group prevents the exponential backtracking by saying \"once I've matched the a's, I'm done - don't try different ways to split them up.\"</p> <ol> <li>Use possessive quantifiers (advanced, limited support):</li> </ol> <p>Possessive quantifiers (<code>*+</code>, <code>++</code>, <code>?+</code>) work like atomic groups but with shorter syntax - they match and don't give back:</p> Possessive Quantifiers<pre><code># Possessive quantifier - no backtracking\na++b\n</code></pre> Limited Support <p>Atomic groups and possessive quantifiers are not supported in all regex engines. JavaScript doesn't support them at all. Stick with solution #1 (refactoring) for maximum compatibility.</p>"},{"location":"building_blocks/regular_expressions/#forgetting-anchors","title":"Forgetting Anchors","text":"Without Anchors<pre><code>\\d{3}-\\d{4}\n</code></pre> <p>This matches \"555-1234\" inside \"call 555-1234 now\". If you want exact matches, use anchors:</p> With Anchors<pre><code>^\\d{3}-\\d{4}$\n</code></pre>"},{"location":"building_blocks/regular_expressions/#escaping-special-characters","title":"Escaping Special Characters","text":"<p>To match literal special characters, escape them:</p> Escaped Special Characters<pre><code>\\.\\*\\+\\?\\[\\]\\(\\)\\{\\}\\^\\$\\|\\\\\n</code></pre> <p>Or use a character class where most specials are literal:</p> Special Characters in Character Class<pre><code>[.*+?]  # Matches literal ., *, +, or ?\n</code></pre>"},{"location":"building_blocks/regular_expressions/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: URL Validation <p>Write a regex that matches HTTP/HTTPS URLs like:</p> <ul> <li><code>https://example.com</code></li> <li><code>http://sub.domain.org/path</code></li> <li><code>https://site.io/page?id=123</code></li> </ul> Practice Problem 2: Date Formats <p>Match dates in YYYY-MM-DD format where:</p> <ul> <li>Year is 4 digits</li> <li>Month is 01-12</li> <li>Day is 01-31</li> </ul> <p>Bonus: Can you ensure month doesn't exceed 12?</p> Practice Problem 3: Find Duplicates <p>Write a regex that finds repeated consecutive words in text, like \"the the\" or \"is is\".</p> <p>Hint: Use backreferences.</p>"},{"location":"building_blocks/regular_expressions/#key-takeaways","title":"Key Takeaways","text":"Concept Syntax Example Any character <code>.</code> <code>a.c</code> matches \"abc\", \"a1c\" Character class <code>[...]</code> <code>[aeiou]</code> matches vowels Negated class <code>[^...]</code> <code>[^0-9]</code> matches non-digits Zero or more <code>*</code> <code>a*</code> matches \"\", \"a\", \"aaa\" One or more <code>+</code> <code>a+</code> matches \"a\", \"aaa\" Optional <code>?</code> <code>colou?r</code> matches both spellings Alternation <code>\\|</code> <code>cat\\|dog</code> matches either Group <code>(...)</code> <code>(ab)+</code> matches \"ab\", \"abab\" Word boundary <code>\\b</code> <code>\\bword\\b</code> matches whole word"},{"location":"building_blocks/regular_expressions/#further-reading","title":"Further Reading","text":"<ul> <li>Finite State Machines \u2014 The theory behind regex</li> <li>How Parsers Work \u2014 How regex fits into lexical analysis and parsing</li> <li>Regular Expressions 101 \u2014 Interactive regex tester</li> <li>Backus-Naur Form \u2014 When regex isn't powerful enough</li> </ul> <p>Regular expressions are a superpower with a steep learning curve. They look like line noise until suddenly they don't\u2014and then you'll find yourself reaching for them constantly. The trick is to build them up piece by piece, test frequently, and resist the urge to write everything in one inscrutable line. Your future self will thank you. \ud83c\udfaf</p>"},{"location":"building_blocks/regular_expressions/#video-summary","title":"Video Summary","text":""},{"location":"building_blocks/scheme_and_parse_trees/","title":"Scheme & Parse Trees","text":""},{"location":"building_blocks/scheme_and_parse_trees/#description-why-lisp-and-scheme-use-parentheses-understanding-prefix-notation-and-parse-trees","title":"description: Why Lisp and Scheme use parentheses: Understanding prefix notation and parse trees.","text":""},{"location":"building_blocks/scheme_and_parse_trees/#scheme-lisp-and-parse-trees","title":"Scheme, Lisp, and Parse Trees","text":"<p>When you write <code>3 + 4 * 5</code> in mathematics, everyone agrees it means <code>3 + (4 * 5) = 23</code>, not <code>(3 + 4) * 5 = 35</code>. Operator precedence rules\u2014memorized through years of schooling\u2014determine this. But what if there were a notation that never needed precedence rules? What if the structure of the expression itself made evaluation order crystal clear?</p> <p>Enter Lisp and its dialect Scheme: languages where parentheses aren't decorative\u2014they're structural. Where <code>(+ 3 (* 4 5))</code> is unambiguous. Where the written form directly reflects the parse tree that represents it.</p> <p>Understanding Scheme's prefix notation and its parse trees reveals something profound: the notation you choose shapes how you think about computation.</p> The Lisp Family: A Quick Map <p>If you\u2019ve heard of Emacs Lisp (Elisp) or Common Lisp, you\u2019re looking at the same family tree. Lisp isn\u2019t a single language, but a lineage of dialects that share the same \"code is data\" DNA.</p> <ul> <li>Common Lisp: The \"industrial\" version\u2014massive, feature-rich, and standardized.</li> <li>Emacs Lisp (Elisp): The specialized dialect used to build and extend the Emacs text editor. (Yes, the editor is mostly written in its own language.)</li> <li>Scheme: The \"academic\" version\u2014minimalist, elegant, and the focus of this article.</li> </ul> <p>We use Scheme because its syntax is so stripped-down that you can\u2019t help but see the underlying structure of the computation.</p>"},{"location":"building_blocks/scheme_and_parse_trees/#what-is-scheme","title":"What is Scheme?","text":"<p>In most programming languages, you write:</p> <pre><code>3 + 4\n</code></pre> <p>This is infix notation\u2014the operator (<code>+</code>) sits between its operands.</p> <p>In Scheme, you write:</p> <pre><code>(+ 3 4)\n</code></pre> <p>This is prefix notation\u2014the operator comes first, followed by its operands.</p> <p>Comparison:</p> Notation Addition Multiplication Nested Infix <code>3 + 4</code> <code>4 * 5</code> <code>3 + 4 * 5</code> Prefix (Scheme) <code>(+ 3 4)</code> <code>(* 4 5)</code> <code>(+ 3 (* 4 5))</code>"},{"location":"building_blocks/scheme_and_parse_trees/#why-prefix-notation","title":"Why Prefix Notation?","text":"<p>Advantages:</p> <ol> <li>No precedence rules needed: Parentheses make structure explicit</li> <li>Uniform syntax: Everything is <code>(function arg1 arg2 ...)</code></li> <li>Easy to parse: No need for precedence-climbing or shunting-yard algorithms</li> <li>Variable number of arguments: <code>(+ 1 2 3 4 5)</code> works naturally</li> </ol> <p>Disadvantages:</p> <ol> <li>Unfamiliar: Humans learn infix in school</li> <li>Lots of parentheses: Can be harder to read for complex expressions</li> </ol>"},{"location":"building_blocks/scheme_and_parse_trees/#s-expressions","title":"S-Expressions","text":"<p>The term S-expression (symbolic expression) sounds complex, but it describes a very simple, recursive structure.</p> <p>Think of it like a system of nested boxes:</p> <ol> <li>Atoms: These are the contents. A number (<code>42</code>) or a symbol (<code>+</code>) is an atom. It cannot be split further.</li> <li>Lists: These are the boxes. A list is wrapped in parentheses <code>( ... )</code>.</li> </ol> <p>The Golden Rule: A list can contain atoms, or it can contain other lists.</p> Type Definition Examples Atom A fundamental unit (number, symbol, string) <code>42</code>, <code>x</code>, <code>+</code>, <code>\"hello\"</code> List A container holding zero or more S-expressions <code>(1 2 3)</code>, <code>(a (b c) d)</code>, <code>()</code> <p>Because lists can contain lists, you naturally build a tree structure.</p>"},{"location":"building_blocks/scheme_and_parse_trees/#visualizing-s-expressions","title":"Visualizing S-Expressions","text":"<p>Consider the S-expression: <code>(* (+ 1 2) 3)</code></p> <p>It is a List containing three things:</p> <ol> <li>Atom: <code>*</code></li> <li>List: <code>(+ 1 2)</code> (which itself contains three atoms)</li> <li>Atom: <code>3</code></li> </ol> <p>If we draw this hierarchy, it is identical to a tree:</p> <pre><code>graph TD\n    Root[List: * ... 3] --&gt; Atom1[\"Atom: *\"]\n    Root --&gt; InnerList[List: + 1 2]\n    Root --&gt; Atom2[\"Atom: 3\"]\n    InnerList --&gt; Atom3[\"Atom: +\"]\n    InnerList --&gt; Atom4[\"Atom: 1\"]\n    InnerList --&gt; Atom5[\"Atom: 2\"]\n\n    style Root fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style InnerList fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre>"},{"location":"building_blocks/scheme_and_parse_trees/#why-symbolic","title":"Why \"Symbolic\"?","text":"<p>In most languages (like C or Java), variable names like <code>x</code> or <code>calculate</code> disappear when you compile the code\u2014they turn into memory addresses.</p> <p>In an S-expression, symbols (words like <code>x</code>, <code>foo</code>, <code>+</code>) are distinct data types, just like numbers. The language can manipulate words and names as easily as it manipulates math. This is why it's called a Symbolic Expression.</p> Under the Hood: How does the CPU handle symbols? <p>In languages like C, a variable name like <code>radius</code> is completely erased during compilation and replaced with a memory address (e.g., <code>0x7ffe...</code>). The CPU only sees the address.</p> <p>In Lisp/Scheme, symbols persist during execution because the language uses an Environment: a giant lookup table in memory.</p> <ol> <li>The Environment: When you call <code>(square 7)</code>, the language looks up the symbol <code>square</code> in its table to find the code it needs to run.</li> <li>Pointers: To keep this fast, the language \"interns\" symbols. Every instance of <code>x</code> in your code points to the exact same \"Symbol Object\" in memory. The CPU doesn't compare the string \"x\"; it just compares the memory pointers to see if they match.</li> <li>Code as Data: Because symbols aren't erased, a Lisp program can read its own source code, move symbols around, and even generate new functions while it is running.</li> </ol> <p>Examples of valid S-expressions:</p> <pre><code>42                  ; Atom (number)\nhello               ; Atom (symbol)\n(1 2 3)             ; List of three atoms\n(+ 1 2)             ; List (function call)\n(+ (* 2 3) 4)       ; List containing another list (nested)\n()                  ; The Empty List (also called \"nil\")\n</code></pre>"},{"location":"building_blocks/scheme_and_parse_trees/#lists-as-code","title":"Lists as Code","text":"<p>In Scheme, code is lists. A function call is a list where:</p> <ul> <li>The first element is the function (operator)</li> <li>Remaining elements are arguments (operands)</li> </ul> <pre><code>(+ 1 2)             ; Call function + with arguments 1 and 2\n(* 3 4)             ; Call function * with arguments 3 and 4\n(- 10 5)            ; Call function - with arguments 10 and 5\n</code></pre> <p>This homoiconicity (code as data) makes Lisp/Scheme uniquely powerful for metaprogramming\u2014programs that manipulate programs.</p> Common Misconception: Code vs. Data <p>When we say \"Code is Data,\" we don't mean hardcoding (mixing magic numbers or strings into your logic), which is generally bad practice.</p> <p>We mean that the structure of the program is exposed as a data structure you can edit.</p> <ul> <li>In Python/Java: Code is text. To change it, you have to cut and paste strings.</li> <li>In Lisp: Code is a List. You can use standard list functions (like <code>map</code> or <code>reverse</code>) to rewrite your own program while it is loading. This allows you to add new features to the language (like loops or classes) without waiting for the compiler developers to add them.</li> </ul>"},{"location":"building_blocks/scheme_and_parse_trees/#special-forms-breaking-the-rules","title":"Special Forms: Breaking the Rules","text":"<p>There is one catch. Normally, Scheme evaluates all arguments before passing them to a function. But some things, like defining variables, wouldn't work if we did that.</p> <pre><code>(define x 10)\n</code></pre> <p>If <code>define</code> were a normal function, Scheme would try to find the value of <code>x</code> before running the line. But <code>x</code> doesn't exist yet!</p> <p>To handle this, Scheme has Special Forms (like <code>define</code>, <code>if</code>, and <code>quote</code>) that have their own custom evaluation rules. They don't evaluate all their arguments.</p>"},{"location":"building_blocks/scheme_and_parse_trees/#reading-scheme-expressions","title":"Reading Scheme Expressions","text":"<p>Let's build intuition by reading Scheme expressions aloud.</p>  Simple Nested Complex <pre><code>(+ 5 6)\n</code></pre> <p>Read as: \"Add 5 and 6\" Evaluates to: <code>11</code></p> <pre><code>(* 7 8)\n</code></pre> <p>Read as: \"Multiply 7 and 8\" Evaluates to: <code>56</code></p> <pre><code>(+ (+ 5 6) (* 7 8))\n</code></pre> <p>Read as: \"Add the result of (add 5 and 6) to the result of (multiply 7 and 8)\"</p> <p>Step-by-step evaluation:</p> <ol> <li>Evaluate inner expressions first:</li> <li><code>(+ 5 6)</code> \u2192 <code>11</code></li> <li><code>(* 7 8)</code> \u2192 <code>56</code></li> <li>Substitute results: <code>(+ 11 56)</code></li> <li>Evaluate outer expression: <code>67</code></li> </ol> <p>Key Insight</p> <p>The structure of nested parentheses directly mirrors the evaluation order. Innermost expressions evaluate first, working outward.</p> <pre><code>(+ (* 2 3) (- 10 4) 5)\n</code></pre> <p>Read as: \"Add the result of (multiply 2 and 3), the result of (subtract 4 from 10), and 5\"</p> <p>Evaluation:</p> <ol> <li><code>(* 2 3)</code> \u2192 <code>6</code></li> <li><code>(- 10 4)</code> \u2192 <code>6</code></li> <li><code>(+ 6 6 5)</code> \u2192 <code>17</code></li> </ol> <p>Notice: <code>+</code> can take more than two arguments in Scheme\u2014another advantage of prefix notation.</p>"},{"location":"building_blocks/scheme_and_parse_trees/#parse-trees-for-scheme","title":"Parse Trees for Scheme","text":"<p>A parse tree (or abstract syntax tree, AST) represents the grammatical structure of an expression as a tree.</p> <p>For Scheme, the correspondence between written form and parse tree is particularly direct\u2014parentheses literally define tree structure.</p>  Simple Tree Nested Tree Drawing Algorithm <p>Expression: <code>(+ 5 6)</code></p> <p>Structure: - Root: The operator <code>+</code> - Children: The operands <code>5</code> and <code>6</code></p> <pre><code>graph TD\n    Plus[\"+\"] --&gt; Five[\"5\"]\n    Plus --&gt; Six[\"6\"]\n\n    style Plus fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Five fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Six fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>Expression: <code>(+ (+ 5 6) (* 7 8))</code></p> <p>Structure: - Root: Outer <code>+</code> operator - Left subtree: <code>(+ 5 6)</code> - Right subtree: <code>(* 7 8)</code></p> <pre><code>graph TD\n    RootPlus[\"+\"] --&gt; LeftPlus[\"+\"]\n    RootPlus --&gt; RightTimes[\"*\"]\n    LeftPlus --&gt; Five[\"5\"]\n    LeftPlus --&gt; Six[\"6\"]\n    RightTimes --&gt; Seven[\"7\"]\n    RightTimes --&gt; Eight[\"8\"]\n\n    style RootPlus fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style LeftPlus fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style RightTimes fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Five fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Six fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Seven fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Eight fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>Evaluation order (post-order traversal):</p> <ol> <li>Evaluate left subtree: <code>5 + 6 = 11</code></li> <li>Evaluate right subtree: <code>7 * 8 = 56</code></li> <li>Evaluate root: <code>11 + 56 = 67</code></li> </ol> <p>How to draw a parse tree from Scheme:</p> <ol> <li>The outermost parentheses define the root node (the operator)</li> <li>Each argument becomes a child</li> <li>If an argument is itself a list (nested expression), recurse</li> </ol> <p>Example: <code>(* (+ 3 4) (- 10 5) 2)</code></p> <p><pre><code>graph TD\n    Times[\"*\"] --&gt; Plus[\"+\"]\n    Times --&gt; Minus[\"-\"]\n    Times --&gt; Two[\"2\"]\n    Plus --&gt; Three[\"3\"]\n    Plus --&gt; Four[\"4\"]\n    Minus --&gt; Ten[\"10\"]\n    Minus --&gt; Five[\"5\"]\n\n    style Times fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Plus fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Minus fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Two fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Three fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Four fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Ten fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Five fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> Evaluation:</p> <ol> <li><code>(+ 3 4)</code> \u2192 <code>7</code></li> <li><code>(- 10 5)</code> \u2192 <code>5</code></li> <li><code>(* 7 5 2)</code> \u2192 <code>70</code></li> </ol>"},{"location":"building_blocks/scheme_and_parse_trees/#evaluation-order-post-order-traversal","title":"Evaluation Order: Post-Order Traversal","text":"<p>Scheme expressions evaluate using post-order traversal:</p> <ol> <li>Evaluate left subtree</li> <li>Evaluate right subtree</li> <li>Apply operator at root</li> </ol> <p>This ensures arguments are computed before the function that uses them\u2014a fundamental principle in most programming languages.</p>"},{"location":"building_blocks/scheme_and_parse_trees/#example-5-6-7-8","title":"Example: <code>(+ (+ 5 6) (* 7 8))</code>","text":"<p>Tree:</p> <pre><code>       +\n      / \\\n     +   *\n    / \\ / \\\n   5  6 7  8\n</code></pre> <p>Post-order traversal:</p> <ol> <li>Visit left subtree (<code>+</code>):</li> <li>Visit <code>5</code> (leaf) \u2192 value is <code>5</code></li> <li>Visit <code>6</code> (leaf) \u2192 value is <code>6</code></li> <li>Apply <code>+</code> \u2192 <code>5 + 6 = 11</code></li> <li>Visit right subtree (<code>*</code>):</li> <li>Visit <code>7</code> (leaf) \u2192 value is <code>7</code></li> <li>Visit <code>8</code> (leaf) \u2192 value is <code>8</code></li> <li>Apply <code>*</code> \u2192 <code>7 * 8 = 56</code></li> <li>Visit root (<code>+</code>):</li> <li>Apply <code>+</code> to results \u2192 <code>11 + 56 = 67</code></li> </ol> <p>Result: <code>67</code></p> <p>The tree structure guarantees correct evaluation order\u2014no precedence rules needed.</p>"},{"location":"building_blocks/scheme_and_parse_trees/#the-ambiguity-problem","title":"The Ambiguity Problem","text":"<p>Why did Lisp choose such a strange notation? To eliminate ambiguity.</p> <p>Infix notation (standard math) is inherently ambiguous. Consider:</p> <p><code>3 + 4 * 5</code></p> <p>Does this mean <code>(3 + 4) * 5</code> or <code>3 + (4 * 5)</code>?</p> <p>To solve this, we rely on Precedence Rules (PEMDAS). You have to memorize that <code>*</code> beats <code>+</code>. These are \"invisible parentheses\" that the parser adds for you. Scheme removes the need for invisible rules by forcing you to make the structure explicit.</p>  Infix (Implicit) Prefix (Explicit) <p>Expression: <code>3 + 4 * 5</code></p> <p>The Problem: Who owns the <code>4</code>? Does <code>+</code> claim it, or does <code>*</code> claim it? The notation doesn't say.</p> <p>The Fix: We apply an arbitrary rule: \"Multiplication before Addition.\" We need a lookup table of rules to read the code.</p> <p>The Hidden Tree: The computer implicitly builds this tree based on the rulebook:</p> <pre><code>graph TD\n    T1[\"3\"] --- T2[\"+\"] --- T3[\"4\"] --- T4[\"*\"] --- T5[\"5\"]\n\n    subgraph Rules [\"The Rulebook (PEMDAS)\"]\n        R1[\"Rule: * beats +\"]\n    end\n\n    Plus[\"+\"] --&gt; Three[\"3\"]\n    Plus --&gt; Times[\"*\"]\n    Times --&gt; Four[\"4\"]\n    Times --&gt; Five[\"5\"]\n\n    T3 --&gt; Rules\n    Rules -.-&gt; Plus\n\n    style Plus fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Times fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Rules fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style R1 fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>Expression: <code>(+ 3 (* 4 5))</code></p> <p>The Solution: There is no question about who owns the <code>4</code>. It is physically inside the <code>(* ...)</code> list. The structure is undeniable.</p> <p>The Explicit Tree: The notation maps 1:1 to the tree.</p> <pre><code>graph TD\n    Plus[\"+\"] --&gt; Three[\"3\"]\n    Plus --&gt; Times[\"*\"]\n    Times --&gt; Four[\"4\"]\n    Times --&gt; Five[\"5\"]\n    style Plus fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Times fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre>"},{"location":"building_blocks/scheme_and_parse_trees/#why-parsers-love-prefix","title":"Why Parsers Love Prefix","text":"<p>The difference in complexity is staggering when you try to write a program to read these expressions.</p> <p>Parsing Infix (<code>3 + 4 * 5</code>) requires:</p> <ol> <li>Tokenizing: Breaking string into parts.</li> <li>Precedence Logic: Knowing <code>*</code> &gt; <code>+</code>.</li> <li>Associativity Logic: Knowing <code>1 - 2 - 3</code> is <code>(1 - 2) - 3</code>.</li> <li>Complex Algorithms: Shunting-yard (Dijkstra) or Operator-precedence parsing.</li> </ol> <p>Parsing Prefix (<code>(+ 3 (* 4 5))</code>) requires:</p> <ol> <li>Tokenizing.</li> <li>Recursion: \"See a paren? Start a new node.\"</li> </ol> <p>There is no Step 3 or 4. The parser is trivial:</p> Simple Scheme Parser<pre><code>def parse(tokens):  # (1)!\n    token = tokens.pop(0)\n    if token == '(':\n        operator = tokens.pop(0)  # (3)!\n        operands = []\n        while tokens[0] != ')':  # (4)!\n            operands.append(parse(tokens))  # (5)!\n        tokens.pop(0)  # (6)!\n        return (operator, operands)\n    else:\n        return int(token)  # (7)!\n</code></pre> <ol> <li>Recursively parse a list of tokens</li> <li>If we see an opening paren, we're starting a new expression</li> <li>First token after '(' is the operator</li> <li>Collect all operands until we hit the closing paren</li> <li>Each operand might itself be an expression, so recurse</li> <li>Consume the closing paren</li> <li>Base case: if it's not a paren, it's a number (or symbol)</li> </ol> <p>No precedence table needed. Structure is explicit.</p>"},{"location":"building_blocks/scheme_and_parse_trees/#historical-context","title":"Historical Context","text":"The Birth of Lisp Scheme Influence <p>Lisp was created by John McCarthy in 1958 at MIT as part of his research on artificial intelligence. McCarthy wanted a language that:</p> <ul> <li>Could manipulate symbolic expressions (not just numbers)</li> <li>Treated code as data (enabling metaprogramming)</li> <li>Supported recursive functions naturally</li> </ul> <p>S-expressions were McCarthy's solution\u2014simple, uniform, and powerful.</p> <p>Scheme emerged from MIT in 1975 as Guy Steele and Gerald Sussman explored \u03bb-calculus and programming language semantics. They wanted a \"purer\" Lisp:</p> <ul> <li>Lexical scoping (instead of dynamic)</li> <li>First-class continuations</li> <li>Tail-call optimization</li> <li>Minimalist design</li> </ul> <p>Scheme's simplicity made it ideal for teaching and research, culminating in the influential textbook Structure and Interpretation of Computer Programs (SICP) by Abelson and Sussman (1984).</p> <p>Lisp's ideas permeate modern programming:</p> <ul> <li>Garbage collection: Pioneered by Lisp (McCarthy, 1960)</li> <li>First-class functions: Lisp made them mainstream</li> <li>Closures: Scheme formalized them</li> <li>Dynamic typing: Common in scripting languages</li> <li>Homoiconicity: Inspired Clojure, Julia's metaprogramming</li> </ul> <p>Even languages that don't look like Lisp (JavaScript, Python, Ruby) adopted its core ideas.</p>"},{"location":"building_blocks/scheme_and_parse_trees/#scheme-in-action","title":"Scheme in Action","text":"Basic Arithmetic Variables &amp; Functions Control Flow Recursion <p>Scheme arithmetic supports variable arguments naturally.</p> <pre><code>(+ 1 2 3 4 5)       ; 15 (variadic function)\n(* 2 3 4)           ; 24\n(- 10 3)            ; 7\n(/ 20 4)            ; 5\n</code></pre> <p>Nested Arithmetic:</p> <pre><code>(+ (* 2 3) (/ 10 2) (- 8 3))\n; Evaluates to: (+ 6 5 5) \u2192 16\n</code></pre> <p>Definitions use <code>define</code>. Notice how defining a function looks just like calling it, but with a body.</p> <pre><code>(define pi 3.14159)\n(define radius 5)\n(* pi (* radius radius))    ; Area of circle: 78.53975\n</code></pre> <p>Defining Functions:</p> <pre><code>(define (square x)\n  (* x x))\n\n(square 7)          ; 49\n</code></pre> <p>Scheme uses <code>if</code> for conditional logic. It returns a value (like the ternary operator <code>? :</code> in C-style languages) rather than executing statements.</p> <pre><code>(define (abs x)\n  (if (&lt; x 0)\n      (- x)\n      x))\n\n(abs -5)            ; 5\n(abs 3)             ; 3\n</code></pre> <p>Recursion is the primary way to loop in Scheme.</p> <pre><code>(define (factorial n)\n  (if (&lt;= n 1)\n      1\n      (* n (factorial (- n 1)))))\n\n(factorial 5)       ; 120\n</code></pre> Recursion and the Call Stack <p>Every recursive call relies on the function call stack\u2014a fundamental data structure that manages function execution.</p> <p>When <code>(factorial 5)</code> runs, the stack grows with each recursive call: <pre><code>factorial(5)\n  \u2192 factorial(4)\n    \u2192 factorial(3)\n      \u2192 factorial(2)\n        \u2192 factorial(1)  \u2190 base case reached, starts returning\n</code></pre></p> <p>Each call waits on the stack until its nested call completes, then pops off and returns its result. This LIFO behavior is what makes recursion possible.</p>"},{"location":"building_blocks/scheme_and_parse_trees/#why-study-scheme","title":"Why Study Scheme?","text":"<p>You might reasonably ask: why learn Scheme when modern languages like Python, JavaScript, or Rust dominate industry?</p>  Conceptual Clarity Understanding Parsers Functional Programming Historical Perspective Academic Rigor <p>Scheme strips away syntax complexity, letting you focus on computational concepts:</p> <ul> <li>Recursion without boilerplate</li> <li>Higher-order functions without ceremony</li> <li>Closures and scope made explicit</li> </ul> <p>Scheme's direct mapping from text to parse tree demystifies how languages work. Once you see how prefix notation avoids precedence, you understand why parsing infix is hard.</p> <p>Scheme is functional-first, teaching patterns now common in JavaScript, Python, Haskell, and Rust:</p> <ul> <li><code>map</code>, <code>filter</code>, <code>reduce</code></li> <li>Immutability</li> <li>Function composition</li> </ul> <p>Understanding Lisp/Scheme helps you appreciate language evolution. Many \"modern\" features (lambdas, closures, garbage collection) were invented in Lisp decades ago.</p> <p>Scheme's minimalism makes it perfect for studying:</p> <ul> <li>Programming language semantics</li> <li>Interpreters and compilers</li> <li>Type theory and \u03bb-calculus</li> </ul> <p>MIT's SICP remains a gold standard in CS education precisely because Scheme gets out of the way, letting ideas shine through.</p>"},{"location":"building_blocks/scheme_and_parse_trees/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Reading Scheme <p>What does this Scheme expression evaluate to?</p> <pre><code>(+ (* 3 4) (- 10 2) 5)\n</code></pre> <p>Show the evaluation steps.</p> Solution <p>Expression: <code>(+ (* 3 4) (- 10 2) 5)</code></p> <p>Step 1: Evaluate subexpressions</p> <ul> <li><code>(* 3 4)</code> \u2192 <code>12</code></li> <li><code>(- 10 2)</code> \u2192 <code>8</code></li> </ul> <p>Step 2: Substitute results</p> <ul> <li><code>(+ 12 8 5)</code></li> </ul> <p>Step 3: Evaluate outer expression</p> <ul> <li><code>12 + 8 + 5 = 25</code></li> </ul> <p>Answer: <code>25</code></p> Practice Problem 2: Convert Infix to Prefix <p>Convert this infix expression to Scheme prefix notation:</p> <pre><code>(5 + 6) * (7 - 2)\n</code></pre> <p>Then draw the parse tree.</p> Solution <p>Infix: <code>(5 + 6) * (7 - 2)</code></p> <p>Prefix (Scheme): <code>(* (+ 5 6) (- 7 2))</code></p> <p>Parse Tree:</p> <pre><code>graph TD\n    Times[\"*\"] --&gt; Plus[\"+\"]\n    Times --&gt; Minus[\"-\"]\n    Plus --&gt; Five[\"5\"]\n    Plus --&gt; Six[\"6\"]\n    Minus --&gt; Seven[\"7\"]\n    Minus --&gt; Two[\"2\"]\n\n    style Times fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Plus fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Minus fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Five fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Six fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Seven fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Two fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>Evaluation:</p> <ol> <li><code>(+ 5 6)</code> \u2192 <code>11</code></li> <li><code>(- 7 2)</code> \u2192 <code>5</code></li> <li><code>(* 11 5)</code> \u2192 <code>55</code></li> </ol> <p>Answer: <code>55</code></p> Practice Problem 3: Draw Parse Tree <p>Draw the parse tree for this Scheme expression:</p> <pre><code>(+ (+ 5 6) (* 7 8))\n</code></pre> <p>Then trace the post-order evaluation.</p> Solution <p>Parse Tree:</p> <pre><code>graph TD\n    RootPlus[\"+\"] --&gt; LeftPlus[\"+\"]\n    RootPlus --&gt; RightTimes[\"*\"]\n    LeftPlus --&gt; Five[\"5\"]\n    LeftPlus --&gt; Six[\"6\"]\n    RightTimes --&gt; Seven[\"7\"]\n    RightTimes --&gt; Eight[\"8\"]\n\n    style RootPlus fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style LeftPlus fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style RightTimes fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Five fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Six fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Seven fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Eight fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>Post-Order Evaluation:</p> <ol> <li>Visit left subtree (<code>+</code>):</li> <li>Visit <code>5</code> \u2192 <code>5</code></li> <li>Visit <code>6</code> \u2192 <code>6</code></li> <li>Apply <code>+</code> \u2192 <code>5 + 6 = 11</code></li> <li>Visit right subtree (<code>*</code>):</li> <li>Visit <code>7</code> \u2192 <code>7</code></li> <li>Visit <code>8</code> \u2192 <code>8</code></li> <li>Apply <code>*</code> \u2192 <code>7 * 8 = 56</code></li> <li>Visit root (<code>+</code>):</li> <li>Apply <code>+</code> \u2192 <code>11 + 56 = 67</code></li> </ol> <p>Answer: <code>67</code></p> Practice Problem 4: Complex Nesting <p>Evaluate this Scheme expression step-by-step:</p> <pre><code>(* (+ 1 2) (- 10 (/ 8 2)) (+ 3 3))\n</code></pre> Solution <p>Expression: <code>(* (+ 1 2) (- 10 (/ 8 2)) (+ 3 3))</code></p> <p>Step 1: Evaluate innermost subexpressions</p> <ul> <li><code>(/ 8 2)</code> \u2192 <code>4</code></li> </ul> <p>Step 2: Substitute and evaluate next level</p> <ul> <li><code>(+ 1 2)</code> \u2192 <code>3</code></li> <li><code>(- 10 4)</code> \u2192 <code>6</code></li> <li><code>(+ 3 3)</code> \u2192 <code>6</code></li> </ul> <p>Step 3: Evaluate outer expression</p> <ul> <li><code>(* 3 6 6)</code> \u2192 <code>108</code></li> </ul> <p>Answer: <code>108</code></p>"},{"location":"building_blocks/scheme_and_parse_trees/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning Prefix Notation Operator comes before operands: <code>(+ 1 2)</code> S-Expression Atom or list of S-expressions Parse Tree Tree representation of expression structure Post-Order Traversal Evaluate children before parent (bottom-up) Homoiconicity Code is data; programs are lists No Precedence Rules Parentheses make structure explicit Scheme/Lisp Languages using prefix notation and S-expressions"},{"location":"building_blocks/scheme_and_parse_trees/#why-scheme-matters","title":"Why Scheme Matters","text":"<p>Scheme and prefix notation reveal:</p> <ul> <li>How notation shapes thought: Explicit structure changes how you reason about programs</li> <li>How parsers work: Prefix notation is trivial to parse; infix requires precedence</li> <li>How trees encode meaning: Parse trees are the \"compiled\" form of expressions</li> <li>How code can be data: S-expressions let programs manipulate programs</li> <li>How functional programming works: Scheme pioneered ideas now common in modern languages</li> </ul> <p>You don't need to write Scheme professionally to benefit from understanding it. The insights it provides\u2014about parsing, recursion, abstraction, and the relationship between notation and computation\u2014are universal.</p>"},{"location":"building_blocks/scheme_and_parse_trees/#further-reading","title":"Further Reading","text":"<ul> <li>Abelson &amp; Sussman, Structure and Interpretation of Computer Programs \u2014 The definitive Scheme textbook</li> <li>David Evans, Introduction to Computing \u2014 Chapter 2 covers RTNs and parsing</li> <li>Recursive Transition Networks \u2014 How grammars define parse trees</li> <li>Computational Thinking \u2014 Abstraction and decomposition in practice</li> </ul> <p>Scheme strips programming down to its essence: functions, data, and recursion. What remains is computation in its purest form\u2014no syntax tricks, no precedence tables, just structure made explicit through parentheses. It's not the notation most programmers use daily, but understanding it changes how you think about all the notations you do use.</p>"},{"location":"building_blocks/scheme_and_parse_trees/#video-summary","title":"Video Summary","text":""},{"location":"building_blocks/what_is_computer_science/","title":"What is Computer Science?","text":"<p>Here's a trick question: What do computers have to do with computer science?</p> <p>Less than you'd think.</p> <p>Computer science isn't really about computers, any more than astronomy is about telescopes or biology is about microscopes. Computers are tools we use, but the field itself is about something deeper: computation\u2014the systematic study of what can be computed, how efficiently, and what it means to solve problems algorithmically.</p>"},{"location":"building_blocks/what_is_computer_science/#the-classic-definitions","title":"The Classic Definitions","text":"<p>Ask ten computer scientists what CS is, and you'll get twelve answers. \ud83e\udd37 Here are some classics:</p> <p>\"Computer science is no more about computers than astronomy is about telescopes.\" \u2014 Edsger Dijkstra</p> <p>\"Computer science is the study of the principles and use of computers.\" \u2014 Encyclopaedia Britannica (less poetic, more accurate for practical purposes)</p> <p>\"The discipline of computing is the systematic study of algorithmic processes that describe and transform information.\" \u2014 ACM/IEEE Computing Curricula (yes, this one's a mouthful, but it's accurate)</p> <p>The common thread? Algorithms and information. Computers just happen to be really good at executing algorithms on information.</p>"},{"location":"building_blocks/what_is_computer_science/#the-core-questions","title":"The Core Questions","text":"<p>Computer science asks fundamental questions that would matter even if silicon chips had never been invented:</p>"},{"location":"building_blocks/what_is_computer_science/#what-can-be-computed","title":"What can be computed?","text":"<p>Not everything! Some problems are undecidable\u2014no algorithm can ever solve them. The famous Halting Problem asks: \"Given a program, will it eventually stop or run forever?\" Alan Turing proved in 1936 that no general algorithm can answer this for all programs.</p> <p>This matters because it sets limits on what we can automate. Some things require human judgment not because we haven't figured out the algorithm yet, but because no such algorithm can exist. Math said so! \ud83e\uddee</p>"},{"location":"building_blocks/what_is_computer_science/#how-efficiently-can-it-be-computed","title":"How efficiently can it be computed?","text":"<p>Even solvable problems vary wildly in difficulty. Sorting a million numbers? Easy\u2014a fraction of a second. Finding the best route through 100 cities (the Traveling Salesman Problem)? Our best algorithms would take longer than the age of the universe. \u23f3 Pack a lunch.</p> <p>This is the study of computational complexity\u2014categorizing problems by how their difficulty scales with size.</p>"},{"location":"building_blocks/what_is_computer_science/#how-do-we-express-computation","title":"How do we express computation?","text":"<p>This is where programming languages come in. But beneath the syntax lies a deeper question: What are the fundamental ways to describe processes? Finite State Machines, Recursive Transition Networks, BNF grammars, lambda calculus, Turing machines\u2014these are all answers to \"How do we write down what we want a computer to do?\"</p> <p>You can see these principles in action in our Scheme Primer, which explores a language designed specifically to be a minimal and elegant expression of computation.</p>"},{"location":"building_blocks/what_is_computer_science/#how-do-we-build-reliable-systems","title":"How do we build reliable systems?","text":"<p>Software is among the most complex things humans create. A modern operating system has tens of millions of lines of code. How do we build systems that work? That don't crash? That hackers can't break into? That scale to billions of users?</p> <p>This encompasses software engineering, security, distributed systems, and more.</p>"},{"location":"building_blocks/what_is_computer_science/#the-major-subfields","title":"The Major Subfields","text":"<p>Computer science is vast. Here's a map of the territory:</p> <ul> <li> <p> Theory</p> <p>The mathematical foundations (where the magic happens):</p> <p>Algorithms \u2014 What's the best way to solve this problem?</p> <p>Complexity \u2014 How hard is this problem inherently?</p> <p>Computability \u2014 Can this problem be solved at all?</p> <p>Formal Languages \u2014 How do we describe and recognize patterns?</p> <p>Cryptography \u2014 How do we secure information mathematically?</p> </li> <li> <p> Systems</p> <p>Building the infrastructure:</p> <p>Operating Systems \u2014 How do we manage hardware resources?</p> <p>Networks \u2014 How do computers communicate?</p> <p>Databases \u2014 How do we store and retrieve information efficiently?</p> <p>Compilers \u2014 How do we translate high-level code to machine code?</p> <p>Distributed Systems \u2014 How do we coordinate many computers?</p> </li> <li> <p> Specialized Domains</p> <p>Pushing the boundaries of what computers can do:</p> <p>Artificial Intelligence \u2014 Can machines think? Learn? Reason?</p> <p>Computer Graphics \u2014 How do we generate images and animations?</p> <p>Computer Vision \u2014 How do we understand images and video?</p> <p>Natural Language Processing \u2014 How do we understand human language?</p> <p>Robotics \u2014 How do we build machines that act in the world?</p> </li> <li> <p> Software Engineering</p> <p>The art and science of building robust software:</p> <p>Software Engineering \u2014 How do we build large systems reliably?</p> </li> <li> <p> Human-Computer Interaction</p> <p>Designing for people:</p> <p>Human-Computer Interaction \u2014 How do we design usable interfaces?</p> </li> <li> <p> Ethics &amp; Society</p> <p>Considering the impact:</p> <p>Ethics \u2014 What should we build? What shouldn't we?</p> <p>Privacy \u2014 How do we protect personal information?</p> <p>Fairness \u2014 Are our algorithms biased?</p> </li> </ul>"},{"location":"building_blocks/what_is_computer_science/#a-brief-history","title":"A Brief History","text":"Before Computers (\u20131940s)Pioneer Era (1940s\u20131960s)Structured Era (1970s\u20131980s)Networked Era (1990s\u20132000s)Modern Era (2010s\u2013Present) <p>Computer science ideas predate computers:</p> <ul> <li>9th century: Al-Khwarizmi develops algebra and systematic problem-solving (his name gives us \"algorithm\")</li> <li>1843: Ada Lovelace writes the first algorithm intended for a machine</li> <li>1936: Alan Turing defines computation mathematically; Alonzo Church develops lambda calculus</li> </ul> <ul> <li>First electronic computers (ENIAC, UNIVAC)</li> <li>First programming languages (FORTRAN, LISP, COBOL)</li> <li>Dijkstra, Knuth, McCarthy lay theoretical foundations</li> <li>The term \"software\" is coined (1958)</li> </ul> <ul> <li>Unix and C language</li> <li>Relational databases</li> <li>Personal computers arrive</li> <li>Object-oriented programming emerges</li> <li>The internet (ARPANET) grows</li> </ul> <ul> <li>World Wide Web</li> <li>Java, Python, JavaScript</li> <li>Open source movement</li> <li>Google, Amazon, Facebook scale to billions</li> </ul> <ul> <li>Cloud computing becomes dominant</li> <li>Machine learning renaissance (deep learning)</li> <li>Mobile-first world</li> <li>Growing concerns about ethics, privacy, AI safety</li> </ul>"},{"location":"building_blocks/what_is_computer_science/#cs-vs-programming-vs-it","title":"CS vs Programming vs IT","text":"<p>These terms are often confused:</p> Field Focus Typical Questions Computer Science Theory and foundations \"Is this problem solvable? How efficiently?\" Software Engineering Building systems \"How do we build this reliably at scale?\" Programming Writing code \"How do I implement this feature?\" Information Technology Managing and maintaining computing infrastructure and services \"How do we deploy and maintain this?\" <p>A computer scientist might study whether a problem is solvable in polynomial time. A programmer implements a solution. An IT professional deploys it. These overlap, but they're distinct skill sets.</p> <p>You can be an excellent programmer without knowing complexity theory. You can understand theory without being able to ship production code. The most powerful combination is both.</p>"},{"location":"building_blocks/what_is_computer_science/#why-study-computer-science","title":"Why Study Computer Science?","text":"<p>Studying computer science isn't just about learning to code; it's about developing a powerful new way of thinking.</p>  Problem-Solving Empowering Creativity Understanding the World Career Opportunities <p>At its core, computer science is about solving problems systematically and at a massive scale. Whether it's finding the shortest route between two cities, detecting cancer in medical images, or serving billions of search queries a day, computer science provides the tools to tackle these challenges efficiently.</p> <p>Computer science is a creative discipline. You can build anything you can imagine: games, music, art, social networks, scientific simulations. Code is the ultimate creative medium, limited only by your imagination.</p> <p>Everything is powered by computation. From your phone to your car to the economy, understanding computer science is essential to being a literate citizen in the 21st century. It demystifies technology and empowers you to be a creator, not just a consumer.</p> <p>Demand for computer science skills is high across every industry\u2014finance, healthcare, entertainment, and more. A CS degree opens doors to a vast range of fulfilling and well-compensated careers.</p>"},{"location":"building_blocks/what_is_computer_science/#the-philosophical-angle","title":"The Philosophical Angle","text":"<p>Here's where things get genuinely interesting. Computer science touches deep philosophical questions:</p> <p>What is intelligence? AI research forces us to define what we mean by understanding, learning, and reasoning. Turns out it's harder than you'd think.</p> <p>What is information? Claude Shannon's information theory quantifies the abstract concept of \"information\" mathematically. (Yes, you can measure surprise!)</p> <p>What is proof? Automated theorem provers and proof assistants are changing how we think about mathematical certainty. Computers now help mathematicians prove theorems humans can't verify by hand.</p> <p>What is a process? Algorithms formalize the notion of \"a procedure to do something\"\u2014an idea that seemed obvious until we tried to make it precise. (Spoiler: it wasn't obvious.)</p> <p>Computer science is philosophy made executable. \ud83d\udcad\u2192\ud83d\udcbb</p>"},{"location":"building_blocks/what_is_computer_science/#getting-started","title":"Getting Started","text":"<p>If you're new to CS, follow this roadmap:</p> <ol> <li>Computational Thinking \u2014 The mental toolkit</li> <li>Finite State Machines \u2014 Simple computation models</li> <li>Recursive Transition Networks \u2014 Describing languages visually</li> <li>Backus-Naur Form \u2014 Describing languages textually</li> <li>Scheme Primer \u2014 Your first look at a functional language</li> <li>Procedures &amp; HOFs \u2014 Mastering abstraction</li> </ol> <p>Coming soon: 7. Regular Expressions \u2014 Practical pattern matching 8. How Parsers Work \u2014 From theory to implementation</p> How These Subfields Connect: A Google Search <p>When you type a query into Google and hit enter, you're touching all four areas of CS:</p> <ul> <li>Theory: Search algorithms decide which pages match your query; ranking algorithms determine the order using graph theory (PageRank) and complexity analysis</li> <li>Systems: Your query hits distributed databases across thousands of servers, coordinated by networking protocols and operating systems</li> <li>Applications: Natural language processing interprets what you meant, not just what you typed; machine learning personalizes results</li> <li>Human-Centered: The clean, minimal interface hides all this complexity behind a single text box</li> </ul> <p>One search. Four subfields. That's computer science in action.</p>"},{"location":"building_blocks/what_is_computer_science/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Identify the Subfield <p>For each problem below, which CS subfield would primarily tackle it? (Some might involve multiple!)</p> <ol> <li>Making Netflix recommend shows you'll actually like</li> <li>Ensuring electronic voting machines can't be hacked</li> <li>Making a video game run smoothly at 60 frames per second</li> <li>Determining if two programs do the same thing</li> <li>Designing an intuitive interface for elderly users</li> </ol> Answers <ol> <li>Machine Learning / AI \u2014 Pattern recognition from viewing history</li> <li>Security / Cryptography \u2014 Protecting systems from attacks, ensuring integrity</li> <li>Computer Graphics / Systems \u2014 Rendering efficiently, managing resources</li> <li>Theory / Computability \u2014 This is actually undecidable! (Rice's Theorem)</li> <li>Human-Computer Interaction (HCI) \u2014 Usability and accessibility</li> </ol> Practice Problem 2: Solvable or Not? <p>Which of these problems can be solved algorithmically?</p> <ol> <li>Given a number, determine if it's prime</li> <li>Given a program, determine if it will ever print \"Hello\"</li> <li>Given a list of numbers, find the largest one</li> <li>Given any mathematical statement, prove whether it's true or false</li> <li>Given a list of numbers, sort them in ascending order</li> </ol> Answers <p>Solvable:</p> <ul> <li>\u2705 #1: Prime testing \u2014 solvable (even efficiently!)</li> <li>\u2705 #3: Find largest \u2014 definitely solvable</li> <li>\u2705 #5: Sorting \u2014 very solvable (many algorithms)</li> </ul> <p>Unsolvable:</p> <ul> <li>\u274c #2: Undecidable (related to Halting Problem)</li> <li>\u274c #4: Undecidable (G\u00f6del's Incompleteness Theorem)</li> </ul> Practice Problem 3: CS vs. Programming vs. IT <p>Classify each task as primarily Computer Science (theory), Software Engineering (building systems), Programming (writing code), or IT (deployment/maintenance):</p> <ol> <li>Proving that no algorithm can solve the Traveling Salesman Problem in polynomial time</li> <li>Writing a Python script to rename 1000 files</li> <li>Designing the architecture for a system that handles 10 million users</li> <li>Setting up backup systems for a company's servers</li> <li>Implementing a search feature for a website</li> </ol> Answers <ol> <li>Computer Science \u2014 Theoretical complexity analysis</li> <li>Programming \u2014 Straightforward coding task</li> <li>Software Engineering \u2014 System design at scale</li> <li>IT \u2014 Infrastructure management</li> <li>Programming (for small sites) or Software Engineering (for large-scale systems)</li> </ol>"},{"location":"building_blocks/what_is_computer_science/#key-takeaways","title":"Key Takeaways","text":"Concept What It Means Computation The systematic transformation of information Algorithm A precise procedure for solving a problem Complexity How difficulty scales with problem size Abstraction Hiding details to manage complexity Decidability Whether a problem can be solved algorithmically"},{"location":"building_blocks/what_is_computer_science/#further-reading","title":"Further Reading","text":"<ul> <li> <p>Introduction to Computing: Explorations in Language, Logic, and Machines by David Evans - A free introductory Computer Science textbook</p> </li> <li> <p>Code: The Hidden Language of Computer Hardware and Software by Charles Petzold \u2014 How computers actually work</p> </li> <li>G\u00f6del, Escher, Bach by Douglas Hofstadter \u2014 Mind-bending exploration of computation and consciousness</li> <li>The Innovators by Walter Isaacson \u2014 History of computing from Ada Lovelace to the internet</li> </ul> <p>Computer science is a young field\u2014barely 80 years old\u2014but it's already transformed the world more profoundly than disciplines thousands of years older. That transformation is accelerating.</p> <p>Whether you're here to build the next transformation or just to understand the one that's already happened, welcome. There's a lot to explore. Let's get started. \ud83d\ude80</p>"},{"location":"building_blocks/what_is_computer_science/#video-summary","title":"Video Summary","text":""},{"location":"data_security/big_data_and_nosql/","title":"Big Data and NoSQL","text":"<p>For 40 years, Relational Databases (SQL) ruled the world. They were safe, consistent, and structured.</p> <p>Then came Google, Facebook, and Amazon.</p> <p>They generated data at a scale that traditional databases couldn't handle. \"Big Data\" broke the old rules, and a new generation of NoSQL databases was born.</p>"},{"location":"data_security/big_data_and_nosql/#the-3-vs-of-big-data","title":"The 3 Vs of Big Data","text":"<p>When does \"Data\" become \"Big Data\"? It's defined by the 3 Vs:</p> <ol> <li>Volume: The sheer amount of data. (Terabytes? Petabytes? Exabytes?).</li> <li>Velocity: The speed at which data arrives. (Millions of tweets per second).</li> <li>Variety: The messiness of the data. (It\u2019s not just neat tables anymore; it\u2019s videos, JSON, logs, and free text).</li> </ol>"},{"location":"data_security/big_data_and_nosql/#nosql-not-only-sql","title":"NoSQL (Not Only SQL)","text":"<p>To handle this, engineers built NoSQL databases. These databases often sacrifice some of the strict safety of SQL (like ACID or Normalization) in exchange for massive Scale and Speed.</p>"},{"location":"data_security/big_data_and_nosql/#types-of-nosql-databases","title":"Types of NoSQL Databases:","text":"<ul> <li>Document Stores (e.g., MongoDB): Store data as JSON-like documents. Flexible schema (you can add new fields anytime).</li> <li>Key-Value Stores (e.g., Redis): Like a giant Hash Map. Incredibly fast but simple.</li> <li>Column-Family (e.g., Cassandra): Optimized for writing massive amounts of data across many servers.</li> <li>Graph Databases (e.g., Neo4j): Optimized for storing connections (Social Networks).</li> </ul>"},{"location":"data_security/big_data_and_nosql/#the-cap-theorem","title":"The CAP Theorem","text":"<p>In a distributed system (like a database spanning 100 servers), it is theoretically impossible to have perfection. You must choose.</p> <p>The CAP Theorem states you can only have two of the following three:</p> <ol> <li>Consistency: Every read receives the most recent write. (Everyone sees the same data at the same time).</li> <li>Availability: Every request receives a response, without guarantee that it contains the most recent write. ( The system never goes down).</li> <li>Partition Tolerance: The system continues to operate despite an arbitrary number of messages being dropped or delayed by the network between nodes.</li> </ol> <p>The Reality: In a distributed system, \"Partition Tolerance\" is mandatory (networks will fail). So, you really only have a choice between CP (Consistency) and AP (Availability).</p> <ul> <li>SQL Databases usually choose Consistency. If the network breaks, they stop accepting writes to prevent errors.</li> <li>NoSQL Databases often choose Availability. If the network breaks, they keep accepting writes, even if some users see slightly old data for a moment (\"Eventually Consistent\").</li> </ul>"},{"location":"data_security/big_data_and_nosql/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Choosing a Database <p>You are building a social media feed where speed is critical. If a user sees a post 1 second later than their friend, it doesn't matter. Which CAP trade-off should you choose?</p> Solution <p>AP (Availability and Partition Tolerance).</p> <p>You prioritize keeping the site up and fast (Availability) over ensuring everyone sees the exact same data at the exact same millisecond (Consistency). A NoSQL database is a good fit here.</p> Practice Problem 2: Banking <p>You are building a bank ledger. Which CAP trade-off is mandatory?</p> Solution <p>CP (Consistency and Partition Tolerance).</p> <p>You cannot afford for money to \"disappear\" or for two ATMs to show different balances. You must choose Consistency, even if it means the ATM says \"Service Unavailable\" during a network glitch.</p>"},{"location":"data_security/big_data_and_nosql/#key-takeaways","title":"Key Takeaways","text":"Feature SQL NoSQL Structure Rigid Tables. Flexible Documents/Keys. Scaling Vertical (Bigger Server). Horizontal (More Servers). Priority Consistency (ACID). Speed and Scale (CAP). Best For Banks, Inventory, Financials. Social Media, Real-time Analytics, IoT. <p>Big Data isn't just \"more data.\" It requires a fundamental shift in how we think about storage. We move from the comfortable certainty of \"ACID\" to the chaotic, eventual reality of \"BASE\" (Basically Available, Soft state, Eventual consistency).</p>"},{"location":"data_security/cryptography_basics/","title":"Cryptography Basics","text":"<p>The word \"Cryptography\" comes from the Greek kryptos (hidden). It is the science of keeping information secret.</p> <p>For thousands of years, generals used codes to send orders to armies. Today, your browser uses cryptography every time you visit a bank website.</p>"},{"location":"data_security/cryptography_basics/#1-symmetric-encryption-the-shared-key","title":"1. Symmetric Encryption (The Shared Key)","text":"<p>Imagine a safe with a single key. You put a message in the safe, lock it, and send the safe to your friend. Your friend uses the same key to unlock it.</p> <ul> <li>Algorithm: AES (Advanced Encryption Standard).</li> <li>Pros: Very fast. Good for encrypting large files.</li> <li>Cons: Key Distribution. How do you get the key to your friend without a hacker seeing it? You can't just email it!</li> </ul>"},{"location":"data_security/cryptography_basics/#2-asymmetric-encryption-public-key","title":"2. Asymmetric Encryption (Public Key)","text":"<p>This was a mathematical breakthrough in the 1970s. Imagine a mailbox.</p> <ul> <li>Public Key (The Slot): Anyone can put a letter in the mailbox. You give this key to the world.</li> <li>Private Key (The Key): Only you can open the mailbox and take letters out. You keep this key secret.</li> </ul> <p>If Alice wants to send Bob a secret: 1.  Alice looks up Bob's Public Key. 2.  Alice encrypts the message with it. 3.  Alice sends the encrypted message. 4.  Bob decrypts it with his Private Key.</p> <ul> <li>Algorithm: RSA, ECC (Elliptic Curve).</li> <li>Pros: No need to share secret keys!</li> <li>Cons: Very slow. Usually used just to exchange a Symmetric Key securely.</li> </ul>"},{"location":"data_security/cryptography_basics/#3-hashing-digital-fingerprints","title":"3. Hashing (Digital Fingerprints)","text":"<p>Encryption is two-way (scramble -&gt; unscramble). Hashing is one-way.</p> <p>A Hash Function takes any amount of data (a password, a file, a movie) and turns it into a fixed-size string of characters (the \"Hash\" or \"Digest\").</p> <p>Properties: 1.  One-Way: You cannot turn the hash back into the original data. 2.  Deterministic: The same input always gives the same hash. 3.  Sensitive: Changing one bit of the input completely changes the hash.</p> <p>Use Case: Passwords Websites never store your actual password. They store the Hash of your password. When you log in, they hash what you typed and compare it to the stored hash. If hackers steal the database, they only get the hashes, not the passwords.</p>"},{"location":"data_security/cryptography_basics/#summary-table","title":"Summary Table","text":"Type Keys Direction Use Case Symmetric 1 (Shared) Two-way Encrypting hard drives, WiFi. Asymmetric 2 (Public/Private) Two-way Secure web browsing (HTTPS), Digital Signatures. Hashing 0 One-way Storing passwords, verifying file integrity."},{"location":"data_security/cryptography_basics/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Safe Communication <p>Alice and Bob have never met. They want to chat securely over the internet. Which encryption method allows them to start talking without a hacker listening in?</p> Solution <p>Asymmetric Encryption.</p> <p>Alice sends Bob her Public Key. Bob uses it to encrypt a \"Session Key\" (Symmetric) and sends it back. Only Alice can decrypt it with her Private Key. Now they both have the Symmetric Key and can talk fast and securely. This is how HTTPS/TLS works.</p> Practice Problem 2: Hashing <p>If you download a large file and the website provides a \"SHA-256 Checksum,\" what is that for?</p> Solution <p>Integrity.</p> <p>You can hash the file you downloaded. If your hash matches the website's hash, you know the file is 100% identical (no corruption, no viruses added).</p>"},{"location":"data_security/cryptography_basics/#key-takeaways","title":"Key Takeaways","text":"Term Meaning Encryption Scrambling data so it is unreadable. Decryption Unscrambling data back to original form. Key The secret password used to encrypt/decrypt. Hash A unique, one-way fingerprint of data. <p>Cryptography is the only reason the modern digital economy exists. Without it, we couldn't buy things online, log into email, or trust that our bank balances are real. It is the mathematics of trust.</p>"},{"location":"data_security/database_acid_and_normalization/","title":"Database Theory: ACID and Normalization","text":"<p>Building a database isn't just about dumping data into tables. It's about ensuring that data remains valid, consistent, and reliable, even when things go wrong.</p> <p>To achieve this, computer scientists rely on two major concepts: the ACID guarantees and Normalization.</p>"},{"location":"data_security/database_acid_and_normalization/#1-acid-the-safety-net","title":"1. ACID: The Safety Net","text":"<p>Imagine you are transferring $100 from Account A to Account B. 1.  Subtract $100 from A. 2.  Add $100 to B.</p> <p>What happens if the power goes out after Step 1 but before Step 2? The money has vanished! ACID is the set of properties that prevents this.</p>"},{"location":"data_security/database_acid_and_normalization/#a-atomicity-all-or-nothing","title":"A - Atomicity (All or Nothing)","text":"<p>A transaction is treated as a single \"Atom.\" Either all steps happen, or none of them happen. If the power fails, the database \"Rolls Back\" Step 1 as if it never occurred.</p>"},{"location":"data_security/database_acid_and_normalization/#c-consistency-follow-the-rules","title":"C - Consistency (Follow the Rules)","text":"<p>The database must always move from one valid state to another valid state. It cannot break its own rules (e.g., \"Account balance cannot be negative\").</p>"},{"location":"data_security/database_acid_and_normalization/#i-isolation-wait-your-turn","title":"I - Isolation (Wait Your Turn)","text":"<p>If two people try to edit the same record at the same time, they shouldn't mess each other up. The database processes transactions as if they happened one after another (Serialized).</p>"},{"location":"data_security/database_acid_and_normalization/#d-durability-written-in-stone","title":"D - Durability (Written in Stone)","text":"<p>Once the database says \"Success,\" that data is saved to the physical disk. Even if the server catches fire immediately afterwards, the data is safe on the hard drive.</p>"},{"location":"data_security/database_acid_and_normalization/#2-normalization-organizing-data","title":"2. Normalization: Organizing Data","text":"<p>Normalization is the process of organizing data to reduce redundancy (duplicates). </p> <p>The Golden Rule: Every piece of information should be stored in exactly one place.</p> <p>If you store a customer's address in the <code>Orders</code> table, and they place 50 orders, you have stored their address 50 times. If they move, you have to update 50 rows. This is bad design. Instead, store the address once in the <code>Customers</code> table and reference it.</p>"},{"location":"data_security/database_acid_and_normalization/#the-normal-forms","title":"The Normal Forms","text":"<ul> <li>1NF (First Normal Form): Each cell must contain a single value. No lists or comma-separated values in a single column.</li> <li>2NF (Second Normal Form): All non-key columns must depend on the entire Primary Key.</li> <li>3NF (Third Normal Form): All columns must depend only on the Primary Key, not on other columns. (\"The Key, the whole Key, and nothing but the Key\").</li> </ul>"},{"location":"data_security/database_acid_and_normalization/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: ACID Failure <p>You buy a concert ticket online. The system charges your credit card but crashes before assigning you a seat. Which ACID property failed?</p> Solution <p>Atomicity.</p> <p>The transaction (Charge Card + Assign Seat) should have been atomic. Since one part happened and the other didn't, the system failed to enforce Atomicity.</p> Practice Problem 2: Normalization <p>You have a table <code>Students</code> with a column <code>Classes</code> that contains: \"Math, History, Science\". Is this table in 1NF?</p> Solution <p>No.</p> <p>1NF forbids multiple values in a single cell. You should create a separate <code>Enrollments</code> table where each class is a separate row linked to the student.</p>"},{"location":"data_security/database_acid_and_normalization/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning Atomicity All or nothing transactions. Consistency Data always follows the rules. Redundancy Storing the same data twice (Bad!). Normalization Splitting tables to remove redundancy. <p>ACID keeps your data safe. Normalization keeps your data clean. Together, they form the bedrock of reliable information systems.</p>"},{"location":"data_security/database_fundamentals/","title":"Database Fundamentals","text":"<p>If you're writing a small script, saving data to a text file or a spreadsheet is fine. But what happens when you have 10,000 users trying to save data at the exact same millisecond? Or when you need to find one specific customer among 50 million records instantly?</p> <p>Text files crash. Spreadsheets freeze. For this, we need a Database.</p>"},{"location":"data_security/database_fundamentals/#1-the-dbms-database-management-system","title":"1. The DBMS (Database Management System)","text":"<p>A database isn't just a file. It is managed by a piece of software called the DBMS (e.g., PostgreSQL, MySQL, SQLite, Oracle).</p> <p>The DBMS is the gatekeeper. -   It ensures data is saved correctly. -   It prevents two people from overwriting each other. -   It enforces security rules. -   It optimizes searches (using \"Indexes\").</p>"},{"location":"data_security/database_fundamentals/#2-the-relational-model","title":"2. The Relational Model","text":"<p>Most of the world's data is stored in Relational Databases. This model was invented by E.F. Codd in 1970 and is based on set theory.</p> <p>In this model, data is organized into Tables (formally called \"Relations\").</p> <ul> <li>Table (Relation): A collection of data about a specific topic (e.g., <code>Customers</code>, <code>Orders</code>).</li> <li>Column (Attribute): A specific piece of information (e.g., <code>Email</code>, <code>Phone Number</code>). Every column has a specific Type (Integer, Text, Date).</li> <li>Row (Tuple): A single record (e.g., <code>Customer #42: Brad Penney</code>).</li> <li>Primary Key: A unique ID that identifies a specific row (e.g., <code>CustomerID</code>).</li> <li>Foreign Key: A reference to a Primary Key in another table. This is how we \"Relate\" data (e.g., An Order has a <code>CustomerID</code> that points to the Customer who made it).</li> </ul>"},{"location":"data_security/database_fundamentals/#3-sql-structured-query-language","title":"3. SQL (Structured Query Language)","text":"<p>To talk to a Relational DBMS, we use a standard language called SQL.</p> <p>It is a Declarative language (remember Programming Paradigms?). You tell the database what you want, not how to find it.</p> <p>Example: <pre><code>SELECT name, email \nFROM customers \nWHERE city = 'New York';\n</code></pre></p>"},{"location":"data_security/database_fundamentals/#why-not-just-use-files","title":"Why Not Just Use Files?","text":"<ol> <li>Concurrency: A DBMS allows thousands of users to read/write at the same time.</li> <li>Integrity: You can set rules like \"Email cannot be blank\" or \"Age must be &gt; 0\". The DBMS will reject any bad data.</li> <li>Speed: A DBMS uses fancy data structures (B-Trees) to find data in \\(O(\\log N)\\) time, whereas searching a text file is \\(O(N)\\).</li> </ol>"},{"location":"data_security/database_fundamentals/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Primary vs. Foreign Key <p>In an <code>Orders</code> table, you have a column called <code>Product_ID</code>. This ID connects the order to the <code>Products</code> table. Is <code>Product_ID</code> a Primary Key or a Foreign Key in the <code>Orders</code> table?</p> Solution <p>Foreign Key.</p> <p>It is a \"reference\" to a key in another table. The <code>Primary Key</code> of the <code>Orders</code> table would be something like <code>Order_ID</code>, which uniquely identifies the order itself.</p> Practice Problem 2: Relational Integrity <p>If you try to delete a Customer from the database, but that Customer still has 5 active Orders, what should the DBMS do?</p> Solution <p>Block the deletion.</p> <p>This is called Referential Integrity. If you deleted the Customer, the Orders would become \"orphans\" pointing to a Customer that doesn't exist. The DBMS prevents this to keep the data valid.</p>"},{"location":"data_security/database_fundamentals/#key-takeaways","title":"Key Takeaways","text":"Term Meaning DBMS The software that manages the database. Table A structured list of data (Relation). Row A single record (Tuple). Column A specific field/attribute. SQL The language used to query the database. <p>Databases are the memory of civilization. They allow us to store vast amounts of information in a structured, retrievable way, forming the backbone of every bank, hospital, and website on Earth.</p>"},{"location":"data_security/information_security_basics/","title":"Information Security Basics","text":"<p>In the physical world, we protect valuables with locks, safes, and guards. in the digital world, we protect Information.</p> <p>Information Security (InfoSec) is the practice of protecting information from unauthorized access, use, disclosure, disruption, modification, or destruction.</p>"},{"location":"data_security/information_security_basics/#the-cia-triad","title":"The CIA Triad","text":"<p>The core goal of InfoSec is to maintain three key properties, known as the CIA Triad:</p> <ol> <li>Confidentiality: Only authorized people can see the data.<ul> <li>Failure: A hacker steals your credit card number.</li> </ul> </li> <li>Integrity: The data has not been tampered with.<ul> <li>Failure: A hacker changes your bank balance from $100 to $0.</li> </ul> </li> <li>Availability: The data is accessible when needed.<ul> <li>Failure: A Denial of Service (DoS) attack takes down Netflix.</li> </ul> </li> </ol>"},{"location":"data_security/information_security_basics/#authentication-vs-authorization","title":"Authentication vs. Authorization","text":"<p>These two terms sound similar but mean very different things.</p> <ol> <li>Authentication (AuthN): \"Who are you?\"<ul> <li>Verifying identity (Passwords, Fingerprints, 2FA).</li> <li>Analogy: Showing your passport at the airport.</li> </ul> </li> <li>Authorization (AuthZ): \"What are you allowed to do?\"<ul> <li>Verifying permissions (Read-only, Admin, Edit).</li> <li>Analogy: Your boarding pass letting you on a specific flight, but not into the cockpit.</li> </ul> </li> </ol> <p>You must be Authenticated before you can be Authorized.</p>"},{"location":"data_security/information_security_basics/#common-threats","title":"Common Threats","text":""},{"location":"data_security/information_security_basics/#1-social-engineering-phishing","title":"1. Social Engineering (Phishing)","text":"<p>Hacking the human, not the computer. Sending a fake email (\"Reset your password!\") to trick a user into giving up their credentials. This is the most common way systems are breached.</p>"},{"location":"data_security/information_security_basics/#2-malware","title":"2. Malware","text":"<p>Software designed to harm. -   Virus: Attaches to a file and spreads. -   Worm: Spreads automatically across a network. -   Ransomware: Encrypts your files and demands payment to unlock them.</p>"},{"location":"data_security/information_security_basics/#3-man-in-the-middle-mitm","title":"3. Man-in-the-Middle (MitM)","text":"<p>An attacker sits between you and the server (e.g., on public Wi-Fi) and intercepts your data. This is why we use HTTPS (Encryption).</p>"},{"location":"data_security/information_security_basics/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: AuthN or AuthZ? <p>You swipe your badge to enter the office building. The reader beeps and unlocks the door. Is this Authentication or Authorization?</p> Solution <p>Both.</p> <ul> <li>Authentication: The badge proves who you are (ID #12345).</li> <li>Authorization: The system checks if ID #12345 is allowed to enter that specific door at that time.</li> </ul> Practice Problem 2: CIA Failure <p>A hospital's patient database is encrypted so hackers can't read it, but a ransomware attack locks the hospital staff out of the system for 3 days. Which part of the CIA triad was compromised?</p> Solution <p>Availability.</p> <p>The data was still Confidential (hackers didn't read it) and had Integrity (hackers didn't change the medical records), but it was not Available to the doctors who needed it.</p>"},{"location":"data_security/information_security_basics/#key-takeaways","title":"Key Takeaways","text":"Concept Definition Confidentiality Secrecy. Integrity Accuracy/Trust. Availability Uptime. Authentication Identity Verification. Authorization Permission Management. <p>Security is not a product you buy; it is a process. It requires constant vigilance, because while defenders have to be right 100% of the time, an attacker only has to be right once.</p>"},{"location":"data_structures/abstract_data_types_and_stack/","title":"Abstract Data Types and the Stack","text":"<p>Imagine you're at a fancy restaurant. You order your food, and a chef prepares it in the kitchen. Do you, as the diner, need to know every single ingredient, every whisk, every chop, or the exact brand of whisk the chef used? Probably not. You care about the delicious meal that arrives, not the culinary mechanics behind it.</p> <p>In computer science, we often deal with complexity by abstracting it away. We care about what a data structure does, not necessarily how it's implemented under the hood. This powerful idea leads us to Abstract Data Types (ADTs), and one of the most fundamental ADTs you'll encounter is the Stack.</p> <p>Get ready to dive into the world of \"black boxes\" and discover how a simple pile of plates can secretly run half the software you use every day.</p>"},{"location":"data_structures/abstract_data_types_and_stack/#what-is-an-abstract-data-type-adt","title":"What is an Abstract Data Type (ADT)?","text":"<p>An Abstract Data Type (ADT) is a logical description of what a data structure represents, without specifying how it's implemented. It defines the data, the operations you can perform on it, and the behavior those operations exhibit.</p> <p>Think of an ADT as a contract or a blueprint. It tells you what you can do, but not how it's done.</p>"},{"location":"data_structures/abstract_data_types_and_stack/#formal-definition","title":"Formal Definition","text":"<p>Mathematically, an ADT can be defined by its state and the transitions between those states. For a Stack, we can represent its behavior using the following notation:</p> Component Mathematical Notation Description Data Set \\(D\\) The set of all possible elements that can be stored in the stack Stack State \\(S\\) A sequence of elements \\((e_1, e_2, \\dots, e_n)\\) where \\(e_n\\) is the top Push \\(push: S \\times D \\to S\\) Adds an element to the top: \\(push((e_1, \\dots, e_n), e) = (e_1, \\dots, e_n, e)\\) Pop \\(pop: S \\to S \\times D\\) Removes and returns the top element: \\(pop((e_1, \\dots, e_n)) = ((e_1, \\dots, e_{n-1}), e_n)\\) Peek \\(peek: S \\to D\\) Returns the top element without removing it: \\(peek((e_1, \\dots, e_n)) = e_n\\) Is Empty \\(isEmpty: S \\to \\{True, False\\}\\) Returns True if the sequence is empty, False otherwise"},{"location":"data_structures/abstract_data_types_and_stack/#the-vending-machine-analogy","title":"The Vending Machine Analogy","text":"<p>In the article about Procedures and Higher-Order Functions, we mentioned that a vending machine is a great analogy for hiding complexity. ADTs are very similar:</p> <ul> <li>Buttons (Operations): <code>Insert Money</code>, <code>Select Item</code>, <code>Get Change</code>. You know what these buttons do.</li> <li>Display (Data): Shows <code>Item A: $1.50</code>, <code>Item B: Out of Stock</code>. You know what information is available.</li> <li>Internal Mechanism (Implementation): Motors, wires, sensors, inventory management system. You don't need to know this to use the machine.</li> </ul> <p>If the vending machine owner decides to replace the internal coin mechanism with a credit card reader, you still use the <code>Select Item</code> operation\u2014the behavior remains the same, even if the implementation changes. That's abstraction in action!</p>"},{"location":"data_structures/abstract_data_types_and_stack/#why-adts-are-awesome","title":"Why ADTs are Awesome","text":"<ol> <li>Modularity: Code becomes easier to organize and maintain.</li> <li>Flexibility: You can change the underlying implementation without affecting the rest of the program, as long as the ADT's contract is upheld.</li> <li>Encapsulation: Details are hidden, preventing accidental misuse or modification.</li> <li>Clarity: Focus on the problem you're solving, not the nitty-gritty storage details.</li> </ol>"},{"location":"data_structures/abstract_data_types_and_stack/#historical-context-the-evolution-of-the-cellar","title":"Historical Context: The Evolution of the \"Cellar\"","text":"<p>The concept of the stack wasn't just \"discovered\"\u2014it was engineered to solve specific problems in early computing.</p> <ul> <li>1945: Alan Turing used the terms \"bury\" and \"unbury\" for stacks in his design of the Automatic Computing Engine (ACE). He needed a way to keep track of return addresses during sub-routine calls.</li> <li>1955: Friedrich L. Bauer and Klaus Samelson applied for a patent for \"The Cellar Principle\" (Stapelprinzip). They recognized that a \"cellar\" (stack) was the perfect structure for evaluating mathematical expressions.</li> <li>1957: Charles Hamblin introduced Reverse Polish Notation (RPN) and stack-based evaluation, which became the foundation for many early calculators and programming languages like Forth and PostScript.</li> </ul> <p>That's not hyperbole\u2014it's history. The stack is one of the oldest and most enduring structures in computer science.</p>"},{"location":"data_structures/abstract_data_types_and_stack/#the-stack-a-lifo-love-story","title":"The Stack: A LIFO Love Story","text":"<p>One of the simplest yet most powerful ADTs is the Stack. If you've ever piled books on your desk or plates in a cupboard, you already understand its core principle.</p> <p>A Stack is a collection of items that follows the Last-In, First-Out (LIFO) principle. This means the last item added to the stack is always the first one to be removed.</p>"},{"location":"data_structures/abstract_data_types_and_stack/#core-stack-operations","title":"Core Stack Operations","text":"<p>The Stack ADT typically defines a few essential operations:</p> <ul> <li><code>PUSH(item)</code>: Adds an <code>item</code> to the top of the stack.</li> <li><code>POP()</code>: Removes and returns the <code>item</code> from the top of the stack. If the stack is empty, it usually results in an error.</li> <li><code>PEEK()</code> / <code>TOP()</code>: Returns the <code>item</code> at the top of the stack without removing it.</li> <li><code>IS_EMPTY()</code>: Checks if the stack contains any items.</li> <li><code>SIZE()</code>: Returns the number of items currently in the stack.</li> </ul>"},{"location":"data_structures/abstract_data_types_and_stack/#visualizing-a-stack","title":"Visualizing a Stack","text":"<p>Let's see a stack in action with some pushes and pops:</p> <pre><code>graph TD\n    subgraph Operations\n        op1(Start Empty) --&gt; op2(PUSH A);\n        op2 --&gt; op3(PUSH B);\n        op3 --&gt; op4(PUSH C);\n        op4 --&gt; op5(POP);\n        op5 --&gt; op6(PUSH D);\n        op6 --&gt; op7(POP);\n        op7 --&gt; op8(POP);\n    end\n\n    subgraph Stack Visuals\n        v1[\" \"] --&gt; v2[\"A\"]\n        v2 --&gt; v3[\"B&lt;br&gt;A\"]\n        v3 --&gt; v4[\"C&lt;br&gt;B&lt;br&gt;A\"]\n        v4 --&gt; v5[\"B&lt;br&gt;A\"]\n        v5 --&gt; v6[\"D&lt;br&gt;B&lt;br&gt;A\"]\n        v6 --&gt; v7[\"B&lt;br&gt;A\"]\n        v7 --&gt; v8[\"A\"]\n    end\n\n    op1 --- v1;\n    op2 --- v2;\n    op3 --- v3;\n    op4 --- v4;\n    op5 --- v5;\n    op6 --- v6;\n    op7 --- v7;\n    op8 --- v8;\n\n    style v1 fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style v2 fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style v3 fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style v4 fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style v5 fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style v6 fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style v7 fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style v8 fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n\n    style op1 fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style op2 fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style op3 fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style op4 fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style op5 fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style op6 fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style op7 fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style op8 fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre>"},{"location":"data_structures/abstract_data_types_and_stack/#implementing-a-stack-the-how-hidden-by-the-adt","title":"Implementing a Stack (The How, Hidden by the ADT)","text":"<p>The beauty of an ADT is that its users don't care about the implementation. But for us curious computer scientists, it's good to know how a Stack can be built.</p> <p>Two common ways to implement a Stack are:</p> <ol> <li>Using an Array/List: <code>PUSH</code> appends to the end; <code>POP</code> removes from the end. This is highly efficient if the array can dynamically resize.</li> <li>Using a Linked List: <code>PUSH</code> adds a new node at the beginning (making it the new head); <code>POP</code> removes the head node.</li> </ol>"},{"location":"data_structures/abstract_data_types_and_stack/#multi-language-implementation","title":"Multi-Language Implementation","text":"<p>Here is a Stack implementation using dynamic arrays (the most common approach) in several popular languages:</p>  Python JavaScript Go Rust Java C++ Stack Implementation in Python<pre><code>class Stack:\n    def __init__(self):\n        self.data = []  # (1)!\n\n    def push(self, item):\n        self.data.append(item)  # (2)!\n\n    def pop(self):\n        if self.is_empty():\n            raise IndexError(\"Pop from empty stack\")\n        return self.data.pop()  # (3)!\n\n    def peek(self):\n        if self.is_empty():\n            return None\n        return self.data[-1]  # (4)!\n\n    def is_empty(self):\n        return len(self.data) == 0\n\n    def size(self):\n        return len(self.data)\n</code></pre> <ol> <li>Python lists are dynamic arrays, perfect for a stack.</li> <li>Appending to the end of a list is O(1) amortized.</li> <li><code>pop()</code> without an index removes the last item.</li> <li>Access the last element without removing it.</li> </ol> Stack Implementation in JavaScript<pre><code>class Stack {\n    constructor() {\n        this.data = [];  // (1)!\n    }\n\n    push(item) {\n        this.data.push(item);  // (2)!\n    }\n\n    pop() {\n        if (this.isEmpty()) {\n            throw new Error(\"Stack is empty\");\n        }\n        return this.data.pop();  // (3)!\n    }\n\n    peek() {\n        return this.isEmpty() ? null : this.data[this.data.length - 1];  // (4)!\n    }\n\n    isEmpty() {\n        return this.data.length === 0;\n    }\n\n    size() {\n        return this.data.length;\n    }\n}\n</code></pre> <ol> <li>JavaScript arrays are dynamic and work perfectly as stacks.</li> <li>The <code>push()</code> method appends to the end in O(1) time.</li> <li>The <code>pop()</code> method removes and returns the last element.</li> <li>Uses a ternary operator to return null for empty stacks.</li> </ol> Stack Implementation in Go<pre><code>package main\n\nimport \"errors\"\n\ntype Stack struct {\n    data []interface{}  // (1)!\n}\n\nfunc (s *Stack) Push(item interface{}) {\n    s.data = append(s.data, item)  // (2)!\n}\n\nfunc (s *Stack) Pop() (interface{}, error) {\n    if s.IsEmpty() {\n        return nil, errors.New(\"stack is empty\")  // (3)!\n    }\n    item := s.data[len(s.data)-1]\n    s.data = s.data[:len(s.data)-1]  // (4)!\n    return item, nil\n}\n\nfunc (s *Stack) Peek() (interface{}, error) {\n    if s.IsEmpty() {\n        return nil, errors.New(\"stack is empty\")\n    }\n    return s.data[len(s.data)-1], nil\n}\n\nfunc (s *Stack) IsEmpty() bool {\n    return len(s.data) == 0\n}\n</code></pre> <ol> <li>Uses <code>interface{}</code> to allow any type (consider using generics in Go 1.18+).</li> <li>The <code>append()</code> function handles slice growth automatically.</li> <li>Idiomatic Go returns errors instead of throwing exceptions.</li> <li>Slice reslicing removes the last element efficiently.</li> </ol> Stack Implementation in Rust<pre><code>struct Stack&lt;T&gt; {  // (1)!\n    data: Vec&lt;T&gt;,\n}\n\nimpl&lt;T&gt; Stack&lt;T&gt; {\n    fn new() -&gt; Self {\n        Stack { data: Vec::new() }\n    }\n\n    fn push(&amp;mut self, item: T) {  // (2)!\n        self.data.push(item);\n    }\n\n    fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {  // (3)!\n        self.data.pop()\n    }\n\n    fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {  // (4)!\n        self.data.last()\n    }\n\n    fn is_empty(&amp;self) -&gt; bool {\n        self.data.is_empty()\n    }\n}\n</code></pre> <ol> <li>Generic type <code>T</code> allows the stack to hold any type safely.</li> <li><code>&amp;mut self</code> borrows the stack mutably for modification.</li> <li>Returns <code>Option&lt;T&gt;</code> - idiomatic Rust for operations that can fail.</li> <li>Returns a reference <code>&amp;T</code> since peek doesn't take ownership.</li> </ol> Stack Implementation in Java<pre><code>import java.util.ArrayList;\n\npublic class Stack&lt;T&gt; {  // (1)!\n    private ArrayList&lt;T&gt; data = new ArrayList&lt;&gt;();  // (2)!\n\n    public void push(T item) {\n        data.add(item);\n    }\n\n    public T pop() {\n        if (isEmpty()) {\n            throw new RuntimeException(\"Stack is empty\");  // (3)!\n        }\n        return data.remove(data.size() - 1);\n    }\n\n    public T peek() {\n        if (isEmpty()) {\n            return null;\n        }\n        return data.get(data.size() - 1);\n    }\n\n    public boolean isEmpty() {\n        return data.isEmpty();\n    }\n}\n</code></pre> <ol> <li>Generic type parameter <code>&lt;T&gt;</code> provides type safety.</li> <li>ArrayList automatically resizes as needed.</li> <li>Throws unchecked exception for empty stack (alternatively use Optional). Stack Implementation in C++<pre><code>#include &lt;vector&gt;\n#include &lt;stdexcept&gt;\n\ntemplate &lt;typename T&gt;  // (1)!\nclass Stack {\nprivate:\n    std::vector&lt;T&gt; data;  // (2)!\n\npublic:\n    void push(const T&amp; item) {  // (3)!\n        data.push_back(item);\n    }\n\n    T pop() {\n        if (isEmpty()) {\n            throw std::runtime_error(\"Stack is empty\");\n        }\n        T item = data.back();\n        data.pop_back();\n        return item;\n    }\n\n    T peek() const {  // (4)!\n        if (isEmpty()) {\n            throw std::runtime_error(\"Stack is empty\");\n        }\n        return data.back();\n    }\n\n    bool isEmpty() const {\n        return data.empty();\n    }\n};\n</code></pre> <ol> <li>Template allows generic type-safe stack implementation.</li> <li><code>std::vector</code> provides dynamic array with automatic memory management.</li> <li>Pass by const reference to avoid unnecessary copying.</li> <li><code>const</code> method indicates peek doesn't modify the stack.</li> </ol>"},{"location":"data_structures/abstract_data_types_and_stack/#real-world-applications-of-stacks","title":"Real-World Applications of Stacks","text":"<p>Stacks aren't just academic exercises; they power many features you use daily!</p>  Function Call Stack Undo/Redo Expression Parsing Browser History <p>This is perhaps the most critical use of a stack in computing.</p> <p>When a program calls a function, a stack frame (containing local variables and return addresses) is pushed onto the call stack. When the function finishes, its frame is popped, and execution returns to the caller. This LIFO behavior is why recursion works\u2014the last function called is the first one to finish. (Pack a lunch; recursion can get deep!)</p> <p></p> <p>Ever hit ++ctrl+z++? That's a stack at work!</p> <p>Each action you perform is pushed onto an \"undo stack.\" When you \"undo,\" the last action is popped and reversed. Often, that popped action is then pushed onto a \"redo stack,\" allowing you to move back and forth through your history.</p> <p></p> <p>Compilers and interpreters use stacks extensively to validate syntax and evaluate math.</p> <ul> <li>Parentheses Matching: As a parser reads code, it pushes opening brackets onto a stack and pops them when it sees a closing bracket. If the types don't match or the stack isn't empty at the end, the code is invalid.</li> <li>RPN Evaluation: Calculators use stacks to evaluate expressions like <code>3 4 + 5 *</code> (which equals 35) without needing parentheses.</li> </ul> <p></p> <p>Your web browser's \"Back\" button is a classic stack. As you navigate to new pages, your URLs are pushed onto a history stack. Clicking \"Back\" pops the current URL and takes you to the one underneath it.</p>"},{"location":"data_structures/abstract_data_types_and_stack/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Stack State Tracing <p>Starting with an empty stack, perform the following sequence of operations. What is the final state of the stack (from top to bottom), and what values are returned by the <code>POP</code> operations?</p> <ol> <li><code>PUSH('X')</code></li> <li><code>PUSH('Y')</code></li> <li><code>POP()</code></li> <li><code>PUSH('Z')</code></li> <li><code>PUSH('W')</code></li> <li><code>POP()</code></li> <li><code>PEEK()</code></li> </ol> Solution Operation Stack State (Top -&gt; Bottom) Returned Value Start <code>[]</code> N/A <code>PUSH('X')</code> <code>['X']</code> N/A <code>PUSH('Y')</code> <code>['Y', 'X']</code> N/A <code>POP()</code> <code>['X']</code> <code>'Y'</code> <code>PUSH('Z')</code> <code>['Z', 'X']</code> N/A <code>PUSH('W')</code> <code>['W', 'Z', 'X']</code> N/A <code>POP()</code> <code>['Z', 'X']</code> <code>'W'</code> <code>PEEK()</code> <code>['Z', 'X']</code> <code>'Z'</code> <p>Final Stack State: <code>['Z', 'X']</code> Values returned by POP: 'Y', 'W'</p> Practice Problem 2: Balanced Delimiters <p>Using a stack, determine if the string <code>\"{ [ ( ) ] }\"</code> is balanced. Describe the steps.</p> Solution <ol> <li>Iterate through the string:</li> <li><code>{</code>: Push to stack. Stack: <code>['{']</code></li> <li><code>[</code>: Push to stack. Stack: <code>['[', '{']</code></li> <li><code>(</code>: Push to stack. Stack: <code>['(', '[', '{']</code></li> <li><code>)</code>: Pop from stack (<code>(</code>). Match found! Stack: <code>['[', '{']</code></li> <li><code>]</code>: Pop from stack (<code>[</code>). Match found! Stack: <code>['{']</code></li> <li><code>}</code>: Pop from stack (<code>{</code>). Match found! Stack: <code>[]</code></li> <li>End of string and stack is empty: Balanced!</li> </ol> Practice Problem 3: Reverse a String <p>Write pseudocode using a stack to reverse the string \"STACK\".</p> Solution Reverse String Pseudocode<pre><code>function REVERSE_STRING(input)\n    s = CREATE_STACK()\n    for each char in input:\n        PUSH(s, char)\n\n    result = \"\"\n    while NOT IS_EMPTY(s):\n        result = result + POP(s)\n\n    return result\nendfunction\n</code></pre> <ol> <li>Push 'S', 'T', 'A', 'C', 'K'. Stack: <code>['K', 'C', 'A', 'T', 'S']</code></li> <li>Pop characters: 'K', then 'C', then 'A', then 'T', then 'S'.</li> <li>Result: \"KCATS\" (reversed).</li> </ol>"},{"location":"data_structures/abstract_data_types_and_stack/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning Abstract Data Type (ADT) A logical contract defining data and operations, hiding implementation details Stack A linear data structure following the Last-In, First-Out (LIFO) principle PUSH / POP The two primary operations for adding and removing the top element Call Stack The system-level stack that manages function calls and local variables LIFO The fundamental rule of stacks: the newest item is the first one out"},{"location":"data_structures/abstract_data_types_and_stack/#why-adts-and-stacks-matter","title":"Why ADTs and Stacks Matter","text":"<p>Understanding Abstract Data Types, particularly the Stack, is foundational to mastering computer science.</p> <ul> <li>ADTs teach you to think about interfaces first: Before you optimize or implement, you define the \"what\" and the \"how it behaves.\" This leads to cleaner, more maintainable code.</li> <li>The Stack is everywhere: From the lowest levels of your operating system (the call stack) to the highest levels of application design (undo/redo, browser history), its simple LIFO rule provides elegant solutions to complex problems.</li> <li>It demystifies complex systems: Knowing about the call stack helps you debug programs, understand recursion, and grasp how a CPU manages execution.</li> </ul>"},{"location":"data_structures/abstract_data_types_and_stack/#further-reading","title":"Further Reading","text":"<ul> <li>David Evans, Introduction to Computing \u2014 Chapter 6 covers the Stack ADT and its applications in more detail.</li> <li>Computational Thinking \u2014 Abstraction as a key problem-solving tool.</li> <li>Procedures and Higher-Order Functions \u2014 How functions enable modularity and abstraction.</li> </ul> <p>The Stack might just be a humble pile of items, but it's one of computing's unsung heroes, silently managing the flow of control and data, always ready to hand you the very last thing you put in.</p>"},{"location":"data_structures/binary_search_trees/","title":"Binary Search Trees (BST)","text":"<p>We know that Binary Search is incredibly fast (\\(O(\\log N)\\)), but it requires a sorted list. What if you need to frequently add or remove items? Sorting a whole list every time you add one number is slow (\\(O(N)\\)).</p> <p>A Binary Search Tree is a data structure that keeps itself sorted while allowing for fast additions, removals, and lookups.</p>"},{"location":"data_structures/binary_search_trees/#the-rule","title":"The Rule","text":"<p>A Binary Search Tree is a Binary Tree that follows one strict rule for every node:</p> <ol> <li>All values in the Left Subtree must be Smaller than the node's value.</li> <li>All values in the Right Subtree must be Larger than the node's value.</li> </ol>"},{"location":"data_structures/binary_search_trees/#example","title":"Example:","text":"<p>If the root is 50: -   The left child could be 30. -   The right child could be 70. -   The left child of 30 could be 20 (smaller than 30 and 50). -   The right child of 30 could be 40 (larger than 30, but still smaller than 50).</p>"},{"location":"data_structures/binary_search_trees/#operations","title":"Operations","text":""},{"location":"data_structures/binary_search_trees/#1-searching-olog-n","title":"1. Searching: \\(O(\\log N)\\)","text":"<p>Searching a BST is just like playing \"High-Low.\" -   Looking for 40?  -   Compare to Root (50). 40 &lt; 50, go Left. -   Compare to 30. 40 &gt; 30, go Right. -   Found it!</p> <p>Because we eliminate half the tree with every step, we find our target in logarithmic time.</p>"},{"location":"data_structures/binary_search_trees/#2-insertion-olog-n","title":"2. Insertion: \\(O(\\log N)\\)","text":"<p>To add a new number, you simply \"search\" for it. When you hit a blank spot (a null leaf), that\u2019s where the new number belongs!</p>"},{"location":"data_structures/binary_search_trees/#the-weakness-unbalanced-trees","title":"The Weakness: Unbalanced Trees","text":"<p>The speed of a BST depends entirely on the height of the tree.</p> <ul> <li>If you add numbers in a random order, the tree stays \"bushy\" and balanced. Height is \\(\\log N\\).</li> <li>The Problem: If you add numbers in order (e.g., <code>10, 20, 30, 40</code>), the tree grows in a straight line to the right. </li> </ul> <p>This is called a Degenerate Tree (or a \"Stick\"). It effectively becomes a Linked List, and your performance crashes from \\(O(\\log N)\\) to \\(O(N)\\).</p> <p>To fix this, computer scientists use \"Self-Balancing Trees\" (like AVL trees or Red-Black trees) that automatically shuffle themselves to stay bushy.</p>"},{"location":"data_structures/binary_search_trees/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Validating a BST <p>Is this a valid Binary Search Tree? Root: 10 Left: 5 Right: 15 Left child of 15: 8</p> Solution <p>No.</p> <p>While 8 is smaller than 15 (valid for the Right subtree's local rule), 8 is not larger than the root (10). In a BST, every node in the right subtree must be larger than the root. The value 8 belongs in the left subtree of 10.</p> Practice Problem 2: Lookup Speed <p>If a balanced BST has 1,000 items, roughly how many comparisons are needed to find a specific item?</p> Solution <p>About 10 comparisons.</p> <p>\\(\\log_2(1000) \\approx 10\\). This is the power of the tree structure.</p>"},{"location":"data_structures/binary_search_trees/#key-takeaways","title":"Key Takeaways","text":"Feature Details Logic Left &lt; Parent &lt; Right. Search Speed \\(O(\\log N)\\) (Average). Insert Speed \\(O(\\log N)\\) (Average). Risk Can become \\(O(N)\\) if unbalanced. <p>The Binary Search Tree is the most common way to implement a Dictionary or Set in many programming languages. It combines the speed of binary search with the flexibility of dynamic memory, making it one of the most versatile tools in your kit.</p>"},{"location":"data_structures/linked_lists/","title":"Linked Lists","text":"<p>Imagine you are on a scavenger hunt. You find a clue in the park. That clue doesn't contain the prize; it contains a piece of paper that says, \"The next clue is in the bakery.\" You go to the bakery and find another clue pointing to the library.</p> <p>This is exactly how a Linked List works. It is a collection of items that are not stored in a neat row (like an array), but are scattered across your computer's memory, connected by Pointers.</p>"},{"location":"data_structures/linked_lists/#1-anatomy-nodes-and-pointers","title":"1. Anatomy: Nodes and Pointers","text":"<p>A Linked List consists of a series of Nodes. Each node has two parts: 1.  Data: The value you want to store (e.g., a number or a string). 2.  Next Pointer: A reference (the memory address) to the next node in the list.</p> <p>The list starts at the Head and ends with a Null pointer (pointing to nothing).</p>"},{"location":"data_structures/linked_lists/#2-linked-lists-vs-arrays","title":"2. Linked Lists vs. Arrays","text":"<p>Why not just use an array? </p>"},{"location":"data_structures/linked_lists/#the-array-problem","title":"The Array Problem","text":"<p>An array is a contiguous block of memory. To add an item to the middle of an array, you have to move every single item after it over to make room. This is slow (\\(O(N)\\)).</p>"},{"location":"data_structures/linked_lists/#the-linked-list-solution","title":"The Linked List Solution","text":"<p>In a Linked List, to add an item, you just change two pointers. You tell the new node to point to the next person, and the previous person to point to the new node. You don't have to move anything. This is very fast (\\(O(1)\\)).</p> Feature Array Linked List Storage Contiguous (Fixed block). Scattered (Nodes). Lookup \\(O(1)\\) (Fast - jump to index). \\(O(N)\\) (Slow - walk the clues). Insert/Delete \\(O(N)\\) (Slow - shifting). \\(O(1)\\) (Fast - pointers). Size Hard to change. Dynamic (Grows/Shrinks)."},{"location":"data_structures/linked_lists/#3-types-of-linked-lists","title":"3. Types of Linked Lists","text":"<ul> <li>Singly Linked: Each node points only to the next one. (One-way street).</li> <li>Doubly Linked: Each node points to both the next and the previous one. (Two-way street). This allows you to walk backwards.</li> <li>Circular Linked: The last node points back to the head. (A loop).</li> </ul>"},{"location":"data_structures/linked_lists/#real-world-use-case-music-playlist","title":"Real-World Use Case: Music Playlist","text":"<p>A music playlist is a perfect Linked List.  -   You are listening to a song (Node). -   When it ends, the player looks at the Next Pointer to find the next song. -   If you want to add a song to the middle of the list, the computer doesn't need to re-index your whole library; it just changes where the \"Next\" buttons point.</p>"},{"location":"data_structures/linked_lists/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Searching <p>If you want to find the 100th item in a Linked List, do you have to look at items 1 through 99 first?</p> Solution <p>Yes. </p> <p>Unlike an array, where you can jump straight to <code>index[99]</code>, a Linked List requires you to start at the head and follow the pointers one by one. This is why lookups are \\(O(N)\\).</p> Practice Problem 2: Memory Cost <p>Which uses more memory: an Array of 10 integers or a Linked List of 10 integers?</p> Solution <p>Linked List.</p> <p>Each node in a Linked List must store the integer plus the memory address of the next node (the pointer). An array only stores the integers themselves.</p>"},{"location":"data_structures/linked_lists/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Linked Lists use pointers to connect nodes scattered in memory.</li> <li>They are excellent for dynamic data that changes size frequently.</li> <li>They are poor for random access (finding a specific index).</li> </ul> <p>The Linked List is the ultimate example of how we use Pointers to manage memory. It frees us from the rigid boundaries of the array, allowing our data structures to grow and evolve as fluidly as the information they represent.</p>"},{"location":"data_structures/queues_and_deques/","title":"Queues and Deques","text":"<p>If a Stack is a \"Last-In, First-Out\" (LIFO) structure (like a pile of plates), a Queue is the exact opposite.</p> <p>A Queue is a First-In, First-Out (FIFO) data structure. Think of it like a line at a grocery store: the first person to get in line is the first person to be served.</p>"},{"location":"data_structures/queues_and_deques/#1-the-queue-fifo","title":"1. The Queue (FIFO)","text":"<p>A Queue has two main operations: 1.  Enqueue: Add an item to the Back of the line. 2.  Dequeue: Remove an item from the Front of the line.</p> <p>Analogy: A tunnel. You drive in one end and come out the other. You can't pass the cars in front of you.</p>"},{"location":"data_structures/queues_and_deques/#real-world-use-cases","title":"Real-World Use Cases:","text":"<ul> <li>Print Queues: The first document you send to the printer is the first one printed.</li> <li>Web Servers: When thousands of people visit a site at once, the server puts them in a queue and processes requests one by one.</li> <li>Task Scheduling: Your CPU uses a queue to decide which process to run next.</li> </ul>"},{"location":"data_structures/queues_and_deques/#2-the-deque-double-ended-queue","title":"2. The Deque (Double-Ended Queue)","text":"<p>A Deque (pronounced \"Deck\") is a more flexible version of a queue. It stands for Double-Ended Queue.</p> <p>In a Deque, you can add or remove items from both the front and the back.</p> <p>Analogy: A deck of cards. You can deal a card from the top or pull one from the bottom (if you're cheating!).</p>"},{"location":"data_structures/queues_and_deques/#operations","title":"Operations:","text":"<ul> <li><code>addFront()</code> / <code>addBack()</code></li> <li><code>removeFront()</code> / <code>removeBack()</code></li> </ul>"},{"location":"data_structures/queues_and_deques/#queue-vs-stack","title":"Queue vs. Stack","text":"Feature Queue Stack Order FIFO (First-In, First-Out). LIFO (Last-In, First-Out). Insert at Back. Top. Remove from Front. Top. Analogy Waiting Line. Pile of Plates."},{"location":"data_structures/queues_and_deques/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Operation Order <p>Starting with an empty Queue, perform these operations: 1. Enqueue(A) 2. Enqueue(B) 3. Dequeue() 4. Enqueue(C)</p> <p>What is the next item to be Dequeued?</p> Solution <p>B.</p> <ol> <li><code>[A]</code></li> <li><code>[A, B]</code></li> <li>Dequeue <code>A</code> -&gt; <code>[B]</code></li> <li><code>[B, C]</code></li> </ol> <p>The next item at the front is B.</p> Practice Problem 2: Stack as Deque <p>Can you use a Deque as if it were a Stack? How?</p> Solution <p>Yes. </p> <p>A Stack only adds and removes from the same end. To use a Deque as a Stack, simply limit yourself to using only <code>addBack()</code> and <code>removeBack()</code>. A Deque is a \"Super-set\" of both Queues and Stacks.</p>"},{"location":"data_structures/queues_and_deques/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Queues ensure fairness by processing items in the order they arrived.</li> <li>Deques provide maximum flexibility for adding/removing from either end.</li> <li>Both structures are essential for managing buffers and asynchronous tasks.</li> </ul> <p>The Queue is the guardian of order. It prevents chaos by ensuring that every task, every packet, and every user gets their turn in the sequence they arrived.</p>"},{"location":"deep_dives/information_theory/","title":"Information Theory","text":"<p>In 1948, Claude Shannon published a paper that changed the world. Before Shannon, people thought communication was about electricity or radio waves. Shannon proved that communication is actually about Mathematics.</p> <p>Information Theory is the study of how information is quantified, stored, and communicated. It provides the foundation for everything from the internet to the DNA in your cells.</p>"},{"location":"deep_dives/information_theory/#1-what-is-information","title":"1. What is Information?","text":"<p>In common language, \"information\" means knowledge. In computer science, information is the reduction of uncertainty.</p> <p>Imagine I flip a coin. Before I tell you the result, you have 50/50 uncertainty. If I say \"Heads,\" I have given you exactly 1 bit of information because I have eliminated two possibilities.</p> <ul> <li>If I tell you something you already knew (e.g., \"The sun will rise tomorrow\"), I have given you 0 bits of information.</li> <li>If I tell you something highly unlikely (e.g., \"It is snowing in the Sahara Desert\"), I have given you a lot of information because I have significantly reduced your uncertainty about a chaotic situation.</li> </ul>"},{"location":"deep_dives/information_theory/#2-the-bit-the-atomic-unit","title":"2. The Bit: The Atomic Unit","text":"<p>Shannon coined the term Bit (Binary Digit). A bit is the smallest possible unit of information. It represents a choice between two equally likely outcomes (0 or 1, Yes or No, True or False).</p>"},{"location":"deep_dives/information_theory/#3-entropy-measuring-randomness","title":"3. Entropy: Measuring Randomness","text":"<p>Entropy is a measure of how much \"uncertainty\" or \"surprise\" is in a message.</p> <ul> <li>Low Entropy: Predictable data. (Example: <code>AAAAA</code>). There is very little information here because we know what's coming next.</li> <li>High Entropy: Unpredictable data. (Example: <code>Xj9!pL</code>). Every character is a surprise.</li> </ul>"},{"location":"deep_dives/information_theory/#4-source-coding-compression","title":"4. Source Coding (Compression)","text":"<p>Because most human communication is redundant (e.g., in English, the letter \"q\" is almost always followed by \"u\"), we can compress it.</p> <p>Compression is the process of representing high-entropy data with the fewest number of bits possible. -   Lossless Compression (ZIP): Every bit is preserved. Essential for text and code. -   Lossy Compression (JPEG, MP3): Throws away bits that humans won't notice (like very high-pitched sounds or subtle color shifts).</p>"},{"location":"deep_dives/information_theory/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Calculating Bits <p>I am thinking of a number between 1 and 8. How many bits of information do you need to find the number?</p> Solution <p>3 bits.</p> <p>Each bit halves the search space: 1. Bit 1: Is it 1-4 or 5-8? (Remaining: 4) 2. Bit 2: Is it 1-2 or 3-4? (Remaining: 2) 3. Bit 3: Is it 1 or 2? (Remaining: 1)</p> <p>Mathematically, \\(\\log_2(8) = 3\\).</p> Practice Problem 2: Entropy <p>Which message has higher entropy? A. <code>1010101010</code> B. <code>1100100101</code></p> Solution <p>Message B.</p> <p>Message A follows a strict, predictable pattern. Message B is more random/unpredictable, meaning it has higher entropy and carries more \"information\" per bit.</p>"},{"location":"deep_dives/information_theory/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning Information The reduction of uncertainty. Bit The unit of information (0 or 1). Entropy The amount of surprise/randomness in data. Compression Removing redundancy to save space. <p>Information theory tells us that there is a physical limit to how much we can compress data and how fast we can send it over a wire. By understanding these limits, Shannon paved the way for the digital revolution, turning the messy world of signals into the precise world of bits.</p>"},{"location":"git/core_functionality/intro_to_git/","title":"Introducing Git","text":"<p>Git is a version control system. It tracks changes to text files, so any changes that are made by authors can be reverted at any time.  Its the ideal tool for software developers to collaborate together to create a unified software product.</p>"},{"location":"modern_topics/artificial_intelligence_concepts/","title":"Artificial Intelligence Concepts","text":"<p>For as long as there have been computers, there has been a question: Can a machine think?</p> <p>Artificial Intelligence (AI) is the branch of computer science dedicated to creating systems capable of performing tasks that typically require human intelligence, such as recognizing speech, making decisions, or playing games.</p>"},{"location":"modern_topics/artificial_intelligence_concepts/#1-the-two-paths-of-ai","title":"1. The Two Paths of AI","text":"<p>Historically, there have been two ways to build \"intelligence\":</p>"},{"location":"modern_topics/artificial_intelligence_concepts/#a-symbolic-ai-the-rule-book","title":"A. Symbolic AI (The Rule-Book)","text":"<p>Also known as \"Good Old Fashioned AI\" (GOFAI). The idea is that intelligence comes from manipulating symbols according to logical rules. -   Method: \"If the light is red, then stop.\" -   Strength: Excellent for math and logic. -   Weakness: Fails at \"messy\" real-world tasks like identifying a cat in a photo.</p>"},{"location":"modern_topics/artificial_intelligence_concepts/#b-connectionism-the-brain-model","title":"B. Connectionism (The Brain-Model)","text":"<p>Inspired by the human brain. Instead of rules, we build a \"Neural Network\" of simple nodes that learn patterns through experience. -   Method: Show the machine 10,000 photos of cats until it \"recognizes\" the pattern. -   Strength: Excellent for vision, speech, and translation. -   Weakness: A \"Black Box\"\u2014it\u2019s hard to explain why it made a specific decision.</p>"},{"location":"modern_topics/artificial_intelligence_concepts/#2-machine-learning-ml","title":"2. Machine Learning (ML)","text":"<p>Most modern AI is actually Machine Learning. This is a subset of AI where the computer improves its performance on a task by analyzing data, rather than being explicitly programmed with rules.</p>"},{"location":"modern_topics/artificial_intelligence_concepts/#the-three-types-of-learning","title":"The Three Types of Learning:","text":"<ol> <li>Supervised Learning: Learning with a teacher. We give the machine \"Labeled Data\" (Input + Correct Answer). <ul> <li>Example: Spam filters (This email is Spam / Not Spam).</li> </ul> </li> <li>Unsupervised Learning: Learning alone. The machine looks for hidden patterns in data without being told what they are.<ul> <li>Example: Grouping customers by their shopping habits.</li> </ul> </li> <li>Reinforcement Learning: Learning by trial and error. The machine receives \"rewards\" for good moves and \"penalties\" for bad ones.<ul> <li>Example: An AI learning to play chess or drive a car.</li> </ul> </li> </ol>"},{"location":"modern_topics/artificial_intelligence_concepts/#3-heuristics-rules-of-thumb","title":"3. Heuristics: Rules of Thumb","text":"<p>Because some problems are too complex to solve perfectly (remember P vs NP?), AI often uses Heuristics. </p> <p>A heuristic is a mental shortcut or \"rule of thumb\" that finds a \"good enough\" solution quickly, even if it's not the mathematically perfect one.</p>"},{"location":"modern_topics/artificial_intelligence_concepts/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Symbolic or Connectionist? <p>An AI system is built to help a doctor diagnose diseases. It uses a massive list of rules written by medical experts (e.g., \"If patient has a fever AND a cough, check for flu\"). Is this Symbolic or Connectionist?</p> Solution <p>Symbolic AI.</p> <p>It is based on explicit logical rules provided by humans. This is often called an Expert System.</p> Practice Problem 2: Type of Learning <p>You want to build an AI that can look at a photo of a piece of fruit and tell you if it is an Apple, Orange, or Banana. You have 5,000 photos that are already labeled with the correct fruit name. Which type of learning should you use?</p> Solution <p>Supervised Learning.</p> <p>Since you have \"labeled data\" (the fruit names), you can train the model to map the input (pixels) to the correct output (label).</p>"},{"location":"modern_topics/artificial_intelligence_concepts/#key-takeaways","title":"Key Takeaways","text":"Term Meaning AI The broad field of \"intelligent\" machines. Machine Learning Learning from data instead of rules. Neural Network A brain-inspired model for finding patterns. Supervised Learning Training with labeled examples. Heuristic A practical \"shortcut\" to find a quick solution. <p>AI is moving from \"calculating\" to \"perceiving.\" By shifting from rigid rules to flexible learning, we have enabled computers to interact with the messy, unpredictable world in ways that were once thought to be pure science fiction.</p>"},{"location":"modern_topics/computer_graphics/","title":"Computer Graphics","text":"<p>Everything you see on a computer screen\u2014from the text in this article to the photorealistic worlds of a modern video game\u2014is the result of Computer Graphics. It is the subfield of computer science that deals with generating and manipulating images using computers.</p>"},{"location":"modern_topics/computer_graphics/#1-raster-vs-vector-the-two-ways-to-draw","title":"1. Raster vs. Vector: The Two Ways to Draw","text":"<p>There are two fundamental ways to represent an image digitally:</p>"},{"location":"modern_topics/computer_graphics/#raster-graphics-the-grid","title":"Raster Graphics (The Grid)","text":"<p>A raster image is a grid of colored dots called Pixels. -   Example: Photos (JPEG, PNG). -   Pros: Can represent complex textures and subtle color changes perfectly. -   Cons: \"Pixelation.\" If you zoom in too far, the image becomes blocky because you are just looking at larger squares.</p>"},{"location":"modern_topics/computer_graphics/#vector-graphics-the-math","title":"Vector Graphics (The Math)","text":"<p>A vector image is a set of mathematical instructions: \"Draw a circle at (x,y) with radius R and color Blue.\" -   Example: Logos, Fonts (SVG, AI). -   Pros: Infinite scaling. You can blow up a vector logo to the size of a billboard and it will stay perfectly crisp. -   Cons: Not suitable for complex, noisy images like a photograph of a forest.</p>"},{"location":"modern_topics/computer_graphics/#2-the-rendering-pipeline","title":"2. The Rendering Pipeline","text":"<p>How does a 3D world (like in Minecraft or Call of Duty) get turned into a 2D image on your flat monitor? This process is called the Rendering Pipeline.</p> <ol> <li>Modeling: Creating the 3D shapes (Vertices and Polygons).</li> <li>Transformation: Rotating and moving the objects in the 3D world.</li> <li>Lighting: Calculating how light hits the surfaces.</li> <li>Projection: Flattening the 3D scene into a 2D view (like a camera lens).</li> <li>Rasterization: Converting the 2D shapes into pixels on the screen.</li> </ol>"},{"location":"modern_topics/computer_graphics/#3-the-gpu-the-specialized-engine","title":"3. The GPU: The Specialized Engine","text":"<p>Processing millions of pixels 60 times per second is too much work for a general-purpose CPU. For this, we use a Graphics Processing Unit (GPU).</p> <p>While a CPU is like a high-speed sports car (doing one complex thing at a time), a GPU is like a massive fleet of 1,000 slow trucks. Each \"truck\" (core) handles a single pixel. Because graphics tasks are parallel (calculating Pixel A doesn't depend on Pixel B), the GPU's massive core count makes it incredibly fast at drawing.</p>"},{"location":"modern_topics/computer_graphics/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Scale Test <p>You are designing a new font. Should you save your letter designs as Raster or Vector files?</p> Solution <p>Vector. </p> <p>Fonts need to look crisp whether they are size 8 on a phone or size 72 on a poster. Vector graphics allow the letter to be recalculated at any size without losing quality.</p> Practice Problem 2: The GPU Choice <p>Why are GPUs used for AI training and Crypto mining, even though those aren't \"graphics\" tasks?</p> Solution <p>Parallelism. </p> <p>Both AI training (Neural Networks) and Crypto mining involve performing the same simple math calculation millions of times simultaneously. Since GPUs are designed for this \"Massively Parallel\" workload, they are much faster than CPUs for these specific tasks.</p>"},{"location":"modern_topics/computer_graphics/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning Pixel A single \"Picture Element\" (dot) on a screen. Raster An image made of pixels (fixed resolution). Vector An image made of math (infinite resolution). Rendering The process of generating an image from a model. GPU Hardware optimized for parallel graphics processing. <p>Computer graphics is where math meets art. By translating the abstract coordinate systems of geometry into the vibrant colors of the screen, we create the window through which we interact with the digital universe.</p>"},{"location":"modern_topics/ethics_in_computing/","title":"Ethics in Computing","text":"<p>In the early days of computer science, the primary focus was: \"Is this possible?\" Today, the question has shifted to: \"Is this right?\"</p> <p>As software becomes integrated into every aspect of our lives\u2014from healthcare and banking to policing and education\u2014the ethical decisions made by programmers have a massive impact on society. Computer Ethics is the study of the moral guidelines that govern the use of computers and information systems.</p>"},{"location":"modern_topics/ethics_in_computing/#1-algorithmic-bias","title":"1. Algorithmic Bias","text":"<p>A common myth is that computers are \"objective\" and \"neutral.\" However, a computer is only as good as its training data.</p> <p>If an AI system is trained on data that contains historical human bias, the system will learn and amplify that bias. This is called Algorithmic Bias.</p> <ul> <li>Example: A facial recognition system that works perfectly on light-skinned faces but fails on dark-skinned faces because it was trained primarily on photos of the former.</li> <li>Impact: This can lead to discrimination in hiring, loan approvals, and even criminal sentencing.</li> </ul>"},{"location":"modern_topics/ethics_in_computing/#2-privacy-and-surveillance","title":"2. Privacy and Surveillance","text":"<p>In the digital age, data is the new oil. Companies and governments collect vast amounts of information about our location, our searches, our health, and our conversations.</p> <p>The ethical dilemma is the Privacy vs. Convenience Trade-off.  -   We get free maps and search engines, but in exchange, we are tracked 24/7. -   Mass Surveillance: Using AI to track entire populations raises fundamental questions about freedom and human rights.</p>"},{"location":"modern_topics/ethics_in_computing/#3-the-digital-divide","title":"3. The Digital Divide","text":"<p>As technology becomes a requirement for participation in society (e.g., online banking, digital education), the gap between those who have access to high-speed internet and computers and those who don't\u2014the Digital Divide\u2014becomes a major ethical issue.</p> <p>If we don't ensure equal access, technology becomes a tool that increases social and economic inequality.</p>"},{"location":"modern_topics/ethics_in_computing/#4-automation-and-the-future-of-work","title":"4. Automation and the Future of Work","text":"<p>Artificial Intelligence and robotics are capable of performing tasks that once required human labor\u2014from factory work to legal analysis.</p> <ul> <li>The Positive: Increased efficiency and freeing humans from dangerous or boring tasks.</li> <li>The Ethical Concern: Mass displacement of workers. How does society support those whose jobs have been \"automated away\"?</li> </ul>"},{"location":"modern_topics/ethics_in_computing/#5-intellectual-property","title":"5. Intellectual Property","text":"<p>In a world where software can be copied perfectly for zero cost, how do we protect the work of creators?  -   Open Source: Is it an ethical duty to share code for the benefit of all? -   Copyright: Should a company be allowed to own a specific algorithm forever?</p>"},{"location":"modern_topics/ethics_in_computing/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Identifying Bias <p>A company uses an AI to screen resumes. The AI notices that, historically, the most successful employees lived in a specific wealthy neighborhood, so it starts automatically rejecting candidates from other neighborhoods. Is this an ethical issue?</p> Solution <p>Yes. </p> <p>This is a classic example of Algorithmic Bias. The AI is using \"neighborhood\" as a proxy for wealth and race, leading to unfair discrimination against qualified candidates based on where they live, rather than their skills.</p> Practice Problem 2: Privacy <p>A school installs software on students' laptops that uses the webcam to watch their eyes during exams to prevent cheating. What is the ethical concern here?</p> Solution <p>Privacy and Surveillance.</p> <p>While the goal (preventing cheating) is understandable, the method involves invasive surveillance of students in their private homes. It also raises concerns about Algorithmic Bias, as some students might have different eye movements due to medical conditions or neurodiversity.</p>"},{"location":"modern_topics/ethics_in_computing/#key-takeaways","title":"Key Takeaways","text":"Issue Core Question Bias Does the system treat everyone fairly? Privacy Who owns your data and who can see it? Access Does everyone have the opportunity to use this? Labor How does this change the lives of workers? <p>Software engineering is not just about writing code; it is about building the infrastructure of human society. Every line of code carries an ethical weight. As a \"System Mage,\" your responsibility is to ensure that your \"magic\" serves the common good and protects the vulnerable.</p>"},{"location":"modern_topics/generative_ai/","title":"Generative AI","text":"<p>Traditional AI is \"Discriminative.\" It looks at a photo and says, \"That's a cat.\" It looks at an email and says, \"That's spam.\" It classifies things that already exist.</p> <p>Generative AI is different. It creates new content\u2014text, images, music, or code\u2014that has never existed before.</p>"},{"location":"modern_topics/generative_ai/#1-large-language-models-llms","title":"1. Large Language Models (LLMs)","text":"<p>When you use ChatGPT or Gemini, you are talking to a Large Language Model. </p> <p>These models are \"Large\" because they have been trained on almost all the text on the public internet\u2014billions of books, articles, and code repositories. They are \"Models\" because they are mathematical representations of how human language works.</p>"},{"location":"modern_topics/generative_ai/#2-how-it-works-next-token-prediction","title":"2. How it Works: Next Token Prediction","text":"<p>Despite how smart it feels, an LLM is essentially a very powerful version of \"Auto-complete\" on your phone.</p> <ol> <li>Tokenization: The model breaks your text into small chunks called Tokens (words or parts of words).</li> <li>Probability: It looks at the tokens you just typed and calculates the mathematical probability of what the next token should be.</li> <li>Generation: It picks the most likely token, adds it to the sequence, and repeats the process.</li> </ol> <p>Example: -   Input: \"The capital of France is...\" -   Model calculation: \"Paris\" (99% probability), \"Lyon\" (0.5% probability). -   Output: \"Paris\"</p>"},{"location":"modern_topics/generative_ai/#3-the-magic-of-transformers","title":"3. The Magic of Transformers","text":"<p>The breakthrough that made modern Generative AI possible was the Transformer architecture (invented by Google in 2017). </p> <p>Transformers use a mechanism called Attention. It allows the model to look at every word in a sentence at once to understand context. </p> <p>In the sentence \"The bank was closed because the river flooded,\" the model uses Attention to know that \"bank\" refers to a river bank, not a money bank, because it sees the word \"river\" elsewhere in the sentence.</p>"},{"location":"modern_topics/generative_ai/#4-hallucinations-the-weakness","title":"4. Hallucinations: The Weakness","text":"<p>Because LLMs are based on probability, not truth, they can sometimes \"Hallucinate.\" </p> <p>They might generate a sentence that sounds perfectly confident and grammatically correct but is factually wrong. They aren't \"lying\"\u2014they are simply picking the most probable word sequence according to their training, even if that sequence doesn't match reality.</p>"},{"location":"modern_topics/generative_ai/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Generative or Discriminative? <p>You use an app that takes a photo of a receipt and automatically extracts the Total Price and the Tax amount. Is this Generative AI?</p> Solution <p>No. </p> <p>This is Discriminative AI (or Computer Vision). It is identifying and classifying existing data on the receipt. If the app used that data to write a funny poem about your shopping habits, that would be Generative AI.</p> Practice Problem 2: Next Token Prediction <p>If an LLM is asked to complete the sentence \"The sun rises in the...\", why does it pick \"East\"?</p> Solution <p>Because in its training data (billions of sentences), the token \"East\" followed that specific sequence of words more often than any other token. It is a mathematical prediction based on patterns in human language.</p>"},{"location":"modern_topics/generative_ai/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning Generative AI AI that creates new data. LLM An AI trained on massive amounts of text. Transformer The architecture that allows AI to understand context. Token The basic unit of text the AI processes. Hallucination When an AI generates factually incorrect information. <p>Generative AI has transformed the computer from a tool that processes our work into a partner that collaborates on it. While it lacks true \"understanding,\" its ability to map the vast patterns of human creativity makes it one of the most powerful inventions in the history of computer science.</p>"},{"location":"programming_languages/compilers_vs_interpreters/","title":"Compilers vs. Interpreters","text":"<p>Computers are incredibly fast, but they are also incredibly simple. They cannot understand Python, Java, or C. They only understand Machine Code\u2014a series of 0s and 1s that tell the CPU exactly which electrical gates to open and close.</p> <p>To bridge the gap between human-readable code and machine-executable bits, we use a translator. There are two main ways to translate: Compiling and Interpreting.</p>"},{"location":"programming_languages/compilers_vs_interpreters/#1-the-compiler-the-book-translator","title":"1. The Compiler: The Book Translator","text":"<p>Imagine you have a book written in Spanish, but you only speak English. You hire a translator to read the entire book and write a new version in English. Once the translation is finished, you can read the English book as many times as you want without needing the translator again.</p> <p>How it works: 1.  Source Code (e.g., C++ file) is fed into the Compiler. 2.  The Compiler analyzes the entire program and translates it into Machine Code (an <code>.exe</code> or binary file). 3.  The computer runs the binary file directly.</p> <p>Pros: -   Speed: Since the translation is already done, the program runs at the full speed of the hardware. -   Security: You don't have to share your original source code with the user.</p> <p>Examples: C, C++, Rust, Go.</p>"},{"location":"programming_languages/compilers_vs_interpreters/#2-the-interpreter-the-live-translator","title":"2. The Interpreter: The Live Translator","text":"<p>Now imagine you are at a United Nations meeting. A diplomat is speaking Spanish, and you are wearing headphones. A translator listens to one sentence in Spanish and immediately tells it to you in English. Then they listen to the next sentence.</p> <p>How it works: 1.  The Interpreter reads one line of source code. 2.  It translates that line into instructions the computer can perform immediately. 3.  It moves to the next line.</p> <p>Pros: -   Flexibility: You can change your code and run it immediately without waiting for a long \"build\" process. -   Debugging: The interpreter can stop exactly on the line where an error occurred.</p> <p>Examples: Python (high level), JavaScript, Ruby.</p>"},{"location":"programming_languages/compilers_vs_interpreters/#the-hybrid-approach-bytecode","title":"The Hybrid Approach: Bytecode","text":"<p>If you've used Python or Java, you might be confused. Python feels like an interpreter, but it generates <code>.pyc</code> files. Java is \"compiled\" to <code>.class</code> files, but it needs a \"Java Virtual Machine\" (JVM) to run.</p> <p>These languages use a Hybrid Approach: 1.  The Compiler translates the source code into an intermediate language called Bytecode. 2.  The Virtual Machine (the Interpreter) reads the bytecode and executes it.</p> <p>This allows the same code to run on any computer (Windows, Mac, Linux) as long as that computer has the Virtual Machine installed.</p> Feature Compiler Interpreter Execution Faster (ready to run). Slower (translating on the fly). Errors Found all at once (before running). Found one by one (during execution). Portability Target-specific (needs re-compiling for Mac vs PC). Cross-platform (runs anywhere with the interpreter)."},{"location":"programming_languages/compilers_vs_interpreters/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: The Fast Runner <p>You are building a high-frequency trading application where every microsecond matters. Would you choose a compiled language or an interpreted language?</p> Solution <p>Compiled. </p> <p>A compiled language like C++ or Rust turns into native machine code. An interpreter adds \"overhead\" because it has to analyze and translate code while the program is running, which is too slow for high-performance needs.</p> Practice Problem 2: The Quick Script <p>You want to write a small script to rename 500 files on your computer. You want to write it, test it, and be done in 10 minutes. Which type of language is better?</p> Solution <p>Interpreted.</p> <p>Languages like Python or Bash are perfect for this. You don't want to wait for a compiler to link libraries and build a binary just to rename some files. You want immediate feedback and quick iteration.</p>"},{"location":"programming_languages/compilers_vs_interpreters/#key-takeaways","title":"Key Takeaways","text":"Term Meaning Source Code The high-level code humans write. Machine Code The 1s and 0s the CPU understands. Binary/Executable The output of a compiler. Bytecode An intermediate format used by hybrid languages like Python/Java. <p>Whether you choose a compiler for its raw speed or an interpreter for its flexibility, both tools serve the same purpose: taking the abstract logic of the human mind and grounding it in the physical reality of the machine.</p>"},{"location":"programming_languages/how_interpreters_work/","title":"How Interpreters Work: Tokens, Parsing, and Evaluation","text":"<p>When you type <code>x = 5 + 10</code> into a Python terminal, the computer doesn't see \"math.\" It sees a string of characters: <code>x</code>, space, <code>=</code>, space, <code>5</code>, space, <code>+</code>, space, <code>1</code>, <code>0</code>.</p> <p>To turn this raw text into action, an Interpreter follows a three-step assembly line: Tokenizing, Parsing, and Evaluating.</p>"},{"location":"programming_languages/how_interpreters_work/#step-1-the-tokenizer-lexer","title":"Step 1: The Tokenizer (Lexer)","text":"<p>The first step is to break the text into meaningful chunks called Tokens. </p> <p>Think of this like breaking a sentence into individual words. A space isn't a word, but it helps you see where one word ends and the next begins.</p> <p>For the input <code>x = 5 + 10</code>, the Tokenizer produces a list like this: 1.  <code>NAME</code> (\"x\") 2.  <code>EQUALS</code> (\"=\") 3.  <code>NUMBER</code> (5) 4.  <code>PLUS</code> (\"+\") 5.  <code>NUMBER</code> (10)</p> <p>The Tokenizer ignores \"noise\" like extra spaces or comments. It just wants to know the \"vocabulary\" of your line.</p>"},{"location":"programming_languages/how_interpreters_work/#step-2-the-parser","title":"Step 2: The Parser","text":"<p>Now that we have a list of tokens, we need to understand the Grammar. Is <code>5 + = x</code> a valid sentence? The Tokenizer says yes (those are all valid words), but the Parser says no (that's a nonsense sentence).</p> <p>The Parser organizes the tokens into a structure called a Syntax Tree (or Abstract Syntax Tree - AST).</p> <p>For <code>x = 5 + 10</code>, the tree looks like this:</p> <pre><code>graph TD\n    A[Assignment] --&gt; B[x]\n    A --&gt; C[Addition]\n    C --&gt; D[5]\n    C --&gt; E[10]\n\n    classDef default fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>The Parser ensures that the code follows the rules of the language (e.g., you can't have two plus signs in a row). If the tree can't be built, you get a Syntax Error.</p>"},{"location":"programming_languages/how_interpreters_work/#step-3-the-evaluator","title":"Step 3: The Evaluator","text":"<p>The final step is the Evaluator. It \"walks\" the tree and performs the actual calculations.</p> <ol> <li>It sees the Addition node.</li> <li>It looks at the children: <code>5</code> and <code>10</code>.</li> <li>It performs the addition (\\(5 + 10 = 15\\)).</li> <li>It sees the Assignment node.</li> <li>It stores the value <code>15</code> in the memory location for <code>x</code>.</li> </ol>"},{"location":"programming_languages/how_interpreters_work/#recursive-descent-parsing","title":"Recursive Descent Parsing","text":"<p>One common way to build the Parser is through Recursive Descent.</p> <p>In this method, the Parser has a dedicated function for every rule in the language (e.g., <code>parse_expression()</code>, <code>parse_statement()</code>, <code>parse_loop()</code>). These functions call each other recursively to \"descend\" through the levels of the tree.</p> <ul> <li>To parse an Assignment, it calls the function to parse a Value.</li> <li>To parse a Value, it might call the function to parse an Expression.</li> </ul> <p>This \"divide and conquer\" approach makes it possible to handle complex, nested code like <code>x = (5 + (2 * 3))</code>.</p>"},{"location":"programming_languages/how_interpreters_work/#summary-the-interpreter-pipeline","title":"Summary: The Interpreter Pipeline","text":"Component Responsibility Output Tokenizer Break text into \"words\". List of Tokens. Parser Check the \"grammar\" and structure. Syntax Tree (AST). Evaluator Execute the logic. Results / State Changes."},{"location":"programming_languages/how_interpreters_work/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Tokenizing <p>What are the tokens in the expression <code>y = x * 2</code>?</p> Solution <ol> <li><code>NAME</code> (\"y\")</li> <li><code>EQUALS</code> (\"=\")</li> <li><code>NAME</code> (\"x\")</li> <li><code>MULTIPLY</code> (\"*\")</li> <li><code>NUMBER</code> (2)</li> </ol> Practice Problem 2: Syntax Error <p>At which stage would the error <code>5 + * 10</code> be caught?</p> Solution <p>The Parser.</p> <p>The Tokenizer would successfully identify the <code>5</code>, <code>+</code>, <code>*</code>, and <code>10</code>. However, when the Parser tries to build a tree, it will see that a <code>*</code> cannot immediately follow a <code>+</code>. Since this breaks the grammar rules, the Parser throws a Syntax Error.</p> <p>By understanding how interpreters break down, structure, and execute our code, we gain a deeper appreciation for the \"magic\" that happens every time we hit the Enter key in a programming environment.</p>"},{"location":"programming_languages/oop_classes_and_objects/","title":"Oop classes and objects","text":""},{"location":"programming_languages/oop_classes_and_objects/#description-the-foundation-of-object-oriented-programming-understanding-classes-as-blueprints-and-objects-as-instances","title":"description: The foundation of Object-Oriented Programming: Understanding Classes as blueprints and Objects as instances.","text":""},{"location":"programming_languages/oop_classes_and_objects/#oop-classes-objects","title":"OOP: Classes &amp; Objects","text":"<p>In early programming, software was just a list of instructions (Procedural Programming). If you wanted to simulate a car, you\u2019d have variables for <code>car_color</code>, <code>car_speed</code>, and a function <code>drive(car_speed)</code>.</p> <p>As programs got larger, this \"spaghetti of variables\" became impossible to manage. Object-Oriented Programming (OOP) solved this by grouping data and behavior together into \"Objects.\"</p>"},{"location":"programming_languages/oop_classes_and_objects/#the-blueprint-the-class","title":"The Blueprint: The Class","text":"<p>Imagine you are an architect. You draw up a set of plans for a house. These plans aren't a house\u2014you can't live in them\u2014but they describe exactly what every house built from those plans will look like.</p> <p>In OOP, the Class is the blueprint. It defines: 1.  Attributes (Properties): What the object knows (data). 2.  Methods (Functions): What the object does (behavior).</p>"},{"location":"programming_languages/oop_classes_and_objects/#the-reality-the-object","title":"The Reality: The Object","text":"<p>When a builder takes those plans and builds an actual house on a specific lot, that is an Object (or an Instance). </p> <p>You can use the same Class (blueprint) to create thousands of Objects (houses). Each house will have its own unique color or address, but they all share the same structure defined by the Class.</p>"},{"location":"programming_languages/oop_classes_and_objects/#example-a-video-game-character","title":"Example: A Video Game Character","text":"<p>Let's define a Class for a Player in an RPG.</p> <p>The Class (<code>Player</code>): -   Attributes: <code>name</code>, <code>health</code>, <code>level</code>. -   Methods: <code>take_damage()</code>, <code>heal()</code>, <code>talk()</code>.</p> <p>The Objects (Instances): -   Object 1: <code>name=\"Brad\"</code>, <code>health=100</code>, <code>level=5</code>. -   Object 2: <code>name=\"Goblin\"</code>, <code>health=20</code>, <code>level=1</code>.</p>"},{"location":"programming_languages/oop_classes_and_objects/#code-example-python","title":"Code Example (Python)","text":"Class and Object in Python<pre><code>class Player:\n    def __init__(self, name, health):  # (1)!\n        self.name = name  # (2)!\n        self.health = health\n\n    def take_damage(self, amount):  # (3)!\n        self.health -= amount\n        print(f\"{self.name} took {amount} damage. Health: {self.health}\")\n\n# Creating Objects (Instantiation)\nhero = Player(\"Aragorn\", 100)\nvillain = Player(\"Sauron\", 500)\n\n# Calling Methods\nhero.take_damage(10) # Aragorn took 10 damage. Health: 90\n</code></pre> <ol> <li>The <code>__init__</code> method is the \"Constructor\"\u2014it's called when you create a new object.</li> <li><code>self</code> refers to the specific instance of the object being worked on.</li> <li><code>take_damage</code> is a Method that changes the object's internal state.</li> </ol>"},{"location":"programming_languages/oop_classes_and_objects/#why-use-objects","title":"Why Use Objects?","text":"<ol> <li>Organization: Related data and functions stay together.</li> <li>Abstraction: You don't need to know how <code>hero.take_damage()</code> works inside; you just call it.</li> <li>Reuse: You write the <code>Player</code> class once and use it for every character in the game.</li> <li>Modeling: It's easier for humans to think about \"Objects\" (Cars, Users, Accounts) than \"Arrays and Integers.\"</li> </ol>"},{"location":"programming_languages/oop_classes_and_objects/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Class vs. Object <p>If \"Dog\" is the Class, what are some examples of Objects?</p> Solution <ul> <li>Your dog, \"Fido\" (a Golden Retriever).</li> <li>The neighbor's dog, \"Rex\" (a Bulldog).</li> <li>A cartoon dog, \"Snoopy\".</li> </ul> <p>They are all \"Dog\" objects because they share the same attributes (breed, name) and behaviors (bark, eat, sleep).</p> Practice Problem 2: Identify Attribute vs. Method <p>In a <code>BankAccount</code> class, which of these is an Attribute and which is a Method? 1. <code>balance</code> 2. <code>withdraw()</code> 3. <code>account_number</code> 4. <code>deposit()</code></p> Solution <ul> <li>Attributes: <code>balance</code>, <code>account_number</code> (These are data).</li> <li>Methods: <code>withdraw()</code>, <code>deposit()</code> (These are actions/behaviors).</li> </ul>"},{"location":"programming_languages/oop_classes_and_objects/#key-takeaways","title":"Key Takeaways","text":"Term Definition Analogy Class The template or blueprint. Architectural plans. Object A specific instance of a class. The physical house. Attribute Data stored inside an object. Color of the house. Method A function defined inside a class. Opening the door. <p>Classes and Objects are the building blocks of modern software engineering. By modeling our code after the real world, we can build systems that are more intuitive, more organized, and easier to scale.</p>"},{"location":"programming_languages/oop_encapsulation/","title":"Oop encapsulation","text":""},{"location":"programming_languages/oop_encapsulation/#description-oop-encapsulation-hiding-complexity-behind-clean-interfaces","title":"description: OOP Encapsulation: Hiding complexity behind clean interfaces.","text":""},{"location":"programming_languages/oop_encapsulation/#oop-encapsulation","title":"OOP: Encapsulation","text":"<p>Imagine you are using a TV remote. To turn up the volume, you press a button labeled <code>+</code>. You don't need to open the remote, touch the copper wires, or understand the infrared signals being sent. The complex internal \"wiring\" is hidden from you, and you are given a simple \"interface\" (the buttons).</p> <p>In programming, this is called Encapsulation. It is the practice of bundling data and the methods that act on that data into a single unit (the Class) and restricting access to the internal details.</p>"},{"location":"programming_languages/oop_encapsulation/#the-black-box-concept","title":"The \"Black Box\" Concept","text":"<p>Encapsulation turns an object into a \"Black Box.\" </p> <ul> <li>The Interface (Public): The methods and attributes that the outside world is allowed to see and use.</li> <li>The Implementation (Private): The internal logic and variables that are hidden from the outside world.</li> </ul>"},{"location":"programming_languages/oop_encapsulation/#why-hide-the-details","title":"Why Hide the Details?","text":"<ol> <li>Protection (Integrity): If a <code>BankAccount</code> object has a <code>balance</code> variable, you don't want other parts of the program setting <code>balance = -1000000</code> directly. By making it private, you force users to go through a <code>withdraw()</code> method that checks if they have enough money first.</li> <li>Flexibility: You can change how the \"wiring\" works inside the object without breaking the rest of the program. As long as the <code>+</code> button on the remote still turns up the volume, the user doesn't care if you replaced the circuit board inside.</li> <li>Simplicity: Users of your class don't need to understand its 500 lines of internal logic; they just need to know the 3 methods they can call.</li> </ol>"},{"location":"programming_languages/oop_encapsulation/#getters-and-setters-the-security-guards","title":"Getters and Setters: The Security Guards","text":"<p>If we make our data private, how do we see or change it? We use \"Security Guard\" methods:</p> <ul> <li>Getter: A method that returns the value (e.g., <code>get_balance()</code>).</li> <li>Setter: A method that validates and updates the value (e.g., <code>set_balance(amount)</code>).</li> </ul>"},{"location":"programming_languages/oop_encapsulation/#code-example-python","title":"Code Example (Python)","text":"<p>In Python, we use a single underscore <code>_</code> or double underscore <code>__</code> to indicate that a variable is \"private\" (by convention).</p> Encapsulation in Python<pre><code>class BankAccount:\n    def __init__(self, owner, balance):\n        self.owner = owner\n        self._balance = balance  # (1)!\n\n    def deposit(self, amount):\n        if amount &gt; 0:\n            self._balance += amount\n            print(f\"Deposited {amount}. New balance: {self._balance}\")\n        else:\n            print(\"Invalid deposit amount!\")\n\n    def get_balance(self):  # (2)!\n        return self._balance\n\n# Usage\nmy_account = BankAccount(\"Brad\", 1000)\n\n# my_account._balance = -5000  # (3)!\nmy_account.deposit(500)      # (4)!\nprint(my_account.get_balance())\n</code></pre> <ol> <li>The underscore <code>_</code> tells other programmers: \"This is internal, don't touch it directly!\"</li> <li>A Getter method provides a safe way to view the balance.</li> <li>DON'T DO THIS: Accessing the private variable directly is bad practice and bypasses the rules.</li> <li>DO THIS: Interact with the object through its public interface.</li> </ol>"},{"location":"programming_languages/oop_encapsulation/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: The Remote Control <p>In our TV Remote analogy, which of these is part of the Interface and which is part of the Implementation? 1. The plastic \"Power\" button. 2. The specific frequency of the infrared light. 3. The battery voltage sensor logic. 4. The \"Channel Up\" button.</p> Solution <ul> <li>Interface: Power button, Channel Up button (These are the \"Public\" parts we interact with).</li> <li>Implementation: Infrared frequency, Battery sensor logic (These are the \"Private\" internal details).</li> </ul> Practice Problem 2: Validation <p>Why is a Setter method better than letting someone change a variable directly?</p> Solution <p>A Setter allows for validation. For example, if you have a <code>Person</code> class with an <code>age</code> attribute, a <code>set_age()</code> method can prevent someone from setting the age to <code>-5</code> or <code>500</code>. Direct access has no way to enforce these rules.</p>"},{"location":"programming_languages/oop_encapsulation/#key-takeaways","title":"Key Takeaways","text":"Term Meaning Encapsulation Bundling data/methods and hiding internal details. Public Interface The methods and properties intended for outside use. Private State Data that should only be modified by the object itself. Getter/Setter Methods used to safely interact with private data. <p>Encapsulation is about trust. By hiding the complexity and protecting the data, you create objects that are reliable, secure, and easy to maintain. It is the first step toward building professional-grade software.</p>"},{"location":"programming_languages/oop_inheritance/","title":"OOP: Inheritance","text":"<p>In the real world, we naturally group things into hierarchies. A German Shepherd is a type of Dog, and a Dog is a type of Mammal. Because a German Shepherd is a Dog, it automatically has certain traits (four legs, fur, barking) without us needing to redefine them every time.</p> <p>In programming, this is called Inheritance. It allows us to create a new class (the Child) that \"inherits\" all the attributes and methods of an existing class (the Parent).</p>"},{"location":"programming_languages/oop_inheritance/#the-is-a-relationship","title":"The \"Is-A\" Relationship","text":"<p>The golden rule of inheritance is the \"Is-A\" Relationship. You should only use inheritance if the child truly \"is a\" version of the parent.</p> <ul> <li>A Square \"is a\" Shape. (Inheritance makes sense)</li> <li>A Laptop \"is a\" Computer. (Inheritance makes sense)</li> <li>A Car \"is a\" Steering Wheel. (No. A car has a steering wheel, but it is not one. This is a different concept called \"Composition\").</li> </ul>"},{"location":"programming_languages/oop_inheritance/#parent-vs-child-classes","title":"Parent vs. Child Classes","text":"<ul> <li>Parent Class (Base Class): The general class containing shared logic.</li> <li>Child Class (Derived Class): The specific class that inherits from the parent and adds its own unique features.</li> </ul>"},{"location":"programming_languages/oop_inheritance/#why-use-inheritance","title":"Why Use Inheritance?","text":"<ol> <li>Code Reuse (DRY): You don't have to rewrite the same code for <code>Car</code>, <code>Truck</code>, and <code>Motorcycle</code> if they all share a <code>start_engine()</code> method. You put that in the <code>Vehicle</code> parent class once.</li> <li>Extensibility: You can create a specialized version of a class without modifying the original code.</li> <li>Hierarchy: It creates a logical structure for your software that reflects the real world.</li> </ol>"},{"location":"programming_languages/oop_inheritance/#method-overriding","title":"Method Overriding","text":"<p>Sometimes a child class inherits a method but needs to change how it works. This is called Overriding.</p> <p>For example, every <code>Animal</code> might have a <code>make_sound()</code> method. But a <code>Dog</code> should override it to \"Bark,\" while a <code>Cat</code> overrides it to \"Meow.\"</p>"},{"location":"programming_languages/oop_inheritance/#code-example-python","title":"Code Example (Python)","text":"Inheritance in Python<pre><code>class Vehicle: # (1)!\n    def __init__(self, brand):\n        self.brand = brand\n\n    def drive(self):\n        print(f\"The {self.brand} is moving.\")\n\nclass ElectricCar(Vehicle): # (2)!\n    def __init__(self, brand, battery_size):\n        super().__init__(brand) # (3)!\n        self.battery_size = battery_size\n\n    def drive(self): # (4)!\n        print(f\"The {self.brand} is gliding silently on {self.battery_size}kWh.\")\n\n# Usage\nmy_tesla = ElectricCar(\"Tesla\", 75)\nmy_tesla.drive() # Output: The Tesla is gliding silently on 75kWh.\n</code></pre> <ol> <li>Parent Class: A general <code>Vehicle</code>.</li> <li>Child Class: <code>ElectricCar</code> inherits from <code>Vehicle</code>.</li> <li><code>super()</code>: This special function calls the constructor of the parent class so we can still set the <code>brand</code>.</li> <li>Overriding: We provide a new version of <code>drive</code> specifically for electric cars.</li> </ol>"},{"location":"programming_languages/oop_inheritance/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Identify the Parent <p>In a software system for a library, you have classes for <code>Book</code>, <code>Magazine</code>, and <code>DVD</code>. What would be a good Parent Class for these?</p> Solution <p>A good parent class would be <code>LibraryItem</code> or <code>Resource</code>. </p> <p>All three share attributes like <code>title</code>, <code>call_number</code>, and <code>is_checked_out</code>, so those should live in the parent class.</p> Practice Problem 2: The Is-A Test <p>Does it make sense for a <code>SmartPhone</code> class to inherit from a <code>Screen</code> class? Why or why not?</p> Solution <p>No.</p> <p>A <code>SmartPhone</code> is not a <code>Screen</code>. A smartphone has a screen. This fails the \"Is-A\" test. Inheritance here would lead to confusing code. A better approach is to have the <code>SmartPhone</code> class contain an instance of a <code>Screen</code> class as an attribute.</p>"},{"location":"programming_languages/oop_inheritance/#key-takeaways","title":"Key Takeaways","text":"Term Meaning Inheritance Creating a new class based on an existing one. Parent Class The base class that provides the foundation. Child Class The derived class that inherits and extends. super() A way to access methods from the parent class. Overriding Replacing a parent's method with a new version in the child. <p>Inheritance is the foundation of building complex systems. It allows us to start with simple, general ideas and refine them into specific, powerful tools\u2014all while keeping our code clean, organized, and reusable. \ud83c\udf33</p>"},{"location":"programming_languages/oop_polymorphism/","title":"OOP: Polymorphism","text":"<p>The word Polymorphism comes from the Greek words poly (many) and morph (form). In computer science, it refers to the ability of different objects to respond to the same command in their own unique way.</p> <p>Imagine you have a universal remote with a \"Play\" button.  -   If you point it at a CD Player, it starts spinning a disc. -   If you point it at a Netflix App, it starts streaming a digital file. -   If you point it at a YouTube Tab, it resumes a video.</p> <p>The command is the same: \"Play.\" But the form of the action depends entirely on which object is receiving the command.</p>"},{"location":"programming_languages/oop_polymorphism/#one-interface-many-actions","title":"One Interface, Many Actions","text":"<p>Polymorphism allows us to write a single piece of code that can interact with many different types of objects, as long as they share the same \"interface\" (method names).</p>"},{"location":"programming_languages/oop_polymorphism/#why-does-this-matter","title":"Why Does This Matter?","text":"<p>Without polymorphism, if you wanted to draw a list of shapes, you would have to write complex <code>if</code> statements: \"If it's a circle, use <code>draw_circle()</code>. If it's a square, use <code>draw_square()</code>.\"</p> <p>With polymorphism, you just say: \"Draw everything.\" Every object knows how to draw itself.</p>"},{"location":"programming_languages/oop_polymorphism/#how-it-works-overriding","title":"How it Works: Overriding","text":"<p>Polymorphism is the natural result of Inheritance and Method Overriding. </p> <p>When a Child class provides its own version of a Parent's method, it is participating in polymorphism. The computer decides at runtime which version of the method to call based on the specific object it is holding.</p>"},{"location":"programming_languages/oop_polymorphism/#duck-typing-the-python-way","title":"Duck Typing (The Python Way)","text":"<p>In some languages (like Java), you must explicitly use inheritance to achieve polymorphism. Python is more relaxed. It uses Duck Typing:</p> <p>\"If it walks like a duck and it quacks like a duck, then it must be a duck.\"</p> <p>In Python, if an object has a <code>move()</code> method, you can use it in a function that expects things to move, regardless of whether that object is a <code>Car</code>, a <code>Person</code>, or a <code>Glacier</code>.</p>"},{"location":"programming_languages/oop_polymorphism/#code-example-python","title":"Code Example (Python)","text":"Polymorphism in Python<pre><code>class Dog:\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat:\n    def speak(self):\n        return \"Meow!\"\n\nclass Duck:\n    def speak(self):\n        return \"Quack!\"\n\n# A function that doesn't care what the animal is, \n# as long as it can 'speak'.\ndef animal_concert(animals): # (1)!\n    for animal in animals:\n        print(animal.speak()) # (2)!\n\n# Usage\npets = [Dog(), Cat(), Duck()]\nanimal_concert(pets)\n</code></pre> <ol> <li>This function is polymorphic. It can handle a list of anything.</li> <li>The computer doesn't know if <code>animal</code> is a Dog or a Cat until the loop actually runs. It just looks for the <code>.speak()</code> method and calls the right version.</li> </ol>"},{"location":"programming_languages/oop_polymorphism/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: The Remote Control <p>You are building a game with <code>Warrior</code>, <code>Mage</code>, and <code>Archer</code> classes. All of them inherit from a <code>Character</code> class that has an <code>attack()</code> method. </p> <p>If you have a list called <code>party</code> containing one of each, and you run: <pre><code>for member in party:\n    member.attack()\n</code></pre> Which pillar of OOP are you using?</p> Solution <p>Polymorphism.</p> <p>Even though the list contains different types of objects, you are treating them all as \"Characters\" and calling the same <code>attack()</code> method. Each object will execute its own specific version of that method (Sword swing, Fireball, or Arrow shot).</p> Practice Problem 2: Benefits <p>What is the main advantage of using polymorphism in a large software project?</p> Solution <p>Flexibility and Maintainability.</p> <p>You can add a new type of object (e.g., a <code>Necromancer</code> class) without having to change any of the existing code that handles characters. As long as the <code>Necromancer</code> has an <code>attack()</code> method, it will work perfectly with your existing loops and systems.</p>"},{"location":"programming_languages/oop_polymorphism/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning Polymorphism \"Many forms.\" One interface used for different types. Overriding Replacing a parent method to provide a specific polymorphic behavior. Interface The set of methods an object promises to have. Duck Typing Python's style of polymorphism based on behavior, not inheritance. <p>Polymorphism is the ultimate tool for decoupling your code. It allows you to write high-level logic that doesn't get bogged down in the specific details of every single object, making your software more flexible, more scalable, and truly elegant. \ud83c\udfad</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/","title":"Procedures and Higher-Order Functions","text":"<p>When you calculate the total price of an item including tax, you don't rederive the formula every time. You have a mental procedure: multiply the price by the tax rate, add the result to the original price, done. When a chef teaches an apprentice to make a sauce, they don't list every molecular interaction\u2014they provide a procedure: heat butter, add flour, whisk until smooth, gradually add milk.</p> <p>Procedures are recipes for computation. They package sequences of steps into reusable units with names. But what happens when procedures themselves become ingredients\u2014when you pass one procedure to another, or return a new procedure as a result? That's when you enter the realm of higher-order functions, one of the most powerful ideas in computer science.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#what-is-a-procedure","title":"What is a Procedure?","text":"<p>A procedure (also called a function, subroutine, or method) is a named sequence of instructions that performs a specific task.</p> Terminology Across Languages <p>While we use the general term \"procedure,\" you'll encounter different names depending on the language you use:</p> <ul> <li>Functions: The most common term. Used in Python (<code>def</code>), JavaScript (<code>function</code>), C, C++, Go (<code>func</code>), and Rust (<code>fn</code>).</li> <li>Methods: Used in Java, C#, and Ruby. This term usually refers to a function that is part of a class or an object.</li> <li>Subroutines: Often used in Fortran, BASIC, and Assembly language.</li> <li>Procedures: Specifically used in Pascal and Ada (often to distinguish functions that do not return a value from those that do).</li> </ul> <p>Key characteristics:</p> <ul> <li>Name: Identifies the procedure (<code>calculateTotal</code>, <code>sortList</code>, <code>findMax</code>)</li> <li>Parameters: Inputs the procedure needs (also called arguments)</li> <li>Body: The sequence of steps to execute</li> <li>Return value: Output the procedure produces (optional)</li> </ul>"},{"location":"programming_languages/procedures_and_higher_order_functions/#the-vending-machine-analogy","title":"The Vending Machine Analogy","text":"<p>Think of a procedure like a vending machine. You don't need to know how the gears turn inside; you just need to know what to put in and what you'll get out.</p> <pre><code>graph LR\n    Input(&lt;b&gt;Parameters&lt;/b&gt;&lt;br&gt;Coins &amp; Selection) --&gt; Process[&lt;b&gt;Procedure Body&lt;/b&gt;&lt;br&gt;Internal Mechanism]\n    Process --&gt; Output(&lt;b&gt;Return Value&lt;/b&gt;&lt;br&gt;Snack)\n\n    style Input fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Process fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style Output fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <ul> <li>Parameters (Inputs): You insert coins and press a button.</li> <li>Body (The Black Box): The internal mechanism does the work. You don't see or worry about the motors and sensors.</li> <li>Return Value (Output): You receive your snack.</li> </ul> <p>The machine's internal complexity is hidden\u2014you only interact through its interface.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#pseudocode-a-language-neutral-format","title":"Pseudocode: A Language-Neutral Format","text":"<p>Pseudocode is a way to describe algorithms without committing to a specific programming language's syntax. It prioritizes clarity and readability over executability.</p> <p>Characteristics:</p> <ul> <li>Uses plain English mixed with programming constructs</li> <li>No strict syntax rules (as long as meaning is clear)</li> <li>Focuses on logic, not implementation details</li> </ul> <p>Common conventions:</p> Construct Pseudocode Example Assignment <code>x \u2190 5</code> or <code>x = 5</code> Function call <code>result \u2190 calculateTax(100, 0.05)</code> If statement <code>if x &gt; 0 then</code> ... <code>endif</code> Loop <code>while x &lt; 10 do</code> ... <code>endwhile</code> Function definition <code>function name(param1, param2)</code> ... <code>return value</code> Comment <code>// This is a comment</code>"},{"location":"programming_languages/procedures_and_higher_order_functions/#why-use-pseudocode","title":"Why Use Pseudocode?","text":"<ol> <li>Language-agnostic: Describe algorithms before choosing Python, Java, C++, etc.</li> <li>Focus on logic: Don't get bogged down in syntax details</li> <li>Communication: Share ideas with non-programmers or different dev teams</li> <li>Planning: Design before coding (avoiding premature implementation)</li> </ol>"},{"location":"programming_languages/procedures_and_higher_order_functions/#defining-a-simple-procedure","title":"Defining a Simple Procedure","text":""},{"location":"programming_languages/procedures_and_higher_order_functions/#anatomy-of-a-procedure","title":"Anatomy of a Procedure","text":"<p>Before we look at examples, let's understand the basic structure of a procedure.</p> <p>Structure:</p> <pre><code>function name(parameter1, parameter2, ...)\n    // Procedure body: sequence of statements\n    // Can include variables, conditionals, loops, etc.\n    return value  // Optional\nendfunction\n</code></pre> <p>Components:</p> Component Purpose Example Name Identifies the procedure <code>COMP-COST</code> Parameters Inputs (can be zero or more) <code>price</code>, <code>taxRate</code> Body Steps to execute <code>salesTax \u2190 price * taxRate</code> Return Output value <code>return totalCost</code> <p>Parameters vs. Arguments:</p> <ul> <li>Parameters: Variables in the function definition (<code>price</code>, <code>taxRate</code>)</li> <li>Arguments: Actual values passed when calling (<code>100</code>, <code>0.05</code>)</li> </ul>"},{"location":"programming_languages/procedures_and_higher_order_functions/#examples","title":"Examples","text":"Squaring a NumberComputing Total Cost <p>Task: Create a procedure that squares a number.</p>  Pseudocode Python JavaScript Go Rust Java C++ <pre><code>function square(x)\n    result \u2190 x * x\n    return result\nendfunction\n</code></pre> <p>Usage:</p> <pre><code>answer \u2190 square(5)    // answer = 25\n</code></pre> Square Function<pre><code>def square(x):\n    result = x * x\n    return result\n</code></pre> Square Function<pre><code>function square(x) {\n    let result = x * x;\n    return result;\n}\n</code></pre> Square Function<pre><code>func square(x int) int {\n    result := x * x\n    return result\n}\n</code></pre> Square Function<pre><code>fn square(x: i32) -&gt; i32 {\n    let result = x * x;\n    return result; // or just 'x * x'\n}\n</code></pre> Square Function<pre><code>public static int square(int x) {\n    int result = x * x;\n    return result;\n}\n</code></pre> Square Function<pre><code>int square(int x) {\n    int result = x * x;\n    return result;\n}\n</code></pre> <p>Task: Calculate the total cost of an item including sales tax.</p>  Pseudocode Python JavaScript Go Rust Java C++ <pre><code>function COMP-COST(price, taxRate)\n    salesTax \u2190 price * taxRate\n    totalCost \u2190 price + salesTax\n    return totalCost\nendfunction\n</code></pre> <p>Usage:</p> <pre><code>total \u2190 COMP-COST(100, 0.05)\n// total = 105\n</code></pre> Total Cost Function<pre><code>def comp_cost(price, tax_rate):\n    sales_tax = price * tax_rate\n    total_cost = price + sales_tax\n    return total_cost\n</code></pre> Total Cost Function<pre><code>function compCost(price, taxRate) {\n    let salesTax = price * taxRate;\n    let totalCost = price + salesTax;\n    return totalCost;\n}\n</code></pre> Total Cost Function<pre><code>func compCost(price float64, taxRate float64) float64 {\n    salesTax := price * taxRate\n    totalCost := price + salesTax\n    return totalCost\n}\n</code></pre> Total Cost Function<pre><code>fn comp_cost(price: f64, tax_rate: f64) -&gt; f64 {\n    let sales_tax = price * tax_rate;\n    let total_cost = price + sales_tax;\n    return total_cost;\n}\n</code></pre> Total Cost Function<pre><code>public static double compCost(double price, double taxRate) {\n    double salesTax = price * taxRate;\n    double totalCost = price + salesTax;\n    return totalCost;\n}\n</code></pre> Total Cost Function<pre><code>double compCost(double price, double taxRate) {\n    double salesTax = price * taxRate;\n    double totalCost = price + salesTax;\n    return totalCost;\n}\n</code></pre>"},{"location":"programming_languages/procedures_and_higher_order_functions/#why-procedures-matter","title":"Why Procedures Matter","text":"<p>Procedures provide:</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#1-abstraction","title":"1. Abstraction","text":"<p>Hide complexity behind a simple interface. Users don't need to know how <code>COMP-COST</code> works, just what it does.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#2-reuse","title":"2. Reuse","text":"<p>Write once, use many times:</p> <pre><code>total1 \u2190 COMP-COST(50, 0.08)\ntotal2 \u2190 COMP-COST(200, 0.08)\ntotal3 \u2190 COMP-COST(75, 0.08)\n</code></pre> <p>Without procedures, you'd duplicate the calculation logic three times.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#3-maintainability","title":"3. Maintainability","text":"<p>If the tax calculation formula changes (e.g., adding rounding), update one place:</p> <pre><code>function COMP-COST(price, taxRate)\n    salesTax \u2190 round(price * taxRate, 2)  // Round to 2 decimal places\n    totalCost \u2190 price + salesTax\n    return totalCost\nendfunction\n</code></pre> <p>All callers automatically benefit.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#4-testability","title":"4. Testability","text":"<p>Test procedures in isolation:</p> <pre><code>assert COMP-COST(100, 0.05) = 105\nassert COMP-COST(13, 0.05) = 13.65\nassert COMP-COST(0, 0.05) = 0\n</code></pre>"},{"location":"programming_languages/procedures_and_higher_order_functions/#5-readability","title":"5. Readability","text":"<p>Compare:</p> <p>Without procedures:</p> <pre><code>total1 \u2190 100 + (100 * 0.05)\ntotal2 \u2190 200 + (200 * 0.05)\n</code></pre> <p>With procedures:</p> <pre><code>total1 \u2190 COMP-COST(100, 0.05)\ntotal2 \u2190 COMP-COST(200, 0.05)\n</code></pre> <p>The second version clearly communicates intent.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#higher-order-functions","title":"Higher-Order Functions","text":"<p>A higher-order function is a function that:</p> <ol> <li>Takes one or more functions as parameters, and/or</li> <li>Returns a function as its result</li> </ol> <p>This treats functions as first-class values\u2014they can be passed around like numbers or strings.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#why-higher-order","title":"Why \"Higher-Order\"?","text":"<p>The terminology comes from mathematics:</p> <ul> <li>First-order functions operate on data (numbers, strings, etc.)</li> <li>Higher-order functions operate on functions themselves</li> </ul> <p>Example from calculus:</p> <p>The derivative operator takes a function and returns a new function:</p> <pre><code>d/dx(f) \u2192 f'\n</code></pre> <p>If \\(f(x) = x^2\\), then \\(f'(x) = 2x\\). The derivative operator is higher-order.</p> 1930s: The Theoretical Foundation (Lambda Calculus) <p>Long before modern computers, Alonzo Church invented \u03bb-calculus, a formal system where everything is a function.</p> <p>In this system, <code>add(3, 4)</code> looks like <code>(\u03bbx. \u03bby. x + y)(3)(4)</code>. This concept is the theoretical bedrock for all functional programming.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#higher-order-function-examples","title":"Higher-Order Function Examples","text":"Partial ApplicationMap (Functions as Parameters) <p>The Problem</p> <p>Suppose you run a retail store with a fixed 5% sales tax. Every time you calculate total cost, you must specify the tax rate:</p> <pre><code>total1 \u2190 COMP-COST(50, 0.05)\ntotal2 \u2190 COMP-COST(100, 0.05)\ntotal3 \u2190 COMP-COST(75, 0.05)\ntotal4 \u2190 COMP-COST(120, 0.05)\n</code></pre> <p>Repeating <code>0.05</code> is tedious and error-prone. If the tax rate changes, you must update every call.</p> <p>The Solution</p> <p>Create a specialized version of <code>COMP-COST</code> that \"bakes in\" the tax rate:</p>  Pseudocode Python JavaScript Go Rust Java C++ <pre><code>function makeFixedTaxCalculator(fixedTaxRate)\n    function calculate(price)\n        return COMP-COST(price, fixedTaxRate)\n    endfunction\n    return calculate\nendfunction\n</code></pre> <p>Usage:</p> <pre><code>calcWith5PercentTax \u2190 makeFixedTaxCalculator(0.05)\n\ntotal1 \u2190 calcWith5PercentTax(50)      // 52.50\ntotal2 \u2190 calcWith5PercentTax(100)     // 105.00\n</code></pre> Partial Application<pre><code>def make_fixed_tax_calculator(fixed_tax_rate):  # (1)!\n    def calculate(price):  # (2)!\n        return comp_cost(price, fixed_tax_rate)  # (3)!\n    return calculate  # (4)!\n</code></pre> <ol> <li>Outer Function: Takes the configuration value (tax rate).</li> <li>Inner Function: Defines the behavior we want to return.</li> <li>Closure Capture: Uses <code>fixed_tax_rate</code> from the outer scope.</li> <li>Return: Sends the function itself back to the caller.</li> </ol> <p>Usage:</p> <pre><code>calc_with_5_percent = make_fixed_tax_calculator(0.05)\ntotal1 = calc_with_5_percent(50)  # 52.50\n</code></pre> Partial Application<pre><code>function makeFixedTaxCalculator(fixedTaxRate) {  // (1)!\n    return function(price) {  // (2)!\n        return compCost(price, fixedTaxRate);  // (3)!\n    };  // (4)!\n}\n</code></pre> <ol> <li>Outer Function: Takes the configuration value (tax rate).</li> <li>Inner Function: Anonymous function defines the behavior to return.</li> <li>Closure Capture: Accesses <code>fixedTaxRate</code> from the outer scope.</li> <li>Return: Sends the function itself back to the caller.</li> </ol> <p>Usage:</p> <pre><code>const calcWith5Percent = makeFixedTaxCalculator(0.05);\nlet total1 = calcWith5Percent(50); // 52.50\n</code></pre> Partial Application<pre><code>func makeFixedTaxCalculator(fixedTaxRate float64) func(float64) float64 {  // (1)!\n    return func(price float64) float64 {  // (2)!\n        return compCost(price, fixedTaxRate)  // (3)!\n    }  // (4)!\n}\n</code></pre> <ol> <li>Outer Function: Return type is a function signature <code>func(float64) float64</code>.</li> <li>Inner Function: Anonymous function (closure) created inline.</li> <li>Closure Capture: Go closures automatically capture variables from outer scope.</li> <li>Return: Returns the closure, allowing partial application.</li> </ol> <p>Usage:</p> <pre><code>calcWith5Percent := makeFixedTaxCalculator(0.05)\ntotal1 := calcWith5Percent(50.0) // 52.50\n</code></pre> Partial Application<pre><code>fn make_fixed_tax_calculator(fixed_tax_rate: f64) -&gt; impl Fn(f64) -&gt; f64 {  // (1)!\n    move |price| comp_cost(price, fixed_tax_rate)  // (2)!\n}  // (3)!\n</code></pre> <ol> <li>Return Type: <code>impl Fn(f64) -&gt; f64</code> returns a closure that takes f64 and returns f64.</li> <li>Move Keyword: Transfers ownership of <code>fixed_tax_rate</code> into the closure.</li> <li>Closure Expression: Rust's <code>|param| expression</code> syntax for inline functions.</li> </ol> <p>Usage:</p> <pre><code>let calc_with_5_percent = make_fixed_tax_calculator(0.05);\nlet total1 = calc_with_5_percent(50.0); // 52.50\n</code></pre> Partial Application<pre><code>import java.util.function.Function;\n\npublic static Function&lt;Double, Double&gt; makeFixedTaxCalculator(double fixedTaxRate) {  // (1)!\n    return (price) -&gt; compCost(price, fixedTaxRate);  // (2)!\n}  // (3)!\n</code></pre> <ol> <li>Generic Type: <code>Function&lt;Double, Double&gt;</code> takes a Double and returns a Double.</li> <li>Lambda Expression: Java's <code>(param) -&gt; expression</code> syntax captures <code>fixedTaxRate</code>.</li> <li>Closure: Lambda expressions in Java automatically capture variables from enclosing scope.</li> </ol> <p>Usage:</p> <pre><code>Function&lt;Double, Double&gt; calcWith5Percent = makeFixedTaxCalculator(0.05);\ndouble total1 = calcWith5Percent.apply(50.0); // 52.50\n</code></pre> Partial Application<pre><code>#include &lt;functional&gt;\n\nstd::function&lt;double(double)&gt; makeFixedTaxCalculator(double fixedTaxRate) {  // (1)!\n    return [fixedTaxRate](double price) {  // (2)!\n        return compCost(price, fixedTaxRate);  // (3)!\n    };\n}\n</code></pre> <ol> <li>Return Type: <code>std::function&lt;double(double)&gt;</code> is a function wrapper for callables.</li> <li>Capture List: <code>[fixedTaxRate]</code> explicitly captures the variable by value.</li> <li>Lambda Body: Accesses the captured value to create partial application.</li> </ol> <p>Usage:</p> <pre><code>auto calcWith5Percent = makeFixedTaxCalculator(0.05);\ndouble total1 = calcWith5Percent(50.0); // 52.50\n</code></pre> <p>The Problem</p> <p>You have a list of numbers and want to perform various operations (square, double, negate) without rewriting the loop logic every time.</p> <p>The Solution</p> 1958: The First Functional Language (Lisp) <p>John McCarthy created Lisp, the first language to treat functions as \"first-class citizens\"\u2014meaning they could be passed around just like numbers.</p> <p>For a deeper look at Lisp's descendant and how it represents code as data, check out our article on Scheme and Parse Trees.</p> <p>Define a general <code>map</code> function that applies any function to each element:</p>  Pseudocode Python JavaScript Go Rust Java C++ <pre><code>function map(func, numbers)\n    result \u2190 []\n    for each num in numbers\n        result.append(func(num))\n    endfor\n    return result\nendfunction\n</code></pre> Map Function<pre><code>def map_function(func, numbers):  # (1)!\n    result = []\n    for num in numbers:\n        result.append(func(num))  # (2)!\n    return result\n</code></pre> <ol> <li>Takes a function as an argument (<code>func</code>) along with the data.</li> <li>Higher-Order Magic: Calls the passed-in function on each element.</li> </ol> Map Function<pre><code>function map(func, numbers) {  // (1)!\n    let result = [];\n    for (let num of numbers) {\n        result.push(func(num));  // (2)!\n    }\n    return result;\n}\n</code></pre> <ol> <li>Takes a function as the first parameter (higher-order).</li> <li>Higher-Order Magic: Calls the passed-in function on each element.</li> </ol> Map Function<pre><code>func mapInts(f func(int) int, numbers []int) []int {  // (1)!\n    result := make([]int, len(numbers))  // (2)!\n    for i, v := range numbers {\n        result[i] = f(v)  // (3)!\n    }\n    return result\n}\n</code></pre> <ol> <li>Function Parameter: <code>f func(int) int</code> takes a function as an argument.</li> <li>Pre-allocate: Creates result slice with known capacity for efficiency.</li> <li>Apply Function: Calls <code>f</code> on each element, storing the transformed value.</li> </ol> Map Function<pre><code>fn map_vec(func: fn(i32) -&gt; i32, numbers: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {  // (1)!\n    let mut result = Vec::new();\n    for &amp;num in numbers {  // (2)!\n        result.push(func(num));  // (3)!\n    }\n    return result;\n}\n</code></pre> <ol> <li>Function Pointer: <code>fn(i32) -&gt; i32</code> is a function pointer type.</li> <li>Dereference Pattern: <code>&amp;num</code> pattern matches to dereference the element.</li> <li>Higher-Order Call: Applies the function pointer to each element.</li> </ol> Map Function<pre><code>import java.util.List;\nimport java.util.ArrayList;\nimport java.util.function.Function;\n\npublic static List&lt;Integer&gt; map(Function&lt;Integer, Integer&gt; func, List&lt;Integer&gt; numbers) {  // (1)!\n    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n    for (Integer num : numbers) {\n        result.add(func.apply(num));  // (2)!\n    }\n    return result;\n}\n</code></pre> <ol> <li>Function Interface: Uses Java's <code>Function&lt;T, R&gt;</code> interface for type-safe function parameters.</li> <li>Apply Method: Calls the function using <code>.apply()</code> method required by the interface.</li> </ol> Map Function<pre><code>#include &lt;vector&gt;\n#include &lt;functional&gt;\n\nstd::vector&lt;int&gt; map(std::function&lt;int(int)&gt; func, const std::vector&lt;int&gt;&amp; numbers) {  // (1)!\n    std::vector&lt;int&gt; result;\n    for (int num : numbers) {  // (2)!\n        result.push_back(func(num));  // (3)!\n    }\n    return result;\n}\n</code></pre> <ol> <li>Function Wrapper: <code>std::function&lt;int(int)&gt;</code> can hold any callable with matching signature.</li> <li>Range-Based Loop: Modern C++ syntax for iterating over containers.</li> <li>Function Call: Invokes the wrapped function on each element.</li> </ol> <p>Usage:</p> <p>Once <code>map</code> is defined, you can pass any transformation function to it.</p> <pre><code># Example (Python)\nsquared = map_function(square, [1, 2, 3]) # [1, 4, 9]\ndoubled = map_function(double, [1, 2, 3]) # [2, 4, 6]\n</code></pre>"},{"location":"programming_languages/procedures_and_higher_order_functions/#closures","title":"Closures","text":"<p>A closure is a function that \"closes over\" (captures) variables from its surrounding scope. This allows a function to access variables that were present when it was created, even if those variables are no longer in scope when it is called.</p> <p>In the \"Partial Application\" example above, <code>makeFixedTaxCalculator</code> creates a closure.</p> <p>Visualizing Capture:</p> <ol> <li>You call <code>makeFixedTaxCalculator(0.05)</code>.</li> <li>A new local environment is created where <code>fixedTaxRate = 0.05</code>.</li> <li>The <code>calculate</code> function is defined inside this environment.</li> <li>When <code>makeFixedTaxCalculator</code> returns, <code>calculate</code> carries that environment with it like a backpack.</li> </ol> <pre><code>graph TD\n    Scope[Outer Scope: Global] --&gt; FuncCall[Function Call: makeFixedTaxCalculator 0.05]\n    FuncCall --&gt; Env[Captured Environment: fixedTaxRate = 0.05]\n    Env --&gt; InnerFunc[Inner Function: calculate]\n\n    style Env fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style InnerFunc fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>When you later call <code>calcWith5Percent(50)</code>, it reaches into its \"backpack\" (the captured environment) to find <code>fixedTaxRate</code>. Without closures, partial application would be impossible.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#currying","title":"Currying","text":"<p>Currying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, each with a single argument.</p> <p>If you have a function <code>f(x, y, z)</code>, you normally call it like this:</p> <pre><code>result = f(x, y, z)\n</code></pre> <p>Currying transforms it so you call it like this:</p> <pre><code>result = f(x)(y)(z)\n</code></pre>"},{"location":"programming_languages/procedures_and_higher_order_functions/#how-it-works","title":"How it Works","text":"<p>Imagine a factory assembly line.</p> <ol> <li>Standard Function: You dump all raw materials (<code>x</code>, <code>y</code>, <code>z</code>) into the machine at once. It crunches them and spits out the product.</li> <li>Curried Function:<ul> <li>Station 1: Takes <code>x</code>. It adjusts its settings based on <code>x</code> and returns a new machine (Station 2).</li> <li>Station 2: Takes <code>y</code>. It adjusts based on <code>y</code> and returns a new machine (Station 3).</li> <li>Station 3: Takes <code>z</code>. It finally has everything it needs, does the work, and returns the product.</li> </ul> </li> </ol> <p>This \"chain of machines\" allows you to stop at any point. If you only have <code>x</code>, you can run Station 1 and save the resulting Station 2 for later use. This is effectively Partial Application.</p> Origins of Currying <p>While named after the American logician Haskell Curry, the concept was originally introduced in 1924 by the Russian mathematician Moses Sch\u00f6nfinkel. Curry later developed the idea extensively, leading to its widespread adoption in logic and computer science.</p> <p>Currying is a fundamental concept in combinatory logic and the lambda calculus. It allows functions that take multiple arguments to be expressed using only functions that take a single argument, which simplifies the mathematical study of computation. Today, Haskell Curry's legacy lives on in languages like Haskell, which are built entirely on these functional principles.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#currying-examples","title":"Currying Examples","text":"AdditionLogging (Configuration) <p>Task: transform a standard addition function <code>add(x, y)</code> into a sequence of functions <code>add(x)(y)</code>.</p>  Pseudocode Python JavaScript Go Rust Java C++ <p>Normal function:</p> <pre><code>function add(x, y)\n    return x + y\nendfunction\n\nresult \u2190 add(3, 4)  // 7\n</code></pre> <p>Curried version:</p> <pre><code>function addCurried(x)\n    function inner(y)\n        return x + y\n    endfunction\n    return inner\nendfunction\n</code></pre> <p>Usage:</p> <pre><code>add3 \u2190 addCurried(3)     // Returns a function that adds 3\nresult \u2190 add3(4)         // 7\n\nadd10 \u2190 addCurried(10)   // Returns a function that adds 10\nresult2 \u2190 add10(5)       // 15\n</code></pre> <p>Or inline:</p> <pre><code>result \u2190 addCurried(3)(4)  // 7\n</code></pre> Curried Add<pre><code>def add_curried(x):  # (1)!\n    def inner(y):  # (2)!\n        return x + y\n    return inner  # (3)!\n</code></pre> <ol> <li>Stage 1: Accepts the first argument <code>x</code>.</li> <li>Stage 2: Defines a new function waiting for <code>y</code>.</li> <li>Pause: Returns the Stage 2 function, pausing execution until called again.</li> </ol> <p>Usage:</p> <pre><code>add3 = add_curried(3)\nresult = add3(4) # 7\n\n# Inline\nresult2 = add_curried(3)(4) # 7\n</code></pre> Curried Add<pre><code>const addCurried = x =&gt; y =&gt; x + y;  // (1)!\n</code></pre> <ol> <li>Arrow Function Chain: <code>x =&gt;</code> returns a function, which itself returns <code>y =&gt; x + y</code>. Currying in one line!</li> </ol> <p>Usage:</p> <pre><code>const add3 = addCurried(3);\nlet result = add3(4); // 7\n\n// Inline\nlet result2 = addCurried(3)(4); // 7\n</code></pre> Curried Add<pre><code>func addCurried(x int) func(int) int {  // (1)!\n    return func(y int) int {  // (2)!\n        return x + y  // (3)!\n    }\n}\n</code></pre> <ol> <li>Stage 1: Takes first argument <code>x</code>, returns a function.</li> <li>Stage 2: The returned function waits for <code>y</code>.</li> <li>Combine: Adds both captured <code>x</code> and parameter <code>y</code>.</li> </ol> <p>Usage:</p> <pre><code>add3 := addCurried(3)\nresult := add3(4) // 7\n\n// Inline\nresult2 := addCurried(3)(4) // 7\n</code></pre> Curried Add<pre><code>fn add_curried(x: i32) -&gt; impl Fn(i32) -&gt; i32 {  // (1)!\n    move |y| x + y  // (2)!\n}  // (3)!\n</code></pre> <ol> <li>Stage 1: Returns an <code>impl Fn</code> trait object (a closure).</li> <li>Stage 2: <code>move</code> keyword captures <code>x</code> by value; closure waits for <code>y</code>.</li> <li>Concise: Rust's expression-based syntax allows single-line currying.</li> </ol> <p>Usage:</p> <pre><code>let add3 = add_curried(3);\nlet result = add3(4); // 7\n\n// Inline is slightly more verbose in Rust due to borrowing rules\n// but conceptually the same.\n</code></pre> Curried Add<pre><code>import java.util.function.Function;\n\npublic static Function&lt;Integer, Integer&gt; addCurried(int x) {  // (1)!\n    return (y) -&gt; x + y;  // (2)!\n}  // (3)!\n</code></pre> <ol> <li>Stage 1: Returns <code>Function&lt;Integer, Integer&gt;</code> - a function waiting for one Integer.</li> <li>Stage 2: Lambda captures <code>x</code> and waits for <code>y</code> parameter.</li> <li>Type Safety: Generic <code>Function</code> interface ensures compile-time type checking.</li> </ol> <p>Usage:</p> <pre><code>Function&lt;Integer, Integer&gt; add3 = addCurried(3);\nint result = add3.apply(4); // 7\n\n// Inline\nint result2 = addCurried(3).apply(4); // 7\n</code></pre> Curried Add<pre><code>#include &lt;functional&gt;\n\nstd::function&lt;int(int)&gt; addCurried(int x) {  // (1)!\n    return [x](int y) {  // (2)!\n        return x + y;\n    };  // (3)!\n}\n</code></pre> <ol> <li>Stage 1: Returns a function object that takes an int.</li> <li>Capture by Value: <code>[x]</code> captures <code>x</code> into the lambda's closure.</li> <li>Stage 2: The returned lambda waits for <code>y</code>, completing the addition.</li> </ol> <p>Usage:</p> <pre><code>auto add3 = addCurried(3);\nint result = add3(4); // 7\n\n// Inline\nint result2 = addCurried(3)(4); // 7\n</code></pre> <p>Task: Create a reusable logger where the log level (\"INFO\", \"ERROR\") is fixed, so you don't have to repeat it.</p>  Pseudocode Python JavaScript Go Rust Java C++ <p>Normal function:</p> <pre><code>function log(level, message)\n    print(level + \": \" + message)\nendfunction\n</code></pre> <p>Curried version:</p> <pre><code>function logCurried(level)\n    function inner(message)\n        print(level + \": \" + message)\n    endfunction\n    return inner\nendfunction\n</code></pre> <p>Usage:</p> <pre><code>logError \u2190 logCurried(\"ERROR\")\nlogInfo \u2190 logCurried(\"INFO\")\n\nlogError(\"File not found\")      // ERROR: File not found\nlogInfo(\"Server started\")       // INFO: Server started\n</code></pre> Curried Logger<pre><code>def log_curried(level):  # (1)!\n    def inner(message):\n        print(f\"{level}: {message}\")  # (2)!\n    return inner\n</code></pre> <ol> <li>Configuration Stage: Captures the log level once.</li> <li>Execution Stage: Inner function uses captured <code>level</code> with each message.</li> </ol> <p>Usage:</p> <pre><code>log_error = log_curried(\"ERROR\")\nlog_error(\"File not found\")\n# Output: ERROR: File not found\n</code></pre> Curried Logger<pre><code>const logCurried = level =&gt; message =&gt; {  // (1)!\n    console.log(`${level}: ${message}`);  // (2)!\n};\n</code></pre> <ol> <li>Double Arrow: First arrow captures <code>level</code>, second arrow captures <code>message</code>.</li> <li>Template Literals: JavaScript's <code>`${var}`</code> syntax for string interpolation.</li> </ol> <p>Usage:</p> <pre><code>const logError = logCurried(\"ERROR\");\nlogError(\"File not found\");\n// Output: ERROR: File not found\n</code></pre> Curried Logger<pre><code>import \"fmt\"\n\nfunc logCurried(level string) func(string) {  // (1)!\n    return func(message string) {  // (2)!\n        fmt.Printf(\"%s: %s\\n\", level, message)\n    }\n}\n</code></pre> <ol> <li>Return Type: <code>func(string)</code> returns a function that takes a string (no return value).</li> <li>Closure for Config: Inner function remembers <code>level</code> for all future calls.</li> </ol> <p>Usage:</p> <pre><code>logError := logCurried(\"ERROR\")\nlogError(\"File not found\")\n</code></pre> Curried Logger<pre><code>fn log_curried(level: String) -&gt; impl Fn(String) {  // (1)!\n    move |message| println!(\"{}: {}\", level, message)  // (2)!\n}\n</code></pre> <ol> <li>Trait Return: <code>impl Fn(String)</code> returns any closure that implements the Fn trait.</li> <li>Move Ownership: <code>move</code> transfers ownership of <code>level</code> into the closure.</li> </ol> <p>Usage:</p> <pre><code>let log_error = log_curried(String::from(\"ERROR\"));\nlog_error(String::from(\"File not found\"));\n</code></pre> Curried Logger<pre><code>import java.util.function.Consumer;\n\npublic static Consumer&lt;String&gt; logCurried(String level) {  // (1)!\n    return (message) -&gt; System.out.println(level + \": \" + message);  // (2)!\n}\n</code></pre> <ol> <li>Consumer Type: <code>Consumer&lt;String&gt;</code> accepts a String but returns nothing (void).</li> <li>Lambda Capture: Lambda automatically captures <code>level</code> from enclosing scope.</li> </ol> <p>Usage:</p> <pre><code>Consumer&lt;String&gt; logError = logCurried(\"ERROR\");\nlogError.accept(\"File not found\");\n</code></pre> Curried Logger<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;functional&gt;\n\nstd::function&lt;void(std::string)&gt; logCurried(std::string level) {  // (1)!\n    return [level](std::string message) {  // (2)!\n        std::cout &lt;&lt; level &lt;&lt; \": \" &lt;&lt; message &lt;&lt; std::endl;\n    };\n}\n</code></pre> <ol> <li>Void Return: <code>std::function&lt;void(std::string)&gt;</code> takes a string, returns nothing.</li> <li>Capture String: Lambda captures <code>level</code> by value (copied into closure).</li> </ol> <p>Usage:</p> <pre><code>auto logError = logCurried(\"ERROR\");\nlogError(\"File not found\");\n</code></pre>"},{"location":"programming_languages/procedures_and_higher_order_functions/#why-curry","title":"Why Curry?","text":"<p>Partial application: Create specialized versions by fixing some arguments.</p> <p>Benefit: <code>logError</code> and <code>logInfo</code> are reusable, self-documenting functions.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#real-world-applications","title":"Real-World Applications","text":"Today: Mainstream Adoption <p>What started as abstract math is now standard in modern development:</p> <ul> <li>JavaScript: <code>.map()</code>, <code>.filter()</code>, <code>.reduce()</code>, arrow functions</li> <li>Python: <code>map()</code>, <code>filter()</code>, lambda expressions, decorators</li> <li>Java: Streams API, method references (Java 8+)</li> <li>C++: <code>std::function</code>, lambdas (C++11+)</li> <li>Rust: Closures, iterator adapters</li> </ul> GUI Event HandlersAsynchronous CallbacksFunctional ProgrammingDecorators &amp; Middleware <p>In graphical user interfaces (GUIs), you often pass functions to handle user interactions like clicks or text changes.</p> JavaScript Event Handling<pre><code>button.onClick(saveDocument);\ntextBox.onChange(validateInput);\n</code></pre> <p>Here, <code>onClick</code> and <code>onChange</code> are higher-order functions\u2014they take the <code>saveDocument</code> and <code>validateInput</code> functions as parameters and execute them when the event occurs.</p> <p>Higher-order functions are essential for handling tasks that take time to complete, such as fetching data from a network.</p> Asynchronous Callback<pre><code>fetchDataFromServer(url, function(response) {\n    processData(response);\n});\n</code></pre> <p>The second parameter is a callback function. The program doesn't wait for the data; instead, it provides a \"recipe\" (the function) to be executed whenever the data finally arrives.</p> <p>Modern languages provide built-in higher-order functions like <code>map</code>, <code>filter</code>, and <code>reduce</code> to process collections of data efficiently.</p> <p>Map: Apply a function to every element. <pre><code>squared = list(map(lambda x: x**2, [1, 2, 3, 4]))\n# Result: [1, 4, 9, 16]\n</code></pre></p> <p>Filter: Keep only elements that match a condition. <pre><code>evens = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5, 6]))\n# Result: [2, 4, 6]\n</code></pre></p> <p>Reduce: Combine all elements into a single value. <pre><code>from functools import reduce\nproduct = reduce(lambda x, y: x * y, [1, 2, 3, 4])\n# Result: 1 * 2 * 3 * 4 = 24\n</code></pre></p> <p>Decorators (Python) and Middleware (Web Frameworks) wrap existing functions to add behavior like logging, security checks, or performance timing.</p> Python Decorator<pre><code>@log_execution_time\ndef slow_function():\n    # ... logic ...\n    pass\n</code></pre> <p>The <code>@log_execution_time</code> decorator is a higher-order function. It takes <code>slow_function</code>, wraps it with timing logic, and returns a new, \"enhanced\" version of the function.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Define COMP-COST <p>Write a procedure <code>COMP-COST</code> in pseudocode that:</p> <ul> <li>Takes two parameters: <code>price</code> and <code>taxRate</code></li> <li>Calculates sales tax as <code>price * taxRate</code></li> <li>Returns total cost (price + tax)</li> </ul> <p>Test with <code>COMP-COST(13, 0.05)</code> \u2192 expected result: 13.65</p> Solution <pre><code>function COMP-COST(price, taxRate)\n    salesTax \u2190 price * taxRate\n    totalCost \u2190 price + salesTax\n    return totalCost\nendfunction\n</code></pre> <p>Test:</p> <pre><code>result \u2190 COMP-COST(13, 0.05)\n// salesTax = 13 * 0.05 = 0.65\n// totalCost = 13 + 0.65 = 13.65\n</code></pre> <p>Result: 13.65 \u2713</p> Practice Problem 2: Fixed Tax Rate Version <p>Create a higher-order function <code>makeFixedTaxCalculator(taxRate)</code> that returns a new function accepting only <code>price</code>.</p> <p>Use it to create <code>calcWith5Percent</code> and calculate totals for prices [10, 20, 30].</p> Solution <pre><code>function makeFixedTaxCalculator(fixedTaxRate)\n    function calculate(price)\n        return COMP-COST(price, fixedTaxRate)\n    endfunction\n    return calculate\nendfunction\n\n// Create specialized calculator\ncalcWith5Percent \u2190 makeFixedTaxCalculator(0.05)\n\n// Use it\ntotal1 \u2190 calcWith5Percent(10)     // 10.50\ntotal2 \u2190 calcWith5Percent(20)     // 21.00\ntotal3 \u2190 calcWith5Percent(30)     // 31.50\n</code></pre> <p>Results: [10.50, 21.00, 31.50]</p> Practice Problem 3: Implement Map <p>Write a <code>map</code> function in pseudocode that takes a function and a list, applying the function to each element.</p> <p>Define a <code>triple</code> function that multiplies by 3, then use <code>map</code> to triple the list [1, 2, 3, 4].</p> Solution <pre><code>function map(func, list)\n    result \u2190 []\n    for each item in list\n        result.append(func(item))\n    endfor\n    return result\nendfunction\n\nfunction triple(x)\n    return x * 3\nendfunction\n\nnumbers \u2190 [1, 2, 3, 4]\ntripled \u2190 map(triple, numbers)\n// tripled = [3, 6, 9, 12]\n</code></pre> <p>Verification:</p> <ul> <li><code>triple(1) = 3</code></li> <li><code>triple(2) = 6</code></li> <li><code>triple(3) = 9</code></li> <li><code>triple(4) = 12</code></li> </ul> <p>Result: [3, 6, 9, 12] \u2713</p> Practice Problem 4: Curry a Function <p>Write a curried version of a <code>multiply(x, y)</code> function.</p> <p>Use it to create a <code>double</code> function (multiply by 2) and a <code>triple</code> function (multiply by 3).</p> Solution <pre><code>function multiplyCurried(x)\n    function inner(y)\n        return x * y\n    endfunction\n    return inner\nendfunction\n\n// Create specialized functions\ndouble \u2190 multiplyCurried(2)\ntriple \u2190 multiplyCurried(3)\n\n// Use them\nresult1 \u2190 double(5)     // 10\nresult2 \u2190 triple(5)     // 15\nresult3 \u2190 double(7)     // 14\n</code></pre> <p>Alternative inline usage:</p> <pre><code>result \u2190 multiplyCurried(4)(5)  // 20\n</code></pre>"},{"location":"programming_languages/procedures_and_higher_order_functions/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning Procedure Named sequence of instructions with parameters and return value Pseudocode Language-neutral algorithm description prioritizing clarity Higher-Order Function Function that takes or returns other functions Closure Function that captures variables from surrounding scope Currying Transforming multi-argument function into sequence of single-argument functions Partial Application Fixing some arguments to create specialized function First-Class Functions Functions treated as values (can be passed, returned, stored)"},{"location":"programming_languages/procedures_and_higher_order_functions/#why-procedures-and-higher-order-functions-matter","title":"Why Procedures and Higher-Order Functions Matter","text":"<p>These concepts are fundamental because they enable:</p> <ul> <li>Abstraction: Hide complexity, expose simple interfaces</li> <li>Reuse: Write once, use everywhere</li> <li>Composability: Combine simple functions into complex behaviors</li> <li>Maintainability: Change logic in one place</li> <li>Expressiveness: Code that reads like the problem domain</li> </ul> <p>Higher-order functions, in particular, represent a shift in thinking: instead of just operating on data, you operate on operations themselves. This meta-level reasoning unlocks powerful patterns\u2014from event handling to functional programming to domain-specific languages.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#further-reading","title":"Further Reading","text":"<ul> <li>David Evans, Introduction to Computing \u2014 Chapters 3-4 cover procedures and abstraction</li> <li>Abelson &amp; Sussman, Structure and Interpretation of Computer Programs \u2014 Definitive text on procedures and higher-order functions</li> <li>Computational Thinking \u2014 Abstraction and algorithm design</li> <li>Scheme Primer \u2014 A beginner-friendly guide to the language where these concepts were born</li> <li>Scheme and Parse Trees \u2014 First-class functions in Scheme</li> </ul> <p>Procedures transform sequences of steps into reusable building blocks. Higher-order functions let you compose those blocks in infinitely flexible ways. Together, they form the foundation of abstraction\u2014the single most important idea in computer science. Master them, and you've mastered the art of managing complexity.</p>"},{"location":"programming_languages/procedures_and_higher_order_functions/#video-summary","title":"Video Summary","text":""},{"location":"programming_languages/programming_paradigms/","title":"Programming paradigms","text":""},{"location":"programming_languages/programming_paradigms/#description-imperative-vs-declarative-understanding-the-major-styles-of-programming","title":"description: Imperative vs. Declarative: Understanding the major styles of programming.","text":""},{"location":"programming_languages/programming_paradigms/#programming-paradigms-imperative-vs-declarative","title":"Programming Paradigms: Imperative vs. Declarative","text":"<p>When you learn your first programming language (usually Python, C, or Java), you are implicitly learning a specific \"style\" of thinking. This style is called a Programming Paradigm.</p> <p>There are hundreds of languages, but they almost all fall into two major camps: those that tell the computer how to do something, and those that tell the computer what result you want.</p>"},{"location":"programming_languages/programming_paradigms/#1-imperative-programming-the-how","title":"1. Imperative Programming (The \"How\")","text":"<p>Imperative programming is the oldest and most common paradigm. It maps directly to how the hardware works (The Turing Machine). You give the computer a specific sequence of instructions to change its state.</p> <p>The Vibe: A detailed recipe. \"Preheat oven to 350. Mix flour and sugar. Beat eggs. Pour into pan. Bake for 30 minutes.\"</p> <p>Sub-paradigms: -   Procedural: Grouping instructions into functions (C, Pascal). -   Object-Oriented (OOP): Grouping instructions and data into objects (Java, C++).</p> <p>Example (Python): Filtering a list Notice how we manually iterate, check, and append. We control the flow. <pre><code>numbers = [1, 2, 3, 4, 5, 6]\nevens = []\nfor n in numbers:\n    if n % 2 == 0:\n        evens.append(n)\n</code></pre></p>"},{"location":"programming_languages/programming_paradigms/#2-declarative-programming-the-what","title":"2. Declarative Programming (The \"What\")","text":"<p>Declarative programming hides the control flow. You describe the logic of the computation without describing its control flow. You tell the compiler/interpreter the properties of the result you want, and it figures out the steps.</p> <p>The Vibe: A blueprint or a restaurant order. \"I want a pepperoni pizza.\" (You don't tell the chef how to roll the dough).</p> <p>Sub-paradigms: -   Functional: Building programs by composing pure functions (Haskell, Lisp). -   Logic: Defining facts and rules (Prolog). -   Query: Requesting data (SQL). -   Markup: Defining structure (HTML/CSS).</p> <p>Example (SQL): Filtering a list Notice we don't say how to search the table. We just say what we want. <pre><code>SELECT number FROM numbers WHERE number % 2 = 0;\n</code></pre></p> <p>Example (Python List Comprehension): Python supports declarative styles too! <pre><code>evens = [n for n in numbers if n % 2 == 0]\n</code></pre></p>"},{"location":"programming_languages/programming_paradigms/#the-great-convergence","title":"The Great Convergence","text":"<p>Historically, languages picked a side. C was purely Imperative. Lisp was purely Declarative (Functional).</p> <p>Modern languages are Multi-Paradigm. -   Python/JavaScript: Allow you to write imperative loops OR declarative map/filter functions. -   Java: Added declarative Streams in Java 8. -   React (JS Library): Shifted UI development from Imperative (\"Change this button's text\") to Declarative (\"The button's text should be X based on state Y\").</p>"},{"location":"programming_languages/programming_paradigms/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Classify the Code <p>Is HTML Imperative or Declarative?</p> <pre><code>&lt;h1&gt;Hello World&lt;/h1&gt;\n&lt;p&gt;This is a paragraph.&lt;/p&gt;\n</code></pre> Solution <p>Declarative.</p> <p>You are telling the browser what to display (a heading, a paragraph). You are not telling it how to render the pixels, manage the layout engine, or flow the text.</p> Practice Problem 2: The Loop vs. The Map <p>Which of these two JavaScript snippets is Imperative?</p> <p>A: <pre><code>const doubled = numbers.map(n =&gt; n * 2);\n</code></pre></p> <p>B: <pre><code>const doubled = [];\nfor (let i = 0; i &lt; numbers.length; i++) {\n    doubled.push(numbers[i] * 2);\n}\n</code></pre></p> Solution <p>Snippet B is Imperative.</p> <p>It specifies the control flow (the loop, the index <code>i</code>, the push operation). Snippet A is Declarative (Functional)\u2014it just says \"Map these numbers to their double.\"</p>"},{"location":"programming_languages/programming_paradigms/#key-takeaways","title":"Key Takeaways","text":"Feature Imperative Declarative Focus How to do it (Steps). What output to get (Result). State Mutable (Changeable). Immutable (New values created). Analogy Recipe. Blueprint. Examples C, Java, Python (Loops). SQL, HTML, Haskell, Excel. <p>Understanding paradigms is like understanding musical genres. You might be a rock musician (Imperative C coder), but learning jazz (Functional Haskell) will make you a better musician overall.</p>"},{"location":"programming_languages/scheme_primer/","title":"A Beginner's Guide to Scheme","text":"<p>Scheme is one of the most elegant programming languages ever designed. Created in the 1970s at MIT by Guy Steele and Gerald Sussman, it strips programming down to its essential elements: expressions, definitions, and procedures. While Scheme isn't widely used in industry today, learning it teaches you to think about computation in a fundamentally different way.</p> <p>This guide will take you from zero to writing your first Scheme programs.</p>"},{"location":"programming_languages/scheme_primer/#why-learn-scheme","title":"Why Learn Scheme?","text":"<p>Before diving in, let's address the obvious question: why learn a language that most professional programmers never use?</p> <p>Simplicity reveals fundamentals. Scheme's syntax is so minimal that you can learn nearly the entire language in an afternoon. This simplicity lets you focus on what you're computing rather than fighting with syntax. As David Evans notes in Introduction to Computing:</p> <p>The primary advantage of using Scheme to learn about computing is its simplicity and elegance. The language is simple enough that this chapter covers nearly the entire language.</p> <p>It changes how you think. Scheme forces you to think recursively and functionally. These patterns appear everywhere in modern programming\u2014from JavaScript's array methods to React's component model to data processing pipelines.</p> <p>Historical significance. Many \"modern\" features\u2014garbage collection, first-class functions, closures\u2014were invented in Lisp/Scheme decades ago. Understanding Scheme helps you appreciate where programming languages came from.</p>"},{"location":"programming_languages/scheme_primer/#getting-started-with-drracket","title":"Getting Started with DrRacket","text":"<p>The easiest way to start programming in Scheme is with DrRacket, a free IDE designed for learning. DrRacket provides:</p> <ul> <li>Syntax highlighting and error messages designed for beginners</li> <li>Multiple \"language levels\" for gradual learning</li> <li>An interactive REPL (Read-Eval-Print Loop) for experimentation</li> </ul>"},{"location":"programming_languages/scheme_primer/#installation","title":"Installation","text":"<ol> <li>Download DrRacket from racket-lang.org</li> <li>Install and open the application</li> <li>Select a language: Language \u2192 Choose Language \u2192 Teaching Languages \u2192 Beginning Student</li> </ol> <p>For the examples in this guide, you can also select Other Languages \u2192 R5RS for standard Scheme, or simply use <code>#lang scheme</code> at the top of your file.</p> <p>Note: If you are using the Beginning Student language level in DrRacket, you do not need to include <code>#lang scheme</code> at the top of your file. That directive is for when you are running standard Racket/Scheme scripts.</p> DrRacket's Two Panels <p>DrRacket has two main areas:</p> <ul> <li>Definitions Window (top): Where you write your program</li> <li>Interactions Window (bottom): Where you can type expressions and see results immediately</li> </ul> <p>Click the Run button (or press Ctrl+R / Cmd+R) to execute your definitions, then experiment in the interactions window.</p>"},{"location":"programming_languages/scheme_primer/#expressions-the-building-blocks","title":"Expressions: The Building Blocks","text":"<p>Everything in Scheme is an expression\u2014a piece of code that evaluates to a value.</p>"},{"location":"programming_languages/scheme_primer/#primitive-expressions","title":"Primitive Expressions","text":"<p>The simplest expressions are primitives that evaluate to themselves:</p> Primitive Expressions<pre><code>42          ; Evaluates to 42\n3.14159     ; Evaluates to 3.14159\n-17         ; Evaluates to -17\n#t          ; Evaluates to true\n#f          ; Evaluates to false\n\"hello\"     ; Evaluates to \"hello\" (a string)\n</code></pre>"},{"location":"programming_languages/scheme_primer/#application-expressions","title":"Application Expressions","text":"<p>To do anything useful, you apply procedures (functions) to arguments. Scheme uses prefix notation\u2014the procedure comes first, followed by its arguments, all wrapped in parentheses:</p> Application Expressions (Prefix Notation)<pre><code>(+ 1 2)         ; Add 1 and 2 \u2192 3\n(* 3 4)         ; Multiply 3 and 4 \u2192 12\n(- 10 3)        ; Subtract 3 from 10 \u2192 7\n(/ 20 4)        ; Divide 20 by 4 \u2192 5\n</code></pre> <p>Key insight: Every application follows the same pattern: <code>(procedure arg1 arg2 ...)</code>. There are no special cases for operators vs. functions\u2014they all work the same way.</p>"},{"location":"programming_languages/scheme_primer/#nested-expressions","title":"Nested Expressions","text":"<p>Expressions can be nested to build complex computations:</p> Nested Expressions<pre><code>(+ (* 10 10) (+ 25 25))    ; (10*10) + (25+25) = 100 + 50 = 150\n(* (+ 2 3) (- 10 4))       ; (2+3) * (10-4) = 5 * 6 = 30\n</code></pre> <p>The innermost expressions evaluate first, then their results flow outward. This is called post-order evaluation.</p> <pre><code>graph TB\n    subgraph \"Evaluating (+ (* 10 10) (+ 25 25))\"\n    A[\"(+ (* 10 10) (+ 25 25))\"] --&gt; B[\"(* 10 10)\"]\n    A --&gt; C[\"(+ 25 25)\"]\n    B --&gt; D[\"10\"]\n    B --&gt; E[\"10\"]\n    C --&gt; F[\"25\"]\n    C --&gt; G[\"25\"]\n    D --&gt; H[\"100\"]\n    E --&gt; H\n    F --&gt; I[\"50\"]\n    G --&gt; I\n    H --&gt; J[\"150\"]\n    I --&gt; J\n    end\n\n    style A fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style B fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style C fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style D fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style E fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style F fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style G fill:#1a202c,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style H fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style I fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style J fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre> <p>The leaves (primitives) evaluate first, then results propagate up to the root.</p> Prefix vs. Infix Notation <p>Most languages use infix notation where operators go between operands: <code>3 + 4 * 5</code>. This requires precedence rules (PEMDAS) to determine order.</p> <p>Scheme's prefix notation eliminates ambiguity. The expression <code>(+ 3 (* 4 5))</code> explicitly shows that multiplication happens first. No memorization required.</p> <p>For a deeper dive into why this matters, see Scheme &amp; Parse Trees.</p>"},{"location":"programming_languages/scheme_primer/#built-in-procedures","title":"Built-in Procedures","text":"<p>Scheme provides many primitive procedures. Here are the essentials:</p> Procedure Description Example Result <code>+</code> Add numbers <code>(+ 1 2 3)</code> <code>6</code> <code>-</code> Subtract <code>(- 10 3)</code> <code>7</code> <code>*</code> Multiply <code>(* 2 3 4)</code> <code>24</code> <code>/</code> Divide <code>(/ 15 3)</code> <code>5</code> <code>=</code> Equal? <code>(= 5 5)</code> <code>#t</code> <code>&lt;</code> Less than? <code>(&lt; 3 5)</code> <code>#t</code> <code>&gt;</code> Greater than? <code>(&gt; 3 5)</code> <code>#f</code> <code>&lt;=</code> Less or equal? <code>(&lt;= 5 5)</code> <code>#t</code> <code>&gt;=</code> Greater or equal? <code>(&gt;= 3 5)</code> <code>#f</code> <code>zero?</code> Is zero? <code>(zero? 0)</code> <code>#t</code> <p>Notice that <code>+</code> and <code>*</code> can take any number of arguments\u2014another advantage of prefix notation.</p>"},{"location":"programming_languages/scheme_primer/#definitions-naming-things","title":"Definitions: Naming Things","text":"<p>Computation becomes useful when you can name values and reuse them. The <code>define</code> form creates a name and binds it to a value:</p> Defining Constants<pre><code>(define cups-per-day 3)\n(define days-per-year 365)\n(define cost-per-cup 4.50)\n\ncups-per-day                          ; \u2192 3\ncost-per-cup                          ; \u2192 4.50\n</code></pre> <p>Once defined, you can use names in expressions:</p> Using Definitions in Expressions<pre><code>; Calculate annual coffee spending\n(* cups-per-day days-per-year cost-per-cup)\n; \u2192 4927.50\n</code></pre>"},{"location":"programming_languages/scheme_primer/#naming-conventions","title":"Naming Conventions","text":"<p>Scheme names can include letters, digits, and special characters like <code>-</code>, <code>?</code>, and <code>!</code>:</p> Naming Convention Examples<pre><code>(define pi 3.14159)\n(define my-favorite-number 42)\n(define is-valid? #t)\n</code></pre> <p>Good names are: - Descriptive: <code>cups-per-day</code> not <code>cpd</code> - Hyphenated: <code>cost-per-cup</code> not <code>costPerCup</code> - Question-marked for predicates: <code>zero?</code>, <code>even?</code>, <code>is-valid?</code></p>"},{"location":"programming_languages/scheme_primer/#procedures-defining-your-own-functions","title":"Procedures: Defining Your Own Functions","text":"<p>The real power comes from defining your own procedures. Scheme uses <code>lambda</code> (\u03bb) to create procedures:</p> Anonymous Procedure (Lambda)<pre><code>(lambda (x) (* x x))    ; A procedure that squares its input\n</code></pre> <p>This creates an anonymous procedure\u2014it exists but has no name. To use it, you can apply it directly:</p> Applying a Lambda Directly<pre><code>((lambda (x) (* x x)) 5)    ; \u2192 25\n</code></pre> <p>But usually, you'll bind procedures to names with <code>define</code>:</p> Binding Procedures to Names<pre><code>(define square (lambda (x) (* x x)))\n\n(square 2)      ; \u2192 4\n(square 7)      ; \u2192 49\n(square 1/4)    ; \u2192 1/16\n</code></pre>"},{"location":"programming_languages/scheme_primer/#shorthand-definition-syntax","title":"Shorthand Definition Syntax","text":"<p>Defining named procedures is so common that Scheme provides a shorthand:</p> Shorthand vs. Lambda Syntax<pre><code>; These are equivalent:\n(define square (lambda (x) (* x x)))\n(define (square x) (* x x))\n</code></pre> <p>The shorthand moves the parameter list next to the name. Most Scheme code uses this form.</p>"},{"location":"programming_languages/scheme_primer/#multiple-parameters","title":"Multiple Parameters","text":"<p>Procedures can take multiple inputs:</p> Procedure with Multiple Parameters<pre><code>(define (calculate-tax price rate)\n  (* price rate))\n\n(calculate-tax 9.99 0.14)    ; \u2192 1.3986\n</code></pre>"},{"location":"programming_languages/scheme_primer/#practical-examples","title":"Practical Examples","text":"<p>Here are some useful procedures:</p> Practical Procedure Examples<pre><code>; Cube a number\n(define (cubed x) (* x x x))\n(cubed 3)    ; \u2192 27\n\n; Calculate the area of a circle\n(define (circle-area radius)\n  (* 3.14159 radius radius))\n(circle-area 5)    ; \u2192 78.53975\n\n; Convert Fahrenheit to Celsius\n(define (f-to-c fahrenheit)\n  (* (- fahrenheit 32) 5/9))\n(f-to-c 212)    ; \u2192 100\n(f-to-c 32)     ; \u2192 0\n</code></pre>"},{"location":"programming_languages/scheme_primer/#conditionals-making-decisions","title":"Conditionals: Making Decisions","text":"<p>Real programs need to make decisions. The <code>if</code> expression chooses between two values based on a condition:</p> If Expression Syntax<pre><code>(if condition\n    consequent    ; evaluated if condition is true\n    alternate)    ; evaluated if condition is false\n</code></pre> <p>For example:</p> Conditional Examples<pre><code>(if (&gt; 5 3)\n    \"yes\"\n    \"no\")\n; \u2192 \"yes\"\n\n(if (= 1 2)\n    \"equal\"\n    \"not equal\")\n; \u2192 \"not equal\"\n</code></pre>"},{"location":"programming_languages/scheme_primer/#the-cheaper-procedure","title":"The <code>cheaper</code> Procedure","text":"<p>Let's build a procedure that returns the lower of two prices:</p> The cheaper Procedure<pre><code>(define (cheaper price1 price2)\n  (if (&lt; price1 price2) price1 price2))\n\n(cheaper 4.50 3.75)    ; \u2192 3.75\n(cheaper 2.99 5.49)    ; \u2192 2.99\n(cheaper 4.00 4.00)    ; \u2192 4.00\n</code></pre> <p>How it works:</p> <ol> <li><code>(&lt; price1 price2)</code> compares the two prices</li> <li>If <code>price1</code> is less, return <code>price1</code></li> <li>Otherwise, return <code>price2</code></li> </ol>"},{"location":"programming_languages/scheme_primer/#important-if-is-a-special-form","title":"Important: <code>if</code> is a Special Form","text":"<p>Unlike normal procedures, <code>if</code> doesn't evaluate all its arguments. Only the selected branch is evaluated:</p> Short-Circuit Evaluation<pre><code>(if (&gt; 3 4)\n    (/ 1 0)      ; Would cause error, but never runs\n    7)\n; \u2192 7\n</code></pre> <p>This is called short-circuit evaluation\u2014crucial for avoiding unnecessary computation or errors.</p> <p>This pattern is ubiquitous across computing. In most programming languages, <code>&amp;&amp;</code> and <code>||</code> operators short-circuit: <code>false &amp;&amp; expensive()</code> never calls <code>expensive()</code>. You'll find the same behavior in the UNIX shell:</p> Short-Circuit Evaluation in Bash<pre><code>mkdir mydir &amp;&amp; cd mydir      # Only cd if mkdir succeeds\ntest -f config || exit 1     # Only exit if file doesn't exist\n</code></pre> <p>The shell's <code>&amp;&amp;</code> only runs the second command if the first succeeds; <code>||</code> only runs the second if the first fails. Same principle, different syntax.</p>"},{"location":"programming_languages/scheme_primer/#nested-conditionals","title":"Nested Conditionals","text":"<p>You can nest <code>if</code> expressions for multiple conditions:</p> Nested Conditionals<pre><code>(define (sign n)\n  (if (&gt; n 0)\n      \"positive\"\n      (if (&lt; n 0)\n          \"negative\"\n          \"zero\")))\n\n(sign 5)     ; \u2192 \"positive\"\n(sign -3)    ; \u2192 \"negative\"\n(sign 0)     ; \u2192 \"zero\"\n</code></pre> The <code>cond</code> Alternative <p>For multiple conditions, Scheme also provides <code>cond</code>:</p> Using cond for Multiple Conditions<pre><code>(define (sign n)\n  (cond\n    [(&gt; n 0) \"positive\"]\n    [(&lt; n 0) \"negative\"]\n    [else \"zero\"]))\n</code></pre> <p>This is often clearer than nested <code>if</code> expressions.</p>"},{"location":"programming_languages/scheme_primer/#data-structures-lists","title":"Data Structures: Lists","text":"<p>Scheme stands for LISP (LISt Processing), so it's no surprise that lists are its fundamental data structure. A list is an ordered sequence of elements.</p>"},{"location":"programming_languages/scheme_primer/#creating-lists","title":"Creating Lists","text":"<p>You can create a list using the <code>list</code> procedure:</p> Creating Lists<pre><code>(list 1 2 3)            ; \u2192 (1 2 3)\n(list \"a\" \"b\" \"c\")      ; \u2192 (\"a\" \"b\" \"c\")\n(list 1 \"apple\" 3.14)   ; \u2192 (1 \"apple\" 3.14) (lists can be mixed)\n</code></pre> <p>You can also construct lists using <code>cons</code> (construct). <code>cons</code> adds an element to the front of a list:</p> Using cons<pre><code>(cons 1 (list 2 3))     ; \u2192 (1 2 3)\n(cons \"first\" empty)    ; \u2192 (\"first\")\n</code></pre> <p><code>empty</code> (or <code>'()</code>) represents an empty list.</p>"},{"location":"programming_languages/scheme_primer/#accessing-list-elements","title":"Accessing List Elements","text":"<p>Scheme provides two primary procedures for taking lists apart:</p> <ul> <li><code>first</code> (or <code>car</code>): Returns the first element of the list.</li> <li><code>rest</code> (or <code>cdr</code>): Returns the list containing everything except the first element.</li> </ul> Accessing Elements<pre><code>(define my-numbers (list 10 20 30 40))\n\n(first my-numbers)      ; \u2192 10\n(rest my-numbers)       ; \u2192 (20 30 40)\n\n(first (rest my-numbers)) ; \u2192 20\n</code></pre> <p>Historical Note: <code>car</code> stands for \"Contents of the Address part of Register\" and <code>cdr</code> (pronounced \"could-er\") stands for \"Contents of the Decrement part of Register\". These names refer to the architecture of the IBM 704 computer where Lisp was first implemented! Most modern Scheme teaching languages prefer <code>first</code> and <code>rest</code>.</p>"},{"location":"programming_languages/scheme_primer/#recursion-where-are-the-loops","title":"Recursion: Where are the Loops?","text":"<p>You might have noticed that this guide hasn't mentioned <code>for</code> or <code>while</code> loops. That's because Scheme doesn't have them! In Scheme, we use recursion\u2014procedures that call themselves\u2014to handle repetition.</p> <p>For example, if you wanted to sum a list of numbers, you wouldn't use a loop. You would say: \"The sum is the first number plus the sum of the rest of the numbers.\"</p> Recursion Example: Summing a List<pre><code>(define (sum-list numbers)\n  (if (empty? numbers)\n      0                               ; Base case: the sum of nothing is 0\n      (+ (first numbers)              ; Recursive case: add the first...\n         (sum-list (rest numbers))))) ; ...to the sum of the rest!\n\n(sum-list (list 1 2 3 4 5))           ; \u2192 15\n</code></pre> <p>While it might feel strange at first, recursion is a more powerful and flexible way to express computation.</p>"},{"location":"programming_languages/scheme_primer/#higher-order-procedures","title":"Higher-Order Procedures","text":"<p>One of Scheme's most powerful features is that procedures are first-class values. They can be:</p> <ul> <li>Passed as arguments to other procedures</li> <li>Returned as results from procedures</li> <li>Stored in data structures</li> </ul>"},{"location":"programming_languages/scheme_primer/#procedures-that-return-procedures","title":"Procedures That Return Procedures","text":"<p>Here's a procedure that creates other procedures:</p> Procedures That Return Procedures<pre><code>(define make-tipper\n  (lambda (percent)           ; (1)!\n    (lambda (bill) (* bill (/ percent 100))))) ; (2)!\n\n; Create a procedure that calculates a 20% tip\n(define tip-20 (make-tipper 20))\n(tip-20 50)    ; \u2192 10\n(tip-20 75)    ; \u2192 15\n\n; Create a procedure that calculates a 15% tip\n(define tip-15 (make-tipper 15))\n(tip-15 80)    ; \u2192 12\n</code></pre> <ol> <li>Outer lambda takes <code>percent</code> and returns an inner lambda</li> <li>Inner lambda \"closes over\" <code>percent</code>, remembering its value</li> </ol> <p>What's happening:</p> <ol> <li><code>(make-tipper 20)</code> returns <code>(lambda (bill) (* bill (/ 20 100)))</code></li> <li>This new procedure \"remembers\" that <code>percent</code> is <code>20</code></li> <li>When called with <code>50</code>, it computes <code>(* 50 0.20)</code> \u2192 <code>10</code></li> </ol> <p>This \"memory\" is called a closure\u2014the procedure captures the environment where it was created.</p> <pre><code>flowchart TB\n    subgraph CREATE [\"1. Create the closure\"]\n        A[\"(make-tipper 20)\"]\n        B[\"Returns a lambda\"]\n        C[\"Captures: percent = 20\"]\n        A --&gt; B --&gt; C\n    end\n\n    subgraph STORE [\"2. Bind to a name\"]\n        D[\"tip-20\"]\n        E[\"Has code + captured environment\"]\n        D --&gt; E\n    end\n\n    subgraph CALL [\"3. Call the closure\"]\n        F[\"(tip-20 50)\"]\n        G[\"bill = 50, percent = 20\"]\n        H[\"Result: 10\"]\n        F --&gt; G --&gt; H\n    end\n\n    C --&gt; D\n    E --&gt; F\n\n    style A fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style B fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style C fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style D fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style E fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style F fill:#2d3748,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style G fill:#4a5568,stroke:#cbd5e0,stroke-width:2px,color:#fff\n    style H fill:#48bb78,stroke:#cbd5e0,stroke-width:2px,color:#fff</code></pre>"},{"location":"programming_languages/scheme_primer/#procedures-as-arguments","title":"Procedures as Arguments","text":"<p>You can pass procedures to other procedures:</p> Passing Procedures as Arguments<pre><code>(define (apply-twice f x)  ; (1)!\n  (f (f x)))               ; (2)!\n\n(define (add-one x) (+ x 1))\n\n(apply-twice add-one 5)    ; \u2192 7  (adds 1 twice: 5\u21926\u21927)\n(apply-twice square 2)     ; \u2192 16 (squares twice: 2\u21924\u219216)\n</code></pre> <ol> <li><code>f</code> is a procedure passed as an argument</li> <li>Apply <code>f</code> to <code>x</code>, then apply <code>f</code> to that result</li> </ol> <p>This is the foundation of functional programming patterns like <code>map</code>, <code>filter</code>, and <code>reduce</code>.</p>"},{"location":"programming_languages/scheme_primer/#putting-it-all-together","title":"Putting It All Together","text":"<p>Let's build a complete example that uses everything we've learned:</p> Complete Scheme Program<pre><code>#lang scheme\n\n; Constants for coffee habit calculation\n(define cups-per-day 3)\n(define days-per-year 365)\n(define cost-per-cup 4.50)\n\n; Basic functions\n(define (squared x) (* x x))\n(define (cubed x) (* x x x))\n\n; Practical calculation\n(define (calculate-tax price rate) (* price rate))\n\n; Decision making\n(define (cheaper p1 p2) (if (&lt; p1 p2) p1 p2))\n\n; Higher-order function\n(define make-tipper\n  (lambda (percent)\n    (lambda (bill) (* bill (/ percent 100)))))\n\n; Recursive function processing a list\n(define (calculate-total prices)\n  (if (empty? prices)\n      0\n      (+ (first prices) \n         (calculate-total (rest prices)))))\n\n; Using our definitions\n(define tip-20 (make-tipper 20))\n(define tip-15 (make-tipper 15))\n(define my-orders (list 4.50 3.75 2.99))  ; A list of coffee prices\n\n; Try them out!\n(* cups-per-day days-per-year cost-per-cup)    ; Annual coffee cost\n(squared 12)                                    ; 144\n(calculate-tax 9.99 0.14)                       ; Tax amount: 1.3986\n(cheaper 4.50 3.75)                             ; Returns 3.75\n(tip-20 50)                                     ; Returns 10\n(calculate-total my-orders)                     ; Returns 11.24\n</code></pre>"},{"location":"programming_languages/scheme_primer/#practice-exercises","title":"Practice Exercises","text":"Exercise 1: Cube Procedure <p>Define a procedure <code>cube</code> that takes one number and returns its cube.</p> Expected Behavior<pre><code>(cube 3)    ; should return 27\n(cube 5)    ; should return 125\n</code></pre> Solution Solution<pre><code>(define (cube x) (* x x x))\n</code></pre> Exercise 2: Absolute Value <p>Define a procedure <code>abs-value</code> that returns the absolute value of a number.</p> Expected Behavior<pre><code>(abs-value 5)     ; should return 5\n(abs-value -7)    ; should return 7\n(abs-value 0)     ; should return 0\n</code></pre> Solution Solution<pre><code>(define (abs-value x)\n  (if (&lt; x 0)\n      (- x)      ; negate if negative\n      x))\n</code></pre> Exercise 3: Bigger Magnitude <p>Define <code>bigger-magnitude</code> that returns whichever input has the greater absolute value.</p> Hint <p>You can use the <code>abs-value</code> procedure you defined in Exercise 2 to help with the comparison!</p> Expected Behavior<pre><code>(bigger-magnitude 5 -7)    ; should return -7 (|-7| &gt; |5|)\n(bigger-magnitude 9 -3)    ; should return 9\n</code></pre> Solution Solution<pre><code>(define (bigger-magnitude a b)\n  (if (&gt; (abs-value a) (abs-value b))\n      a\n      b))\n</code></pre> Exercise 4: Seconds in a Year <p>Write a Scheme expression to calculate the number of seconds in a year. Define meaningful names for intermediate values.</p> Solution Solution<pre><code>(define seconds-per-minute 60)\n(define minutes-per-hour 60)\n(define hours-per-day 24)\n(define days-per-year 365)\n\n(* seconds-per-minute\n   minutes-per-hour\n   hours-per-day\n   days-per-year)\n; \u2192 31536000\n</code></pre> Exercise 5: Make Multiplier <p>Define a higher-order procedure <code>make-multiplier</code> that takes a number and returns a procedure that multiplies its input by that number.</p> Expected Behavior<pre><code>(define double (make-multiplier 2))\n(define triple (make-multiplier 3))\n\n(double 5)    ; should return 10\n(triple 5)    ; should return 15\n</code></pre> Solution Solution<pre><code>(define (make-multiplier n)\n  (lambda (x) (* n x)))\n</code></pre>"},{"location":"programming_languages/scheme_primer/#key-takeaways","title":"Key Takeaways","text":"Concept Syntax Example Primitive <code>value</code> <code>42</code>, <code>#t</code>, <code>#f</code>, <code>\"hello\"</code> Application <code>(proc args...)</code> <code>(+ 1 2 3)</code> Definition <code>(define name value)</code> <code>(define pi 3.14)</code> Procedure <code>(lambda (params) body)</code> <code>(lambda (x) (* x x))</code> Named Procedure <code>(define (name params) body)</code> <code>(define (square x) (* x x))</code> Conditional <code>(if test then else)</code> <code>(if (&gt; a b) a b)</code>"},{"location":"programming_languages/scheme_primer/#whats-next","title":"What's Next?","text":"<p>This primer covers the core of Scheme. To go deeper:</p> <ul> <li>Scheme &amp; Parse Trees \u2014 Understand why Scheme's syntax directly mirrors computation structure</li> <li>Procedures &amp; Higher-Order Functions \u2014 Explore the full power of functions as values</li> <li>Recursion \u2014 Dive deeper into recursive problem solving.</li> </ul>"},{"location":"programming_languages/scheme_primer/#further-reading","title":"Further Reading","text":"<ul> <li>Structure and Interpretation of Computer Programs (Abelson &amp; Sussman) \u2014 The classic MIT textbook</li> <li>Introduction to Computing (David Evans) \u2014 A key reference for learning Scheme</li> <li>Racket Documentation \u2014 Official guide to Racket/Scheme</li> <li>Teach Yourself Racket \u2014 University of Waterloo tutorial</li> <li>CSC 151 Course Materials \u2014 Grinnell College's introduction to Scheme</li> </ul> <p>Scheme's power lies in its simplicity. With just expressions, definitions, procedures, and conditionals, you can express any computation. The challenge isn't learning more syntax\u2014it's learning to think in terms of these fundamental building blocks.</p>"},{"location":"systems_architecture/cloud_and_edge_computing/","title":"Cloud and Edge Computing","text":"<p>For decades, the goal of computing was to make the personal computer as powerful as possible. But in the last 15 years, the strategy has shifted. Instead of doing everything on your own machine, we now use a massive, global network of shared resources. </p> <p>We call this Cloud Computing, and its newest evolution, Edge Computing.</p>"},{"location":"systems_architecture/cloud_and_edge_computing/#1-cloud-computing-the-giant-server","title":"1. Cloud Computing (The Giant Server)","text":"<p>\"The Cloud\" is not a physical place in the sky. It is simply a collection of massive data centers filled with thousands of servers that you can rent over the internet.</p>"},{"location":"systems_architecture/cloud_and_edge_computing/#the-three-service-models","title":"The Three Service Models:","text":"<ul> <li>IaaS (Infrastructure as a Service): You rent the \"raw\" hardware (Virtual Machines). You are responsible for the OS and the software. <ul> <li>Example: AWS EC2, DigitalOcean.</li> </ul> </li> <li>PaaS (Platform as a Service): You provide the code, and the provider manages the servers, OS, and scaling. <ul> <li>Example: Heroku, Google App Engine, Vercel.</li> </ul> </li> <li>SaaS (Software as a Service): You just use the application. Everything is managed for you.<ul> <li>Example: Gmail, Slack, Netflix, Microsoft 365.</li> </ul> </li> </ul> <p>The Benefit: Elasticity. You can scale from 1 user to 1 million users in seconds by just renting more virtual space.</p>"},{"location":"systems_architecture/cloud_and_edge_computing/#2-edge-computing-the-local-helper","title":"2. Edge Computing (The Local Helper)","text":"<p>Cloud computing is great, but it has one major weakness: Latency (Delay). </p> <p>If you have a self-driving car, it cannot wait 200 milliseconds for a cloud server in another country to decide if it should hit the brakes. The decision must be made instantly.</p> <p>Edge Computing moves the computation closer to the source of the data\u2014on the \"edge\" of the network.</p> <ul> <li>The Cloud: High power, far away, high latency.</li> <li>The Edge: Lower power, right next to you, zero latency.</li> </ul>"},{"location":"systems_architecture/cloud_and_edge_computing/#examples-of-edge-computing","title":"Examples of Edge Computing:","text":"<ul> <li>Smart Cameras: Processing video to detect a person inside the camera instead of sending the whole video stream to the cloud.</li> <li>Industrial Sensors: Monitoring a factory machine and shutting it down in milliseconds if it vibrates too much.</li> <li>Wearables: Your smartwatch calculating your heart rate locally instead of uploading raw data.</li> </ul>"},{"location":"systems_architecture/cloud_and_edge_computing/#3-the-hybrid-future","title":"3. The Hybrid Future","text":"<p>Modern systems use both.  -   The Edge handles real-time, mission-critical decisions. -   The Cloud handles long-term storage, big data analysis, and heavy AI training.</p>"},{"location":"systems_architecture/cloud_and_edge_computing/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Classify the Service <p>You use Spotify to listen to music. Which cloud model is this?</p> <p>A. IaaS B. PaaS C. SaaS</p> Solution <p>C. SaaS (Software as a Service).</p> <p>You aren't managing servers or writing code. you are just using the finished software provided by Spotify over the internet.</p> Practice Problem 2: Why Edge? <p>A hospital uses an AI system to monitor patients' vitals. If a patient's heart stops, an alarm must sound immediately. Why would the hospital prefer to run this AI on an Edge device in the room rather than in the Cloud?</p> Solution <p>Reliability and Latency. </p> <p>If the hospital's internet connection goes down, a Cloud-based alarm would fail. By running it on the Edge, the alarm works even without the internet. Additionally, the Edge device can respond instantly without the delay of sending data across the country.</p>"},{"location":"systems_architecture/cloud_and_edge_computing/#key-takeaways","title":"Key Takeaways","text":"Feature Cloud Computing Edge Computing Location Centralized Data Centers. Near the user/device. Power Massive. Limited. Latency Higher (100ms+). Very Low (&lt;10ms). Best For Big Data, Storage, Web Apps. Real-time, IoT, Privacy. <p>Computing is no longer a single box on your desk. It is a spectrum that stretches from the tiny chips in your watch (The Edge) to the warehouse-sized data centers of Amazon and Google (The Cloud). Understanding where to put your code on this spectrum is the key to modern system design.</p>"},{"location":"systems_architecture/internet_vs_www/","title":"The Internet vs. The World Wide Web","text":"<p>Most people use the terms \"Internet\" and \"Web\" interchangeably, but in computer science, they are completely different things. Confusing them is like confusing the tracks with the train, or the highway with the delivery truck.</p>"},{"location":"systems_architecture/internet_vs_www/#1-the-internet-the-tracks","title":"1. The Internet (The Tracks)","text":"<p>The Internet is the hardware and infrastructure. It is a \"Network of Networks.\" It consists of millions of miles of cables, thousands of routers, and billions of devices.</p> <p>The Internet's job is to move Packets (small chunks of data) from one IP address to another. It doesn't care what is inside the packets\u2014it just delivers them.</p> <p>Other things that run on the Internet (not the Web): -   Email (SMTP) -   File Transfers (FTP) -   Online Gaming (Custom protocols) -   Video Calls (VOIP/WebRTC)</p>"},{"location":"systems_architecture/internet_vs_www/#2-the-world-wide-web-the-train","title":"2. The World Wide Web (The Train)","text":"<p>The World Wide Web (or simply \"The Web\") is a service that runs on top of the Internet. It was invented by Tim Berners-Lee in 1989.</p> <p>The Web is a collection of linked documents (HTML files) and other resources (images, videos) that are identified by URLs (Uniform Resource Locators).</p> <p>The Web relies on three key technologies: 1.  HTML: The language used to write web pages. 2.  HTTP/HTTPS: The protocol used to send those pages over the internet. 3.  Web Browsers: The software used to render those pages for humans.</p>"},{"location":"systems_architecture/internet_vs_www/#3-dns-the-phone-book","title":"3. DNS: The Phone Book","text":"<p>Computers don't understand <code>google.com</code>. They understand IP addresses like <code>142.250.190.46</code>. </p> <p>The Domain Name System (DNS) is the \"phone book\" of the internet. When you type a URL into your browser: 1.  Your computer asks a DNS Server: \"What is the IP address for <code>google.com</code>?\" 2.  The DNS Server returns the IP address. 3.  Your browser then uses that IP to send a request over the Internet to get the Web page.</p>"},{"location":"systems_architecture/internet_vs_www/#summary-table","title":"Summary Table","text":"Feature The Internet The World Wide Web Analogy The Highway System. The Trucks and Cars. Consists of Cables, Routers, Servers. HTML, URLs, Browsers. Age Born in the 1960s (ARPANET). Born in 1989 (CERN). Purpose To move data packets. To share linked documents."},{"location":"systems_architecture/internet_vs_www/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: True or False? <p>\"If the World Wide Web crashed today, I would still be able to send an email.\"</p> Solution <p>True. </p> <p>Email uses a different protocol (SMTP) that runs directly on the Internet. While many people use Web-based email (like Gmail in a browser), the underlying email system is independent of the Web.</p> Practice Problem 2: Identify the Technology <p>You type <code>https://cs.bradpenney.io</code> into your browser. Which part of this is an Internet technology and which is a Web technology?</p> Solution <ul> <li>Internet: The IP routing that finds the server, and the TCP connection that ensures the data arrives.</li> <li>Web: The <code>https</code> protocol, the URL, and the HTML content of the page you are requesting.</li> </ul>"},{"location":"systems_architecture/internet_vs_www/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>The Internet is the physical and logical infrastructure for communication.</li> <li>The World Wide Web is a system of interlinked hypertext documents accessed via the Internet.</li> <li>DNS bridges the gap between human-friendly names and computer-friendly IP addresses.</li> </ul> <p>By distinguishing the infrastructure (Internet) from the application (Web), we can better understand how the digital world is layered. The Internet provides the \"connectivity,\" while the Web provides the \"content.\"</p>"},{"location":"systems_architecture/network_fundamentals/","title":"Network Fundamentals","text":"<p>In the early days of computing, a computer was an \"island.\" To move data from one machine to another, you had to save it to a physical tape or disc and walk it over. Today, computing is defined by connectivity.</p> <p>A Computer Network is simply two or more computers connected together so they can share resources and data.</p>"},{"location":"systems_architecture/network_fundamentals/#1-scope-lan-vs-wan","title":"1. Scope: LAN vs. WAN","text":"<p>We categorize networks by how much distance they cover.</p> <ul> <li>LAN (Local Area Network): A network in a small geographic area, like your house, an office, or a coffee shop. High speed, low cost, and privately owned.</li> <li>WAN (Wide Area Network): A network that spans a large distance\u2014a city, a country, or the entire planet. The Internet is the largest WAN in existence.</li> </ul>"},{"location":"systems_architecture/network_fundamentals/#2-topologies-the-shape-of-the-network","title":"2. Topologies: The Shape of the Network","text":"<p>The \"Topology\" of a network describes how the devices are physically or logically connected.</p> <ul> <li>Star Topology: Every device connects to a central \"Hub\" or \"Switch.\" (This is what your home Wi-Fi router does).<ul> <li>Pros: If one cable breaks, only one computer goes down.</li> <li>Cons: If the central hub breaks, the whole network dies.</li> </ul> </li> <li>Mesh Topology: Every device connects to every other device.<ul> <li>Pros: Extremely reliable (no single point of failure).</li> <li>Cons: Very expensive and complex to wire.</li> </ul> </li> <li>Bus Topology: All devices share a single backbone cable. (Rare today).</li> </ul>"},{"location":"systems_architecture/network_fundamentals/#3-communication-links","title":"3. Communication Links","text":"<p>How does the data actually move? We split links into two categories:</p>"},{"location":"systems_architecture/network_fundamentals/#guided-media-cables","title":"Guided Media (Cables)","text":"<ul> <li>Ethernet (Copper): Uses electrical signals. Fast and cheap, but limited to short distances (100 meters).</li> <li>Fiber Optics (Glass): Uses pulses of light. Incredibly fast and can travel miles without losing signal. This is what connects continents under the ocean.</li> </ul>"},{"location":"systems_architecture/network_fundamentals/#unguided-media-wireless","title":"Unguided Media (Wireless)","text":"<ul> <li>Wi-Fi: Radio waves for short distances.</li> <li>Satellite: Microwave signals bounced off satellites in orbit. High latency (delay) because the signal has to travel to space and back.</li> <li>Cellular (4G/5G): Wide-area wireless for mobile devices.</li> </ul>"},{"location":"systems_architecture/network_fundamentals/#4-network-protocols-the-language-of-the-link","title":"4. Network Protocols: The Language of the Link","text":"<p>For two computers to talk, they must agree on a set of rules. These rules are called Protocols.</p> <ul> <li>IP (Internet Protocol): How to address and route data.</li> <li>TCP (Transmission Control Protocol): How to ensure data arrives correctly and in order.</li> <li>Ethernet Protocol: How to send electrical signals over a wire without \"crashing\" into other signals.</li> </ul>"},{"location":"systems_architecture/network_fundamentals/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Choosing a Topology <p>You are designing a network for a high-security military base where the network must stay up even if several cables are cut. Which topology would you choose?</p> Solution <p>Mesh Topology. </p> <p>Because every node is connected to multiple others, there are many redundant paths. If one path is cut, the data can simply be rerouted through another neighbor.</p> Practice Problem 2: LAN vs. WAN <p>Is your home Wi-Fi network a LAN or a WAN?</p> Solution <p>LAN. </p> <p>It is a small, privately owned network covering a single building. However, your LAN is connected to a WAN (the Internet) through your Internet Service Provider (ISP).</p>"},{"location":"systems_architecture/network_fundamentals/#key-takeaways","title":"Key Takeaways","text":"Concept Meaning LAN Small area (Home/Office). WAN Large area (The Internet). Star Topology All connected to a center point. Guided Media Physical wires (Copper/Fiber). Protocol The \"rules of conversation\" for computers. <p>Network fundamentals are the \"plumbing\" of the digital age. By understanding how the pipes are laid and how the water (data) flows, we can build systems that are faster, more reliable, and more connected than ever before.</p>"},{"location":"systems_architecture/operating_system_basics/","title":"Operating System Basics","text":"<p>When you turn on your computer, you aren't just running a web browser or a game. You are running a massive, complex program that manages everything else. This program is the Operating System (OS).</p> <p>The OS is the government of your computer. It controls the resources (CPU, RAM, Disk), enforces laws (Security, Permissions), and provides services to its citizens (Applications).</p>"},{"location":"systems_architecture/operating_system_basics/#the-kernel-the-core","title":"The Kernel: The Core","text":"<p>At the heart of every OS (Linux, Windows, macOS) is the Kernel. </p> <p>The Kernel is the first program loaded when the computer starts, and it stays in memory until the computer shuts down. It has complete control over every piece of hardware.</p>"},{"location":"systems_architecture/operating_system_basics/#key-responsibilities","title":"Key Responsibilities:","text":"<ol> <li>Process Management: Deciding which program gets to use the CPU.</li> <li>Memory Management: Deciding which program gets which part of RAM.</li> <li>Device Drivers: Talking to keyboards, screens, and Wi-Fi cards.</li> <li>File Systems: Organizing data on the disk.</li> </ol>"},{"location":"systems_architecture/operating_system_basics/#user-mode-vs-kernel-mode","title":"User Mode vs. Kernel Mode","text":"<p>To prevent a buggy web browser from crashing the entire computer, modern CPUs run in two different modes:</p> <ol> <li>User Mode (Ring 3): This is where your applications run. It is \"restricted.\" You cannot directly access hardware or memory that belongs to other programs. If you try, the CPU stops you and crashes your program (Segfault).</li> <li>Kernel Mode (Ring 0): This is where the Kernel runs. It has \"unrestricted\" access to everything. It can overwrite memory, stop the CPU, or wipe the disk.</li> </ol>"},{"location":"systems_architecture/operating_system_basics/#system-calls-asking-for-permission","title":"System Calls: Asking for Permission","text":"<p>If a User Mode program (like Chrome) needs to save a file (which requires talking to the hard drive), it cannot do it directly. It must ask the Kernel for help.</p> <p>This request is called a System Call (syscall).</p> <ol> <li>Application: \"Hey Kernel, please write this data to <code>file.txt</code>.\" (Executes a syscall instruction).</li> <li>CPU: Switches from User Mode to Kernel Mode.</li> <li>Kernel: Checks permissions. \"Does this user own <code>file.txt</code>?\"</li> <li>Kernel: Writes the data to the disk.</li> <li>Kernel: Returns \"Success\" to the application.</li> <li>CPU: Switches back to User Mode.</li> </ol> <p>This context switching is expensive, which is why high-performance software tries to minimize system calls.</p>"},{"location":"systems_architecture/operating_system_basics/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: The Crash <p>If a video game has a bug and tries to access memory that belongs to the Operating System, what happens?</p> <p>A. The entire computer crashes (Blue Screen of Death). B. The video game crashes, but the OS stays running. C. The OS automatically fixes the bug.</p> Solution <p>B. The video game crashes.</p> <p>Because the game runs in User Mode, the hardware prevents it from touching Kernel memory. The CPU detects the illegal attempt and tells the OS, which then kills the game process to protect the system.</p> Practice Problem 2: The Role of Drivers <p>Why do you need to install \"Drivers\" for a new graphics card?</p> Solution <p>The Kernel needs to know how to talk to the specific hardware. A Device Driver is a piece of code that translates the Kernel's generic commands (e.g., \"Draw this pixel\") into the specific electrical signals understood by that brand of graphics card.</p>"},{"location":"systems_architecture/operating_system_basics/#key-takeaways","title":"Key Takeaways","text":"Component Role OS The manager of hardware and software resources. Kernel The core program that runs in privileged mode. User Mode Restricted mode for applications (Safe). Kernel Mode Unrestricted mode for the OS (Powerful/Dangerous). System Call The bridge between User Mode and Kernel Mode. <p>The Operating System is the unsung hero of computing. It virtualizes the messy reality of hardware into a clean, consistent interface for programmers. Without it, every program would have to be its own operating system.</p>"},{"location":"systems_architecture/processes_and_threads/","title":"Processes and Threads","text":"<p>Right now, you probably have a browser, a music player, a code editor, and a terminal open. It feels like your computer is doing all of them at once.</p> <p>Unless you have a 64-core supercomputer, this is mostly an illusion. The CPU switches between tasks so quickly (thousands of times per second) that it looks like they are simultaneous. This magic is managed by Processes and Threads.</p>"},{"location":"systems_architecture/processes_and_threads/#1-the-process","title":"1. The Process","text":"<p>A Process is a program in execution. </p> <p>When you double-click an icon, the OS creates a process. It gives that process: -   Memory Space: A private chunk of RAM that no other process can touch. -   Resources: Open files, network connections, etc. -   Security Context: Which user owns this process?</p> <p>Key Feature: Processes are Isolated. If one process crashes, it doesn't kill the others. If Chrome crashes, Spotify keeps playing.</p>"},{"location":"systems_architecture/processes_and_threads/#2-the-thread","title":"2. The Thread","text":"<p>A Thread is a \"lightweight process\" that lives inside a process.</p> <p>A single process can have multiple threads. -   Thread 1: Render the User Interface. -   Thread 2: Download a file in the background. -   Thread 3: Save data to disk.</p> <p>Key Feature: Threads Share Memory. All threads in a process can see the same variables. This makes communication fast, but dangerous (Race Conditions).</p>"},{"location":"systems_architecture/processes_and_threads/#context-switching","title":"Context Switching","text":"<p>How does the OS multitask? It uses Context Switching.</p> <ol> <li>Stop: The CPU pauses Process A.</li> <li>Save: It saves the \"State\" of Process A (Variable values, program counter) to RAM.</li> <li>Load: It loads the saved \"State\" of Process B.</li> <li>Go: The CPU starts running Process B.</li> </ol> <p>This happens in microseconds. However, it isn't free. If you switch too often, the CPU spends more time switching than working (this is called \"Thrashing\").</p>"},{"location":"systems_architecture/processes_and_threads/#concurrency-vs-parallelism","title":"Concurrency vs. Parallelism","text":"<ul> <li>Concurrency: Dealing with multiple things at once. (e.g., A single chef chopping onions, then stirring the pot, then checking the oven).</li> <li> <p>Parallelism: Doing multiple things at the same time. (e.g., Three chefs in the kitchen, one chopping, one stirring, one checking).</p> </li> <li> <p>Single Core CPU: Can do Concurrency (via Context Switching), but not true Parallelism.</p> </li> <li>Multi-Core CPU: Can do true Parallelism (Core 1 runs Chrome, Core 2 runs Spotify).</li> </ul>"},{"location":"systems_architecture/processes_and_threads/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Crash Impact <ul> <li>Scenario A: A Thread in your browser crashes.</li> <li>Scenario B: A Process (a tab) in your browser crashes.</li> </ul> <p>Which scenario is worse for the whole browser application?</p> Solution <p>Scenario A is usually worse.</p> <p>Since threads share memory, a crash in one thread (like accessing bad memory) often corrupts the entire process, causing the whole browser to close.</p> <p>Modern browsers (like Chrome) actually use a Multi-Process Architecture, where every tab is a separate Process. If one tab crashes, the others survive.</p> Practice Problem 2: Resource Cost <p>Which is \"cheaper\" to create: a new Process or a new Thread?</p> Solution <p>A new Thread.</p> <p>Creating a process requires allocating a whole new memory map and OS resources. Creating a thread just requires a small stack and registers within the existing memory.</p>"},{"location":"systems_architecture/processes_and_threads/#key-takeaways","title":"Key Takeaways","text":"Feature Process Thread Analogy A House. The People living in the house. Memory Private / Isolated. Shared (Risky). Creation Cost High (Heavyweight). Low (Lightweight). Communication Slow (IPC). Fast (Shared Variables). <p>Processes give us stability and isolation. Threads give us speed and responsiveness. Modern software architecture is the art of balancing these two tools to create systems that are both robust and fast.</p>"},{"location":"systems_architecture/virtual_machines/","title":"Virtual Machines","text":"<p>In the movie The Matrix, the characters live in a simulated world that looks and feels real, but is actually running inside a computer.</p> <p>In computer science, a Virtual Machine (VM) is exactly that: a software implementation of a computer that executes programs just like a physical machine.</p> <p>There are two distinct types of VMs, and it is important not to confuse them.</p>"},{"location":"systems_architecture/virtual_machines/#1-system-virtual-machines-the-hardware-simulators","title":"1. System Virtual Machines (The \"Hardware\" Simulators)","text":"<p>This is what you think of when you hear \"VMWare\" or \"VirtualBox.\"</p> <p>A System VM allows you to run an entire Guest Operating System inside your Host Operating System.</p> <ul> <li>Example: You have a Windows laptop (Host), but you open a window that is running Linux (Guest).</li> <li>How it works: Software called a Hypervisor sits between the physical hardware and the VMs. It tricks the Guest OS into thinking it has its own CPU, RAM, and Hard Drive, but the Hypervisor is actually doling out resources from the real physical machine.</li> </ul> <p>Use Cases: -   Cloud Computing: AWS and Azure run thousands of VMs on massive servers. -   Testing: Test your code on Linux without reformatting your Windows laptop. -   Sandboxing: Run a virus in a VM to study it without infecting your real computer.</p>"},{"location":"systems_architecture/virtual_machines/#2-process-virtual-machines-the-software-interpreters","title":"2. Process Virtual Machines (The \"Software\" Interpreters)","text":"<p>This is what Java and Python use.</p> <p>A Process VM doesn't simulate hardware; it simulates an Abstract Computer. It allows you to run a program on any operating system, as long as that OS has the VM installed.</p> <ul> <li>Example: The Java Virtual Machine (JVM).</li> <li>How it works: <ol> <li>You write Java code.</li> <li>You compile it into Bytecode (<code>.class</code> files).</li> <li>The JVM translates that Bytecode into the specific Machine Code for the computer it is running on (Windows, Mac, or Linux).</li> </ol> </li> </ul> <p>The Promise: \"Write Once, Run Anywhere.\"</p> <p>Use Cases: -   Cross-Platform Apps: Minecraft (Java) runs on everything because the JVM runs on everything. -   Security: The VM can strictly limit what the program is allowed to do (e.g., prevent it from reading your files).</p>"},{"location":"systems_architecture/virtual_machines/#comparison","title":"Comparison","text":"Feature System VM Process VM Simulates An entire physical computer (CPU, Disk, Network). An abstract execution environment. Input A full Operating System (ISO). Compiled Bytecode. Goal Run multiple OSes on one machine. Run one app on multiple OSes. Examples VirtualBox, VMWare, EC2, KVM. JVM (Java), CLR (.NET), PVM (Python)."},{"location":"systems_architecture/virtual_machines/#practice-problems","title":"Practice Problems","text":"Practice Problem 1: Cloud Hosting <p>Amazon Web Services (AWS) allows you to rent a \"Server.\" You get full root access to install Windows or Linux. Is this a System VM or a Process VM?</p> Solution <p>System VM.</p> <p>You are running a full Operating System. AWS uses a Hypervisor (like Xen or KVM) to slice up their massive physical servers into smaller virtual servers for customers.</p> Practice Problem 2: Portability <p>Why does compiling C++ code usually produce an <code>.exe</code> that only works on Windows, while compiling Java produces a <code>.class</code> file that works on Windows and Mac?</p> Solution <p>C++ compiles directly to Machine Code for a specific CPU and OS. </p> <p>Java compiles to Bytecode for the Java Virtual Machine. Since there is a version of the JVM for Windows and a version for Mac, the same bytecode runs on both.</p>"},{"location":"systems_architecture/virtual_machines/#key-takeaways","title":"Key Takeaways","text":"Term Definition Hypervisor The software that manages System VMs. Guest OS The OS running inside the VM. Host OS The OS running on the physical hardware. Bytecode The universal language spoken by Process VMs. <p>Virtualization is the foundation of the modern internet. It decouples software from hardware, allowing us to treat computing power as a utility that can be sliced, diced, and moved around the world instantly.</p>"}]}